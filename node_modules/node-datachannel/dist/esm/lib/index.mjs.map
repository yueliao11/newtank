{"version":3,"file":"index.mjs","sources":["../../../src/lib/index.ts"],"sourcesContent":["import nodeDataChannel from './node-datachannel';\nimport _DataChannelStream from './datachannel-stream';\nimport { WebSocketServer } from './websocket-server';\nimport { Channel, DataChannelInitConfig, DescriptionType, Direction, LogLevel, RtcConfig, RTCIceConnectionState, RTCIceGatheringState, RTCPeerConnectionState, RTCSignalingState, SctpSettings, SelectedCandidateInfo } from './types';\nimport { WebSocket } from './websocket';\n\nexport function preload(): void { nodeDataChannel.preload(); }\nexport function initLogger(level: LogLevel): void { nodeDataChannel.initLogger(level); }\nexport function cleanup(): void { nodeDataChannel.cleanup(); }\nexport function setSctpSettings(settings: SctpSettings): void { nodeDataChannel.setSctpSettings(settings); }\nexport function getLibraryVersion(): string { return nodeDataChannel.getLibraryVersion(); }\n\nexport interface Audio {\n    addAudioCodec(payloadType: number, codec: string, profile?: string): void;\n    addOpusCodec(payloadType: number, profile?: string): string;\n    direction(): Direction;\n    generateSdp(eol: string, addr: string, port: number): string;\n    mid(): string;\n    setDirection(dir: Direction): void;\n    description(): string;\n    removeFormat(fmt: string): void;\n    addSSRC(ssrc: number, name?: string, msid?: string, trackID?: string): void;\n    removeSSRC(ssrc: number): void;\n    replaceSSRC(oldSsrc: number, ssrc: number, name?: string, msid?: string, trackID?: string): void;\n    hasSSRC(ssrc: number): boolean;\n    getSSRCs(): number[];\n    getCNameForSsrc(ssrc: number): string;\n    setBitrate(bitRate: number): void;\n    getBitrate(): number;\n    hasPayloadType(payloadType: number): boolean;\n    addRTXCodec(payloadType: number, originalPayloadType: number, clockRate: number): void;\n    addRTPMap(): void;\n    parseSdpLine(line: string): void;\n}\nexport const Audio: {\n    new(mid: string, dir: Direction): Audio\n} = nodeDataChannel.Audio\n\n\nexport interface Video {\n    addVideoCodec(payloadType: number, codec: string, profile?: string): void;\n    addH264Codec(payloadType: number, profile?: string): void;\n    addVP8Codec(payloadType: number): void;\n    addVP9Codec(payloadType: number): void;\n    direction(): Direction;\n    generateSdp(eol: string, addr: string, port: number): string;\n    mid(): string;\n    setDirection(dir: Direction): void;\n    description(): string;\n    removeFormat(fmt: string): void;\n    addSSRC(ssrc: number, name?: string, msid?: string, trackID?: string): void;\n    removeSSRC(ssrc: number): void;\n    replaceSSRC(oldSsrc: number, ssrc: number, name?: string, msid?: string, trackID?: string): void;\n    hasSSRC(ssrc: number): boolean;\n    getSSRCs(): number[];\n    getCNameForSsrc(ssrc: number): string;\n    setBitrate(bitRate: number): void;\n    getBitrate(): number;\n    hasPayloadType(payloadType: number): boolean;\n    addRTXCodec(payloadType: number, originalPayloadType: number, clockRate: number): void;\n    addRTPMap(): void;\n    parseSdpLine(line: string): void;\n}\nexport const Video: {\n    new(mid: string, dir: Direction): Video\n} = nodeDataChannel.Video\n\nexport interface Track {\n    direction(): Direction;\n    mid(): string;\n    type(): string;\n    close(): void;\n    sendMessage(msg: string): boolean;\n    sendMessageBinary(buffer: Buffer): boolean;\n    isOpen(): boolean;\n    isClosed(): boolean;\n    bufferedAmount(): number;\n    maxMessageSize(): number;\n    requestBitrate(bitRate: number): boolean;\n    setBufferedAmountLowThreshold(newSize: number): void;\n    requestKeyframe(): boolean;\n    setMediaHandler(handler: RtcpReceivingSession): void;\n    onOpen(cb: () => void): void;\n    onClosed(cb: () => void): void;\n    onError(cb: (err: string) => void): void;\n    onMessage(cb: (msg: Buffer) => void): void;\n}\nexport const Track: {\n    new(): Track\n} = nodeDataChannel.Track\n\nexport interface DataChannel extends Channel {\n    getLabel(): string;\n    getId(): number;\n    getProtocol(): string;\n\n    // Channel implementation\n    close(): void;\n    sendMessage(msg: string): boolean;\n    sendMessageBinary(buffer: Buffer | Uint8Array): boolean;\n    isOpen(): boolean;\n    bufferedAmount(): number;\n    maxMessageSize(): number;\n    setBufferedAmountLowThreshold(newSize: number): void;\n    onOpen(cb: () => void): void;\n    onClosed(cb: () => void): void;\n    onError(cb: (err: string) => void): void;\n    onBufferedAmountLow(cb: () => void): void;\n    onMessage(cb: (msg: string | Buffer | ArrayBuffer) => void): void;\n}\nexport const DataChannel: {\n    // DataChannel implementation\n} = nodeDataChannel.DataChannel\n\nexport interface PeerConnection {\n    close(): void;\n    setLocalDescription(type?: DescriptionType): void;\n    setRemoteDescription(sdp: string, type: DescriptionType): void;\n    localDescription(): { type: DescriptionType; sdp: string } | null;\n    remoteDescription(): { type: DescriptionType; sdp: string } | null;\n    addRemoteCandidate(candidate: string, mid: string): void;\n    createDataChannel(label: string, config?: DataChannelInitConfig): DataChannel;\n    addTrack(media: Video | Audio): Track;\n    hasMedia(): boolean;\n    state(): RTCPeerConnectionState;\n    iceState(): RTCIceConnectionState;\n    signalingState(): RTCSignalingState;\n    gatheringState(): RTCIceGatheringState;\n    onLocalDescription(cb: (sdp: string, type: DescriptionType) => void): void;\n    onLocalCandidate(cb: (candidate: string, mid: string) => void): void;\n    onStateChange(cb: (state: string) => void): void;\n    onIceStateChange(cb: (state: string) => void): void;\n    onSignalingStateChange(cb: (state: string) => void): void;\n    onGatheringStateChange(cb: (state: string) => void): void;\n    onDataChannel(cb: (dc: DataChannel) => void): void;\n    onTrack(cb: (track: Track) => void): void;\n    bytesSent(): number;\n    bytesReceived(): number;\n    rtt(): number;\n    getSelectedCandidatePair(): { local: SelectedCandidateInfo; remote: SelectedCandidateInfo } | null;\n    maxDataChannelId(): number;\n    maxMessageSize(): number;\n}\nexport const PeerConnection: {\n    new(peerName: string, config: RtcConfig): PeerConnection\n} = nodeDataChannel.PeerConnection\n\nexport class RtcpReceivingSession {\n    //\n}\n\nexport { WebSocketServer } from './websocket-server';\nexport { WebSocket } from './websocket';\n\nexport const DataChannelStream = _DataChannelStream;\n\nexport default {\n    initLogger,\n    cleanup,\n    preload,\n    setSctpSettings,\n    getLibraryVersion,\n    RtcpReceivingSession,\n    Track,\n    Video,\n    Audio,\n    DataChannel,\n    PeerConnection,\n    WebSocket,\n    WebSocketServer,\n    DataChannelStream\n};\n\n\n// Types\n// https://github.com/murat-dogan/node-datachannel/issues/300\nexport *  from './types';\n"],"names":["_DataChannelStream"],"mappings":";;;;;AAMO,SAAS,OAAgB,GAAA;AAAE,EAAA,eAAA,CAAgB,OAAQ,EAAA,CAAA;AAAG,CAAA;AACtD,SAAS,WAAW,KAAuB,EAAA;AAAE,EAAA,eAAA,CAAgB,WAAW,KAAK,CAAA,CAAA;AAAG,CAAA;AAChF,SAAS,OAAgB,GAAA;AAAE,EAAA,eAAA,CAAgB,OAAQ,EAAA,CAAA;AAAG,CAAA;AACtD,SAAS,gBAAgB,QAA8B,EAAA;AAAE,EAAA,eAAA,CAAgB,gBAAgB,QAAQ,CAAA,CAAA;AAAG,CAAA;AACpG,SAAS,iBAA4B,GAAA;AAAE,EAAA,OAAO,gBAAgB,iBAAkB,EAAA,CAAA;AAAG,CAAA;AAwBnF,MAAM,QAET,eAAgB,CAAA,MAAA;AA2Bb,MAAM,QAET,eAAgB,CAAA,MAAA;AAsBb,MAAM,QAET,eAAgB,CAAA,MAAA;AAqBb,MAAM,cAET,eAAgB,CAAA,YAAA;AA+Bb,MAAM,iBAET,eAAgB,CAAA,eAAA;AAEb,MAAM,oBAAqB,CAAA;AAAA;AAElC,CAAA;AAKO,MAAM,iBAAoB,GAAAA,oBAAA;AAEjC,QAAe;AAAA,EACX,UAAA;AAAA,EACA,OAAA;AAAA,EACA,OAAA;AAAA,EACA,eAAA;AAAA,EACA,iBAAA;AAAA,EACA,oBAAA;AAAA,EACA,KAAA;AAAA,EACA,KAAA;AAAA,EACA,KAAA;AAAA,EACA,WAAA;AAAA,EACA,cAAA;AAAA,EACA,SAAA;AAAA,EACA,eAAA;AAAA,EACA,iBAAA;AACJ,CAAA;;;;"}