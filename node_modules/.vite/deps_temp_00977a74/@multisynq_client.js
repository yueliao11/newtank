import {
  __commonJS,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/toastify-js/src/toastify.js
var require_toastify = __commonJS({
  "node_modules/toastify-js/src/toastify.js"(exports, module) {
    (function(root, factory) {
      if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else {
        root.Toastify = factory();
      }
    })(exports, function(global2) {
      var Toastify = function(options) {
        return new Toastify.lib.init(options);
      }, version = "1.12.0";
      Toastify.defaults = {
        oldestFirst: true,
        text: "Toastify is awesome!",
        node: void 0,
        duration: 3e3,
        selector: void 0,
        callback: function() {
        },
        destination: void 0,
        newWindow: false,
        close: false,
        gravity: "toastify-top",
        positionLeft: false,
        position: "",
        backgroundColor: "",
        avatar: "",
        className: "",
        stopOnFocus: true,
        onClick: function() {
        },
        offset: { x: 0, y: 0 },
        escapeMarkup: true,
        ariaLive: "polite",
        style: { background: "" }
      };
      Toastify.lib = Toastify.prototype = {
        toastify: version,
        constructor: Toastify,
        // Initializing the object with required parameters
        init: function(options) {
          if (!options) {
            options = {};
          }
          this.options = {};
          this.toastElement = null;
          this.options.text = options.text || Toastify.defaults.text;
          this.options.node = options.node || Toastify.defaults.node;
          this.options.duration = options.duration === 0 ? 0 : options.duration || Toastify.defaults.duration;
          this.options.selector = options.selector || Toastify.defaults.selector;
          this.options.callback = options.callback || Toastify.defaults.callback;
          this.options.destination = options.destination || Toastify.defaults.destination;
          this.options.newWindow = options.newWindow || Toastify.defaults.newWindow;
          this.options.close = options.close || Toastify.defaults.close;
          this.options.gravity = options.gravity === "bottom" ? "toastify-bottom" : Toastify.defaults.gravity;
          this.options.positionLeft = options.positionLeft || Toastify.defaults.positionLeft;
          this.options.position = options.position || Toastify.defaults.position;
          this.options.backgroundColor = options.backgroundColor || Toastify.defaults.backgroundColor;
          this.options.avatar = options.avatar || Toastify.defaults.avatar;
          this.options.className = options.className || Toastify.defaults.className;
          this.options.stopOnFocus = options.stopOnFocus === void 0 ? Toastify.defaults.stopOnFocus : options.stopOnFocus;
          this.options.onClick = options.onClick || Toastify.defaults.onClick;
          this.options.offset = options.offset || Toastify.defaults.offset;
          this.options.escapeMarkup = options.escapeMarkup !== void 0 ? options.escapeMarkup : Toastify.defaults.escapeMarkup;
          this.options.ariaLive = options.ariaLive || Toastify.defaults.ariaLive;
          this.options.style = options.style || Toastify.defaults.style;
          if (options.backgroundColor) {
            this.options.style.background = options.backgroundColor;
          }
          return this;
        },
        // Building the DOM element
        buildToast: function() {
          if (!this.options) {
            throw "Toastify is not initialized";
          }
          var divElement = document.createElement("div");
          divElement.className = "toastify on " + this.options.className;
          if (!!this.options.position) {
            divElement.className += " toastify-" + this.options.position;
          } else {
            if (this.options.positionLeft === true) {
              divElement.className += " toastify-left";
              console.warn("Property `positionLeft` will be depreciated in further versions. Please use `position` instead.");
            } else {
              divElement.className += " toastify-right";
            }
          }
          divElement.className += " " + this.options.gravity;
          if (this.options.backgroundColor) {
            console.warn('DEPRECATION NOTICE: "backgroundColor" is being deprecated. Please use the "style.background" property.');
          }
          for (var property in this.options.style) {
            divElement.style[property] = this.options.style[property];
          }
          if (this.options.ariaLive) {
            divElement.setAttribute("aria-live", this.options.ariaLive);
          }
          if (this.options.node && this.options.node.nodeType === Node.ELEMENT_NODE) {
            divElement.appendChild(this.options.node);
          } else {
            if (this.options.escapeMarkup) {
              divElement.innerText = this.options.text;
            } else {
              divElement.innerHTML = this.options.text;
            }
            if (this.options.avatar !== "") {
              var avatarElement = document.createElement("img");
              avatarElement.src = this.options.avatar;
              avatarElement.className = "toastify-avatar";
              if (this.options.position == "left" || this.options.positionLeft === true) {
                divElement.appendChild(avatarElement);
              } else {
                divElement.insertAdjacentElement("afterbegin", avatarElement);
              }
            }
          }
          if (this.options.close === true) {
            var closeElement = document.createElement("button");
            closeElement.type = "button";
            closeElement.setAttribute("aria-label", "Close");
            closeElement.className = "toast-close";
            closeElement.innerHTML = "&#10006;";
            closeElement.addEventListener(
              "click",
              (function(event) {
                event.stopPropagation();
                this.removeElement(this.toastElement);
                window.clearTimeout(this.toastElement.timeOutValue);
              }).bind(this)
            );
            var width = window.innerWidth > 0 ? window.innerWidth : screen.width;
            if ((this.options.position == "left" || this.options.positionLeft === true) && width > 360) {
              divElement.insertAdjacentElement("afterbegin", closeElement);
            } else {
              divElement.appendChild(closeElement);
            }
          }
          if (this.options.stopOnFocus && this.options.duration > 0) {
            var self2 = this;
            divElement.addEventListener(
              "mouseover",
              function(event) {
                window.clearTimeout(divElement.timeOutValue);
              }
            );
            divElement.addEventListener(
              "mouseleave",
              function() {
                divElement.timeOutValue = window.setTimeout(
                  function() {
                    self2.removeElement(divElement);
                  },
                  self2.options.duration
                );
              }
            );
          }
          if (typeof this.options.destination !== "undefined") {
            divElement.addEventListener(
              "click",
              (function(event) {
                event.stopPropagation();
                if (this.options.newWindow === true) {
                  window.open(this.options.destination, "_blank");
                } else {
                  window.location = this.options.destination;
                }
              }).bind(this)
            );
          }
          if (typeof this.options.onClick === "function" && typeof this.options.destination === "undefined") {
            divElement.addEventListener(
              "click",
              (function(event) {
                event.stopPropagation();
                this.options.onClick();
              }).bind(this)
            );
          }
          if (typeof this.options.offset === "object") {
            var x = getAxisOffsetAValue("x", this.options);
            var y = getAxisOffsetAValue("y", this.options);
            var xOffset = this.options.position == "left" ? x : "-" + x;
            var yOffset = this.options.gravity == "toastify-top" ? y : "-" + y;
            divElement.style.transform = "translate(" + xOffset + "," + yOffset + ")";
          }
          return divElement;
        },
        // Displaying the toast
        showToast: function() {
          this.toastElement = this.buildToast();
          var rootElement;
          if (typeof this.options.selector === "string") {
            rootElement = document.getElementById(this.options.selector);
          } else if (this.options.selector instanceof HTMLElement || typeof ShadowRoot !== "undefined" && this.options.selector instanceof ShadowRoot) {
            rootElement = this.options.selector;
          } else {
            rootElement = document.body;
          }
          if (!rootElement) {
            throw "Root element is not defined";
          }
          var elementToInsert = Toastify.defaults.oldestFirst ? rootElement.firstChild : rootElement.lastChild;
          rootElement.insertBefore(this.toastElement, elementToInsert);
          Toastify.reposition();
          if (this.options.duration > 0) {
            this.toastElement.timeOutValue = window.setTimeout(
              (function() {
                this.removeElement(this.toastElement);
              }).bind(this),
              this.options.duration
            );
          }
          return this;
        },
        hideToast: function() {
          if (this.toastElement.timeOutValue) {
            clearTimeout(this.toastElement.timeOutValue);
          }
          this.removeElement(this.toastElement);
        },
        // Removing the element from the DOM
        removeElement: function(toastElement) {
          toastElement.className = toastElement.className.replace(" on", "");
          window.setTimeout(
            (function() {
              if (this.options.node && this.options.node.parentNode) {
                this.options.node.parentNode.removeChild(this.options.node);
              }
              if (toastElement.parentNode) {
                toastElement.parentNode.removeChild(toastElement);
              }
              this.options.callback.call(toastElement);
              Toastify.reposition();
            }).bind(this),
            400
          );
        }
      };
      Toastify.reposition = function() {
        var topLeftOffsetSize = {
          top: 15,
          bottom: 15
        };
        var topRightOffsetSize = {
          top: 15,
          bottom: 15
        };
        var offsetSize = {
          top: 15,
          bottom: 15
        };
        var allToasts = document.getElementsByClassName("toastify");
        var classUsed;
        for (var i2 = 0; i2 < allToasts.length; i2++) {
          if (containsClass(allToasts[i2], "toastify-top") === true) {
            classUsed = "toastify-top";
          } else {
            classUsed = "toastify-bottom";
          }
          var height = allToasts[i2].offsetHeight;
          classUsed = classUsed.substr(9, classUsed.length - 1);
          var offset = 15;
          var width = window.innerWidth > 0 ? window.innerWidth : screen.width;
          if (width <= 360) {
            allToasts[i2].style[classUsed] = offsetSize[classUsed] + "px";
            offsetSize[classUsed] += height + offset;
          } else {
            if (containsClass(allToasts[i2], "toastify-left") === true) {
              allToasts[i2].style[classUsed] = topLeftOffsetSize[classUsed] + "px";
              topLeftOffsetSize[classUsed] += height + offset;
            } else {
              allToasts[i2].style[classUsed] = topRightOffsetSize[classUsed] + "px";
              topRightOffsetSize[classUsed] += height + offset;
            }
          }
        }
        return this;
      };
      function getAxisOffsetAValue(axis, options) {
        if (options.offset[axis]) {
          if (isNaN(options.offset[axis])) {
            return options.offset[axis];
          } else {
            return options.offset[axis] + "px";
          }
        }
        return "0px";
      }
      function containsClass(elem, yourClass) {
        if (!elem || typeof yourClass !== "string") {
          return false;
        } else if (elem.className && elem.className.trim().split(/\s+/gi).indexOf(yourClass) > -1) {
          return true;
        } else {
          return false;
        }
      }
      Toastify.lib.init.prototype = Toastify.lib;
      return Toastify;
    });
  }
});

// node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS({
  "node_modules/fast-json-stable-stringify/index.js"(exports, module) {
    "use strict";
    module.exports = function(data, opts) {
      if (!opts) opts = {};
      if (typeof opts === "function") opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && /* @__PURE__ */ function(f) {
        return function(node) {
          return function(a2, b) {
            var aobj = { key: a2, value: node[a2] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return function stringify(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0) return;
        if (typeof node == "number") return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object") return JSON.stringify(node);
        var i2, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i2 = 0; i2 < node.length; i2++) {
            if (i2) out += ",";
            out += stringify(node[i2]) || "null";
          }
          return out + "]";
        }
        if (node === null) return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles) return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i2 = 0; i2 < keys.length; i2++) {
          var key = keys[i2];
          var value = stringify(node[key]);
          if (!value) continue;
          if (out) out += ",";
          out += JSON.stringify(key) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      }(data);
    };
  }
});

// node_modules/fastpriorityqueue/FastPriorityQueue.js
var require_FastPriorityQueue = __commonJS({
  "node_modules/fastpriorityqueue/FastPriorityQueue.js"(exports, module) {
    "use strict";
    var defaultcomparator = function(a2, b) {
      return a2 < b;
    };
    function FastPriorityQueue(comparator) {
      if (!(this instanceof FastPriorityQueue)) return new FastPriorityQueue(comparator);
      this.array = [];
      this.size = 0;
      this.compare = comparator || defaultcomparator;
    }
    FastPriorityQueue.prototype.clone = function() {
      var fpq = new FastPriorityQueue(this.compare);
      fpq.size = this.size;
      fpq.array = this.array.slice(0, this.size);
      return fpq;
    };
    FastPriorityQueue.prototype.add = function(myval) {
      var i2 = this.size;
      this.array[this.size] = myval;
      this.size += 1;
      var p;
      var ap;
      while (i2 > 0) {
        p = i2 - 1 >> 1;
        ap = this.array[p];
        if (!this.compare(myval, ap)) {
          break;
        }
        this.array[i2] = ap;
        i2 = p;
      }
      this.array[i2] = myval;
    };
    FastPriorityQueue.prototype.heapify = function(arr) {
      this.array = arr;
      this.size = arr.length;
      var i2;
      for (i2 = this.size >> 1; i2 >= 0; i2--) {
        this._percolateDown(i2);
      }
    };
    FastPriorityQueue.prototype._percolateUp = function(i2, force) {
      var myval = this.array[i2];
      var p;
      var ap;
      while (i2 > 0) {
        p = i2 - 1 >> 1;
        ap = this.array[p];
        if (!force && !this.compare(myval, ap)) {
          break;
        }
        this.array[i2] = ap;
        i2 = p;
      }
      this.array[i2] = myval;
    };
    FastPriorityQueue.prototype._percolateDown = function(i2) {
      var size = this.size;
      var hsize = this.size >>> 1;
      var ai = this.array[i2];
      var l2;
      var r;
      var bestc;
      while (i2 < hsize) {
        l2 = (i2 << 1) + 1;
        r = l2 + 1;
        bestc = this.array[l2];
        if (r < size) {
          if (this.compare(this.array[r], bestc)) {
            l2 = r;
            bestc = this.array[r];
          }
        }
        if (!this.compare(bestc, ai)) {
          break;
        }
        this.array[i2] = bestc;
        i2 = l2;
      }
      this.array[i2] = ai;
    };
    FastPriorityQueue.prototype._removeAt = function(index) {
      if (index > this.size - 1 || index < 0) return void 0;
      this._percolateUp(index, true);
      return this.poll();
    };
    FastPriorityQueue.prototype.remove = function(myval) {
      for (var i2 = 0; i2 < this.size; i2++) {
        if (!this.compare(this.array[i2], myval) && !this.compare(myval, this.array[i2])) {
          this._removeAt(i2);
          return true;
        }
      }
      return false;
    };
    FastPriorityQueue.prototype.removeOne = function(callback) {
      if (typeof callback !== "function") {
        return void 0;
      }
      for (var i2 = 0; i2 < this.size; i2++) {
        if (callback(this.array[i2])) {
          return this._removeAt(i2);
        }
      }
    };
    FastPriorityQueue.prototype.removeMany = function(callback, limit) {
      if (typeof callback !== "function" || this.size < 1) {
        return [];
      }
      limit = limit ? Math.min(limit, this.size) : this.size;
      var resultSize = 0;
      var result = new Array(limit);
      var tmpSize = 0;
      var tmp = new Array(this.size);
      while (resultSize < limit && !this.isEmpty()) {
        var item = this.poll();
        if (callback(item)) {
          result[resultSize++] = item;
        } else {
          tmp[tmpSize++] = item;
        }
      }
      result.length = resultSize;
      var i2 = 0;
      while (i2 < tmpSize) {
        this.add(tmp[i2++]);
      }
      return result;
    };
    FastPriorityQueue.prototype.peek = function() {
      if (this.size == 0) return void 0;
      return this.array[0];
    };
    FastPriorityQueue.prototype.poll = function() {
      if (this.size == 0) return void 0;
      var ans = this.array[0];
      if (this.size > 1) {
        this.array[0] = this.array[--this.size];
        this._percolateDown(0);
      } else {
        this.size -= 1;
      }
      return ans;
    };
    FastPriorityQueue.prototype.replaceTop = function(myval) {
      if (this.size == 0) return void 0;
      var ans = this.array[0];
      this.array[0] = myval;
      this._percolateDown(0);
      return ans;
    };
    FastPriorityQueue.prototype.trim = function() {
      this.array = this.array.slice(0, this.size);
    };
    FastPriorityQueue.prototype.isEmpty = function() {
      return this.size === 0;
    };
    FastPriorityQueue.prototype.forEach = function(callback) {
      if (this.isEmpty() || typeof callback != "function") return;
      var i2 = 0;
      var fpq = this.clone();
      while (!fpq.isEmpty()) {
        callback(fpq.poll(), i2++);
      }
    };
    FastPriorityQueue.prototype.kSmallest = function(k) {
      if (this.size == 0 || k <= 0) return [];
      k = Math.min(this.size, k);
      const newSize = Math.min(this.size, 2 ** (k - 1) + 1);
      if (newSize < 2) {
        return [this.peek()];
      }
      const fpq = new FastPriorityQueue(this.compare);
      fpq.size = newSize;
      fpq.array = this.array.slice(0, newSize);
      const smallest = new Array(k);
      for (let i2 = 0; i2 < k; i2++) {
        smallest[i2] = fpq.poll();
      }
      return smallest;
    };
    module.exports = FastPriorityQueue;
  }
});

// node_modules/@croquet/croquet/cjs/croquet-croquet.js
var require_croquet_croquet = __commonJS({
  "node_modules/@croquet/croquet/cjs/croquet-croquet.js"(exports) {
    "use strict";
    var t2 = require_toastify();
    var e2 = require_fast_json_stable_stringify();
    var s2 = require_FastPriorityQueue();
    var n2 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
    function i2(t3) {
      return t3 && t3.__esModule && Object.prototype.hasOwnProperty.call(t3, "default") ? t3.default : t3;
    }
    function o2(t3) {
      if (Object.prototype.hasOwnProperty.call(t3, "__esModule")) return t3;
      var e3 = t3.default;
      if ("function" == typeof e3) {
        var s3 = function t4() {
          return this instanceof t4 ? Reflect.construct(e3, arguments, this.constructor) : e3.apply(this, arguments);
        };
        s3.prototype = e3.prototype;
      } else s3 = {};
      return Object.defineProperty(s3, "__esModule", { value: true }), Object.keys(t3).forEach(function(e4) {
        var n3 = Object.getOwnPropertyDescriptor(t3, e4);
        Object.defineProperty(s3, e4, n3.get ? n3 : { enumerable: true, get: function() {
          return t3[e4];
        } });
      }), s3;
    }
    var r;
    var a2 = { exports: {} };
    r || (r = 1, function(t3) {
      var e3 = function(t4) {
        var e4, s3 = Object.prototype, n3 = s3.hasOwnProperty, i3 = Object.defineProperty || function(t5, e5, s4) {
          t5[e5] = s4.value;
        }, o3 = "function" == typeof Symbol ? Symbol : {}, r2 = o3.iterator || "@@iterator", a3 = o3.asyncIterator || "@@asyncIterator", l3 = o3.toStringTag || "@@toStringTag";
        function c2(t5, e5, s4) {
          return Object.defineProperty(t5, e5, { value: s4, enumerable: true, configurable: true, writable: true }), t5[e5];
        }
        try {
          c2({}, "");
        } catch (t5) {
          c2 = function(t6, e5, s4) {
            return t6[e5] = s4;
          };
        }
        function d2(t5, e5, s4, n4) {
          var o4 = e5 && e5.prototype instanceof y2 ? e5 : y2, r3 = Object.create(o4.prototype), a4 = new k2(n4 || []);
          return i3(r3, "_invoke", { value: G2(t5, s4, a4) }), r3;
        }
        function h2(t5, e5, s4) {
          try {
            return { type: "normal", arg: t5.call(e5, s4) };
          } catch (t6) {
            return { type: "throw", arg: t6 };
          }
        }
        t4.wrap = d2;
        var u2 = "suspendedStart", m2 = "suspendedYield", p2 = "executing", f2 = "completed", b2 = {};
        function y2() {
        }
        function g2() {
        }
        function w2() {
        }
        var Z2 = {};
        c2(Z2, r2, function() {
          return this;
        });
        var X2 = Object.getPrototypeOf, v2 = X2 && X2(X2(P2([])));
        v2 && v2 !== s3 && n3.call(v2, r2) && (Z2 = v2);
        var L2 = w2.prototype = y2.prototype = Object.create(Z2);
        function x2(t5) {
          ["next", "throw", "return"].forEach(function(e5) {
            c2(t5, e5, function(t6) {
              return this._invoke(e5, t6);
            });
          });
        }
        function S2(t5, e5) {
          function s4(i4, o5, r3, a4) {
            var l4 = h2(t5[i4], t5, o5);
            if ("throw" !== l4.type) {
              var c3 = l4.arg, d3 = c3.value;
              return d3 && "object" == typeof d3 && n3.call(d3, "__await") ? e5.resolve(d3.__await).then(function(t6) {
                s4("next", t6, r3, a4);
              }, function(t6) {
                s4("throw", t6, r3, a4);
              }) : e5.resolve(d3).then(function(t6) {
                c3.value = t6, r3(c3);
              }, function(t6) {
                return s4("throw", t6, r3, a4);
              });
            }
            a4(l4.arg);
          }
          var o4;
          i3(this, "_invoke", { value: function(t6, n4) {
            function i4() {
              return new e5(function(e6, i5) {
                s4(t6, n4, e6, i5);
              });
            }
            return o4 = o4 ? o4.then(i4, i4) : i4();
          } });
        }
        function G2(t5, s4, n4) {
          var i4 = u2;
          return function(o4, r3) {
            if (i4 === p2) throw new Error("Generator is already running");
            if (i4 === f2) {
              if ("throw" === o4) throw r3;
              return { value: e4, done: true };
            }
            for (n4.method = o4, n4.arg = r3; ; ) {
              var a4 = n4.delegate;
              if (a4) {
                var l4 = T2(a4, n4);
                if (l4) {
                  if (l4 === b2) continue;
                  return l4;
                }
              }
              if ("next" === n4.method) n4.sent = n4._sent = n4.arg;
              else if ("throw" === n4.method) {
                if (i4 === u2) throw i4 = f2, n4.arg;
                n4.dispatchException(n4.arg);
              } else "return" === n4.method && n4.abrupt("return", n4.arg);
              i4 = p2;
              var c3 = h2(t5, s4, n4);
              if ("normal" === c3.type) {
                if (i4 = n4.done ? f2 : m2, c3.arg === b2) continue;
                return { value: c3.arg, done: n4.done };
              }
              "throw" === c3.type && (i4 = f2, n4.method = "throw", n4.arg = c3.arg);
            }
          };
        }
        function T2(t5, s4) {
          var n4 = s4.method, i4 = t5.iterator[n4];
          if (i4 === e4) return s4.delegate = null, "throw" === n4 && t5.iterator.return && (s4.method = "return", s4.arg = e4, T2(t5, s4), "throw" === s4.method) || "return" !== n4 && (s4.method = "throw", s4.arg = new TypeError("The iterator does not provide a '" + n4 + "' method")), b2;
          var o4 = h2(i4, t5.iterator, s4.arg);
          if ("throw" === o4.type) return s4.method = "throw", s4.arg = o4.arg, s4.delegate = null, b2;
          var r3 = o4.arg;
          return r3 ? r3.done ? (s4[t5.resultName] = r3.value, s4.next = t5.nextLoc, "return" !== s4.method && (s4.method = "next", s4.arg = e4), s4.delegate = null, b2) : r3 : (s4.method = "throw", s4.arg = new TypeError("iterator result is not an object"), s4.delegate = null, b2);
        }
        function W2(t5) {
          var e5 = { tryLoc: t5[0] };
          1 in t5 && (e5.catchLoc = t5[1]), 2 in t5 && (e5.finallyLoc = t5[2], e5.afterLoc = t5[3]), this.tryEntries.push(e5);
        }
        function C2(t5) {
          var e5 = t5.completion || {};
          e5.type = "normal", delete e5.arg, t5.completion = e5;
        }
        function k2(t5) {
          this.tryEntries = [{ tryLoc: "root" }], t5.forEach(W2, this), this.reset(true);
        }
        function P2(t5) {
          if (null != t5) {
            var s4 = t5[r2];
            if (s4) return s4.call(t5);
            if ("function" == typeof t5.next) return t5;
            if (!isNaN(t5.length)) {
              var i4 = -1, o4 = function s5() {
                for (; ++i4 < t5.length; ) if (n3.call(t5, i4)) return s5.value = t5[i4], s5.done = false, s5;
                return s5.value = e4, s5.done = true, s5;
              };
              return o4.next = o4;
            }
          }
          throw new TypeError(typeof t5 + " is not iterable");
        }
        return g2.prototype = w2, i3(L2, "constructor", { value: w2, configurable: true }), i3(w2, "constructor", { value: g2, configurable: true }), g2.displayName = c2(w2, l3, "GeneratorFunction"), t4.isGeneratorFunction = function(t5) {
          var e5 = "function" == typeof t5 && t5.constructor;
          return !!e5 && (e5 === g2 || "GeneratorFunction" === (e5.displayName || e5.name));
        }, t4.mark = function(t5) {
          return Object.setPrototypeOf ? Object.setPrototypeOf(t5, w2) : (t5.__proto__ = w2, c2(t5, l3, "GeneratorFunction")), t5.prototype = Object.create(L2), t5;
        }, t4.awrap = function(t5) {
          return { __await: t5 };
        }, x2(S2.prototype), c2(S2.prototype, a3, function() {
          return this;
        }), t4.AsyncIterator = S2, t4.async = function(e5, s4, n4, i4, o4) {
          void 0 === o4 && (o4 = Promise);
          var r3 = new S2(d2(e5, s4, n4, i4), o4);
          return t4.isGeneratorFunction(s4) ? r3 : r3.next().then(function(t5) {
            return t5.done ? t5.value : r3.next();
          });
        }, x2(L2), c2(L2, l3, "Generator"), c2(L2, r2, function() {
          return this;
        }), c2(L2, "toString", function() {
          return "[object Generator]";
        }), t4.keys = function(t5) {
          var e5 = Object(t5), s4 = [];
          for (var n4 in e5) s4.push(n4);
          return s4.reverse(), function t6() {
            for (; s4.length; ) {
              var n5 = s4.pop();
              if (n5 in e5) return t6.value = n5, t6.done = false, t6;
            }
            return t6.done = true, t6;
          };
        }, t4.values = P2, k2.prototype = { constructor: k2, reset: function(t5) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = e4, this.done = false, this.delegate = null, this.method = "next", this.arg = e4, this.tryEntries.forEach(C2), !t5) for (var s4 in this) "t" === s4.charAt(0) && n3.call(this, s4) && !isNaN(+s4.slice(1)) && (this[s4] = e4);
        }, stop: function() {
          this.done = true;
          var t5 = this.tryEntries[0].completion;
          if ("throw" === t5.type) throw t5.arg;
          return this.rval;
        }, dispatchException: function(t5) {
          if (this.done) throw t5;
          var s4 = this;
          function i4(n4, i5) {
            return a4.type = "throw", a4.arg = t5, s4.next = n4, i5 && (s4.method = "next", s4.arg = e4), !!i5;
          }
          for (var o4 = this.tryEntries.length - 1; o4 >= 0; --o4) {
            var r3 = this.tryEntries[o4], a4 = r3.completion;
            if ("root" === r3.tryLoc) return i4("end");
            if (r3.tryLoc <= this.prev) {
              var l4 = n3.call(r3, "catchLoc"), c3 = n3.call(r3, "finallyLoc");
              if (l4 && c3) {
                if (this.prev < r3.catchLoc) return i4(r3.catchLoc, true);
                if (this.prev < r3.finallyLoc) return i4(r3.finallyLoc);
              } else if (l4) {
                if (this.prev < r3.catchLoc) return i4(r3.catchLoc, true);
              } else {
                if (!c3) throw new Error("try statement without catch or finally");
                if (this.prev < r3.finallyLoc) return i4(r3.finallyLoc);
              }
            }
          }
        }, abrupt: function(t5, e5) {
          for (var s4 = this.tryEntries.length - 1; s4 >= 0; --s4) {
            var i4 = this.tryEntries[s4];
            if (i4.tryLoc <= this.prev && n3.call(i4, "finallyLoc") && this.prev < i4.finallyLoc) {
              var o4 = i4;
              break;
            }
          }
          o4 && ("break" === t5 || "continue" === t5) && o4.tryLoc <= e5 && e5 <= o4.finallyLoc && (o4 = null);
          var r3 = o4 ? o4.completion : {};
          return r3.type = t5, r3.arg = e5, o4 ? (this.method = "next", this.next = o4.finallyLoc, b2) : this.complete(r3);
        }, complete: function(t5, e5) {
          if ("throw" === t5.type) throw t5.arg;
          return "break" === t5.type || "continue" === t5.type ? this.next = t5.arg : "return" === t5.type ? (this.rval = this.arg = t5.arg, this.method = "return", this.next = "end") : "normal" === t5.type && e5 && (this.next = e5), b2;
        }, finish: function(t5) {
          for (var e5 = this.tryEntries.length - 1; e5 >= 0; --e5) {
            var s4 = this.tryEntries[e5];
            if (s4.finallyLoc === t5) return this.complete(s4.completion, s4.afterLoc), C2(s4), b2;
          }
        }, catch: function(t5) {
          for (var e5 = this.tryEntries.length - 1; e5 >= 0; --e5) {
            var s4 = this.tryEntries[e5];
            if (s4.tryLoc === t5) {
              var n4 = s4.completion;
              if ("throw" === n4.type) {
                var i4 = n4.arg;
                C2(s4);
              }
              return i4;
            }
          }
          throw new Error("illegal catch attempt");
        }, delegateYield: function(t5, s4, n4) {
          return this.delegate = { iterator: P2(t5), resultName: s4, nextLoc: n4 }, "next" === this.method && (this.arg = e4), b2;
        } }, t4;
      }(t3.exports);
      try {
        globalThis.regeneratorRuntime = e3;
      } catch (t4) {
        "object" == typeof globalThis ? globalThis.regeneratorRuntime = e3 : Function("r", "regeneratorRuntime = r")(e3);
      }
    }(a2));
    var l2 = { CROQUET_VERSION: "2.0.4" };
    var c = window && window.location.hostname.endsWith("croquet.studio");
    var d = "";
    var h = "";
    function u(t3, e3) {
      if (e3) for (const s3 of e3.split("&")) {
        const e4 = s3.split("="), n3 = e4[0];
        let i3 = true;
        if (e4.length > 1 && (i3 = decodeURIComponent(e4.slice(1).join("=")), i3.match(/^(true|false|null|[0-9.]*|["[{].*)$/))) try {
          i3 = JSON.parse(i3);
        } catch (t4) {
          "[" === i3[0] && (i3 = i3.slice(1, -1).split(","));
        }
        t3[n3] = i3;
      }
    }
    var m = new class {
      constructor() {
        this.getSession(), u(this, window.location.search.slice(1)), u(this, c ? window.location.hash.slice(1) : h), window.location.pathname.indexOf("/ar.html") >= 0 && (this.ar = true);
      }
      has(t3, e3) {
        let s3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        "string" == typeof s3 && (s3 = this.isHost(s3));
        const n3 = this[t3];
        if ("string" != typeof n3) return s3;
        const i3 = n3.split(",");
        return true === s3 && (e3 = `no${e3}`), e3.endsWith("s") && (e3 = e3.slice(0, -1)), i3.includes(e3) || i3.includes(`${e3}s`) ? !s3 : s3;
      }
      getSession() {
        if (c) {
          const t3 = /^\/([^/]+)\/(.*)$/, e3 = window.location.pathname.match(t3);
          if (e3) return d = e3[1], e3[2];
        } else {
          const t3 = /^#([^&]+)&?(.*)$/, e3 = window.location.hash.match(t3);
          if (e3) return e3[1].includes("=") ? (h = `${e3[1]}&${e3[2]}`, "") : (h = e3[2], e3[1]);
        }
        return "string" == typeof this.session ? (h = window.location.hash.slice(1), this.session) : "";
      }
      setSession(t3) {
        let e3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        null == c && this.getSession();
        const { search: s3, hash: n3 } = window.location, i3 = c ? `/${d}/${t3}${s3}${n3}` : `#${t3}${h ? "&" + h : ""}`;
        e3 ? window.history.replaceState({}, "", i3) : window.history.pushState({}, "", i3);
      }
      isHost(t3) {
        const e3 = window.location.hostname;
        if (e3 === t3) return true;
        if ("localhost" !== t3) return false;
        if (e3.endsWith(".ngrok.io")) return true;
        if ("croquet.io" === e3) {
          if (window.location.pathname.match(/^\/(dev|files)\//)) return true;
        }
        return "file:" === window.location.protocol || ["127.0.0.1", "[::1]"].includes(e3);
      }
      isLocalhost() {
        return this.isHost("localhost");
      }
    }();
    var p;
    var f = 256;
    var b = Math.pow(f, 6);
    var y = Math.pow(2, 52);
    var g = 2 * y;
    var w = 255;
    function Z(t3, e3) {
      var s3 = [];
      if ((e3 = e3 || {}).entropy) throw new Error("this version of seedrandom does not support entropy");
      if (null == t3 && !e3.state) throw new Error("this version of seedrandom requires a seed");
      !function(t4, e4) {
        var s4, n4 = t4 + "", i4 = 0;
        for (; i4 < n4.length; ) e4[w & i4] = w & (s4 ^= 19 * e4[w & i4]) + n4.charCodeAt(i4++);
        return o3 = e4, String.fromCharCode.apply(0, o3);
        var o3;
      }(L(t3, 3), s3);
      var n3 = new X(s3), i3 = function() {
        for (var t4 = n3.g(6), e4 = b, s4 = 0; t4 < y; ) t4 = (t4 + s4) * f, e4 *= f, s4 = n3.g(1);
        for (; t4 >= g; ) t4 /= 2, e4 /= 2, s4 >>>= 1;
        return (t4 + s4) / e4;
      };
      return i3.int32 = function() {
        return 0 | n3.g(4);
      }, i3.quick = function() {
        return n3.g(4) / 4294967296;
      }, i3.double = i3, (e3.pass || function(t4, e4) {
        return e4 && (e4.S && v(e4, n3), t4.state = function() {
          return v(n3, {});
        }), t4;
      })(i3, e3.state);
    }
    function X(t3) {
      var e3, s3 = t3.length, n3 = this, i3 = 0, o3 = n3.i = n3.j = 0, r2 = n3.S = [];
      for (s3 || (t3 = [s3++]); i3 < f; ) r2[i3] = i3++;
      for (i3 = 0; i3 < f; i3++) r2[i3] = r2[o3 = w & o3 + t3[i3 % s3] + (e3 = r2[i3])], r2[o3] = e3;
      (n3.g = function(t4) {
        for (var e4, s4 = 0, i4 = n3.i, o4 = n3.j, r3 = n3.S; t4--; ) e4 = r3[i4 = w & i4 + 1], s4 = s4 * f + r3[w & (r3[i4] = r3[o4 = w & o4 + e4]) + (r3[o4] = e4)];
        return n3.i = i4, n3.j = o4, s4;
      })(f);
    }
    function v(t3, e3) {
      return e3.i = t3.i, e3.j = t3.j, e3.S = t3.S.slice(), e3;
    }
    function L(t3, e3) {
      var s3, n3 = [], i3 = typeof t3;
      if (e3 && "object" == i3) for (s3 in t3) try {
        n3.push(L(t3[s3], e3 - 1));
      } catch (t4) {
      }
      return n3.length ? n3 : "string" == i3 ? t3 : t3 + "\0";
    }
    !function() {
      function t3(t4) {
        this.mode = s3.MODE_8BIT_BYTE, this.data = t4, this.parsedData = [];
        for (var e4 = 0, n4 = this.data.length; e4 < n4; e4++) {
          var i4 = [], o4 = this.data.charCodeAt(e4);
          o4 > 65536 ? (i4[0] = 240 | (1835008 & o4) >>> 18, i4[1] = 128 | (258048 & o4) >>> 12, i4[2] = 128 | (4032 & o4) >>> 6, i4[3] = 128 | 63 & o4) : o4 > 2048 ? (i4[0] = 224 | (61440 & o4) >>> 12, i4[1] = 128 | (4032 & o4) >>> 6, i4[2] = 128 | 63 & o4) : o4 > 128 ? (i4[0] = 192 | (1984 & o4) >>> 6, i4[1] = 128 | 63 & o4) : i4[0] = o4, this.parsedData.push(i4);
        }
        this.parsedData = Array.prototype.concat.apply([], this.parsedData), this.parsedData.length != this.data.length && (this.parsedData.unshift(191), this.parsedData.unshift(187), this.parsedData.unshift(239));
      }
      function e3(t4, e4) {
        this.typeNumber = t4, this.errorCorrectLevel = e4, this.modules = null, this.moduleCount = 0, this.dataCache = null, this.dataList = [];
      }
      t3.prototype = { getLength: function(t4) {
        return this.parsedData.length;
      }, write: function(t4) {
        for (var e4 = 0, s4 = this.parsedData.length; e4 < s4; e4++) t4.put(this.parsedData[e4], 8);
      } }, e3.prototype = { addData: function(e4) {
        var s4 = new t3(e4);
        this.dataList.push(s4), this.dataCache = null;
      }, isDark: function(t4, e4) {
        if (t4 < 0 || this.moduleCount <= t4 || e4 < 0 || this.moduleCount <= e4) throw new Error(t4 + "," + e4);
        return this.modules[t4][e4];
      }, getModuleCount: function() {
        return this.moduleCount;
      }, make: function() {
        this.makeImpl(false, this.getBestMaskPattern());
      }, makeImpl: function(t4, s4) {
        this.moduleCount = 4 * this.typeNumber + 17, this.modules = new Array(this.moduleCount);
        for (var n4 = 0; n4 < this.moduleCount; n4++) {
          this.modules[n4] = new Array(this.moduleCount);
          for (var i4 = 0; i4 < this.moduleCount; i4++) this.modules[n4][i4] = null;
        }
        this.setupPositionProbePattern(0, 0), this.setupPositionProbePattern(this.moduleCount - 7, 0), this.setupPositionProbePattern(0, this.moduleCount - 7), this.setupPositionAdjustPattern(), this.setupTimingPattern(), this.setupTypeInfo(t4, s4), this.typeNumber >= 7 && this.setupTypeNumber(t4), null == this.dataCache && (this.dataCache = e3.createData(this.typeNumber, this.errorCorrectLevel, this.dataList)), this.mapData(this.dataCache, s4);
      }, setupPositionProbePattern: function(t4, e4) {
        for (var s4 = -1; s4 <= 7; s4++) if (!(t4 + s4 <= -1 || this.moduleCount <= t4 + s4)) for (var n4 = -1; n4 <= 7; n4++) e4 + n4 <= -1 || this.moduleCount <= e4 + n4 || (this.modules[t4 + s4][e4 + n4] = 0 <= s4 && s4 <= 6 && (0 == n4 || 6 == n4) || 0 <= n4 && n4 <= 6 && (0 == s4 || 6 == s4) || 2 <= s4 && s4 <= 4 && 2 <= n4 && n4 <= 4);
      }, getBestMaskPattern: function() {
        for (var t4 = 0, e4 = 0, s4 = 0; s4 < 8; s4++) {
          this.makeImpl(true, s4);
          var n4 = u2.getLostPoint(this);
          (0 == s4 || t4 > n4) && (t4 = n4, e4 = s4);
        }
        return e4;
      }, createMovieClip: function(t4, e4, s4) {
        var n4 = t4.createEmptyMovieClip(e4, s4);
        this.make();
        for (var i4 = 0; i4 < this.modules.length; i4++) for (var o4 = 1 * i4, r3 = 0; r3 < this.modules[i4].length; r3++) {
          var a4 = 1 * r3;
          this.modules[i4][r3] && (n4.beginFill(0, 100), n4.moveTo(a4, o4), n4.lineTo(a4 + 1, o4), n4.lineTo(a4 + 1, o4 + 1), n4.lineTo(a4, o4 + 1), n4.endFill());
        }
        return n4;
      }, setupTimingPattern: function() {
        for (var t4 = 8; t4 < this.moduleCount - 8; t4++) null == this.modules[t4][6] && (this.modules[t4][6] = t4 % 2 == 0);
        for (var e4 = 8; e4 < this.moduleCount - 8; e4++) null == this.modules[6][e4] && (this.modules[6][e4] = e4 % 2 == 0);
      }, setupPositionAdjustPattern: function() {
        for (var t4 = u2.getPatternPosition(this.typeNumber), e4 = 0; e4 < t4.length; e4++) for (var s4 = 0; s4 < t4.length; s4++) {
          var n4 = t4[e4], i4 = t4[s4];
          if (null == this.modules[n4][i4]) for (var o4 = -2; o4 <= 2; o4++) for (var r3 = -2; r3 <= 2; r3++) this.modules[n4 + o4][i4 + r3] = -2 == o4 || 2 == o4 || -2 == r3 || 2 == r3 || 0 == o4 && 0 == r3;
        }
      }, setupTypeNumber: function(t4) {
        for (var e4 = u2.getBCHTypeNumber(this.typeNumber), s4 = 0; s4 < 18; s4++) {
          var n4 = !t4 && 1 == (e4 >> s4 & 1);
          this.modules[Math.floor(s4 / 3)][s4 % 3 + this.moduleCount - 8 - 3] = n4;
        }
        for (s4 = 0; s4 < 18; s4++) {
          n4 = !t4 && 1 == (e4 >> s4 & 1);
          this.modules[s4 % 3 + this.moduleCount - 8 - 3][Math.floor(s4 / 3)] = n4;
        }
      }, setupTypeInfo: function(t4, e4) {
        for (var s4 = this.errorCorrectLevel << 3 | e4, n4 = u2.getBCHTypeInfo(s4), i4 = 0; i4 < 15; i4++) {
          var o4 = !t4 && 1 == (n4 >> i4 & 1);
          i4 < 6 ? this.modules[i4][8] = o4 : i4 < 8 ? this.modules[i4 + 1][8] = o4 : this.modules[this.moduleCount - 15 + i4][8] = o4;
        }
        for (i4 = 0; i4 < 15; i4++) {
          o4 = !t4 && 1 == (n4 >> i4 & 1);
          i4 < 8 ? this.modules[8][this.moduleCount - i4 - 1] = o4 : i4 < 9 ? this.modules[8][15 - i4 - 1 + 1] = o4 : this.modules[8][15 - i4 - 1] = o4;
        }
        this.modules[this.moduleCount - 8][8] = !t4;
      }, mapData: function(t4, e4) {
        for (var s4 = -1, n4 = this.moduleCount - 1, i4 = 7, o4 = 0, r3 = this.moduleCount - 1; r3 > 0; r3 -= 2) for (6 == r3 && r3--; ; ) {
          for (var a4 = 0; a4 < 2; a4++) if (null == this.modules[n4][r3 - a4]) {
            var l4 = false;
            o4 < t4.length && (l4 = 1 == (t4[o4] >>> i4 & 1)), u2.getMask(e4, n4, r3 - a4) && (l4 = !l4), this.modules[n4][r3 - a4] = l4, -1 == --i4 && (o4++, i4 = 7);
          }
          if ((n4 += s4) < 0 || this.moduleCount <= n4) {
            n4 -= s4, s4 = -s4;
            break;
          }
        }
      } }, e3.PAD0 = 236, e3.PAD1 = 17, e3.createData = function(t4, s4, n4) {
        for (var i4 = y2.getRSBlocks(t4, s4), o4 = new g2(), r3 = 0; r3 < n4.length; r3++) {
          var a4 = n4[r3];
          o4.put(a4.mode, 4), o4.put(a4.getLength(), u2.getLengthInBits(a4.mode, t4)), a4.write(o4);
        }
        var l4 = 0;
        for (r3 = 0; r3 < i4.length; r3++) l4 += i4[r3].dataCount;
        if (o4.getLengthInBits() > 8 * l4) throw new Error("code length overflow. (" + o4.getLengthInBits() + ">" + 8 * l4 + ")");
        for (o4.getLengthInBits() + 4 <= 8 * l4 && o4.put(0, 4); o4.getLengthInBits() % 8 != 0; ) o4.putBit(false);
        for (; !(o4.getLengthInBits() >= 8 * l4 || (o4.put(e3.PAD0, 8), o4.getLengthInBits() >= 8 * l4)); ) o4.put(e3.PAD1, 8);
        return e3.createBytes(o4, i4);
      }, e3.createBytes = function(t4, e4) {
        for (var s4 = 0, n4 = 0, i4 = 0, o4 = new Array(e4.length), r3 = new Array(e4.length), a4 = 0; a4 < e4.length; a4++) {
          var l4 = e4[a4].dataCount, c3 = e4[a4].totalCount - l4;
          n4 = Math.max(n4, l4), i4 = Math.max(i4, c3), o4[a4] = new Array(l4);
          for (var d3 = 0; d3 < o4[a4].length; d3++) o4[a4][d3] = 255 & t4.buffer[d3 + s4];
          s4 += l4;
          var h3 = u2.getErrorCorrectPolynomial(c3), m3 = new b2(o4[a4], h3.getLength() - 1).mod(h3);
          r3[a4] = new Array(h3.getLength() - 1);
          for (d3 = 0; d3 < r3[a4].length; d3++) {
            var p2 = d3 + m3.getLength() - r3[a4].length;
            r3[a4][d3] = p2 >= 0 ? m3.get(p2) : 0;
          }
        }
        var f3 = 0;
        for (d3 = 0; d3 < e4.length; d3++) f3 += e4[d3].totalCount;
        var y3 = new Array(f3), g3 = 0;
        for (d3 = 0; d3 < n4; d3++) for (a4 = 0; a4 < e4.length; a4++) d3 < o4[a4].length && (y3[g3++] = o4[a4][d3]);
        for (d3 = 0; d3 < i4; d3++) for (a4 = 0; a4 < e4.length; a4++) d3 < r3[a4].length && (y3[g3++] = r3[a4][d3]);
        return y3;
      };
      for (var s3 = { MODE_NUMBER: 1, MODE_ALPHA_NUM: 2, MODE_8BIT_BYTE: 4, MODE_KANJI: 8 }, n3 = { L: 1, M: 0, Q: 3, H: 2 }, i3 = 0, o3 = 1, r2 = 2, a3 = 3, l3 = 4, c2 = 5, d2 = 6, h2 = 7, u2 = { PATTERN_POSITION_TABLE: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], G15: 1335, G18: 7973, G15_MASK: 21522, getBCHTypeInfo: function(t4) {
        for (var e4 = t4 << 10; u2.getBCHDigit(e4) - u2.getBCHDigit(u2.G15) >= 0; ) e4 ^= u2.G15 << u2.getBCHDigit(e4) - u2.getBCHDigit(u2.G15);
        return (t4 << 10 | e4) ^ u2.G15_MASK;
      }, getBCHTypeNumber: function(t4) {
        for (var e4 = t4 << 12; u2.getBCHDigit(e4) - u2.getBCHDigit(u2.G18) >= 0; ) e4 ^= u2.G18 << u2.getBCHDigit(e4) - u2.getBCHDigit(u2.G18);
        return t4 << 12 | e4;
      }, getBCHDigit: function(t4) {
        for (var e4 = 0; 0 != t4; ) e4++, t4 >>>= 1;
        return e4;
      }, getPatternPosition: function(t4) {
        return u2.PATTERN_POSITION_TABLE[t4 - 1];
      }, getMask: function(t4, e4, s4) {
        switch (t4) {
          case i3:
            return (e4 + s4) % 2 == 0;
          case o3:
            return e4 % 2 == 0;
          case r2:
            return s4 % 3 == 0;
          case a3:
            return (e4 + s4) % 3 == 0;
          case l3:
            return (Math.floor(e4 / 2) + Math.floor(s4 / 3)) % 2 == 0;
          case c2:
            return e4 * s4 % 2 + e4 * s4 % 3 == 0;
          case d2:
            return (e4 * s4 % 2 + e4 * s4 % 3) % 2 == 0;
          case h2:
            return (e4 * s4 % 3 + (e4 + s4) % 2) % 2 == 0;
          default:
            throw new Error("bad maskPattern:" + t4);
        }
      }, getErrorCorrectPolynomial: function(t4) {
        for (var e4 = new b2([1], 0), s4 = 0; s4 < t4; s4++) e4 = e4.multiply(new b2([1, m2.gexp(s4)], 0));
        return e4;
      }, getLengthInBits: function(t4, e4) {
        if (1 <= e4 && e4 < 10) switch (t4) {
          case s3.MODE_NUMBER:
            return 10;
          case s3.MODE_ALPHA_NUM:
            return 9;
          case s3.MODE_8BIT_BYTE:
          case s3.MODE_KANJI:
            return 8;
          default:
            throw new Error("mode:" + t4);
        }
        else if (e4 < 27) switch (t4) {
          case s3.MODE_NUMBER:
            return 12;
          case s3.MODE_ALPHA_NUM:
            return 11;
          case s3.MODE_8BIT_BYTE:
            return 16;
          case s3.MODE_KANJI:
            return 10;
          default:
            throw new Error("mode:" + t4);
        }
        else {
          if (!(e4 < 41)) throw new Error("type:" + e4);
          switch (t4) {
            case s3.MODE_NUMBER:
              return 14;
            case s3.MODE_ALPHA_NUM:
              return 13;
            case s3.MODE_8BIT_BYTE:
              return 16;
            case s3.MODE_KANJI:
              return 12;
            default:
              throw new Error("mode:" + t4);
          }
        }
      }, getLostPoint: function(t4) {
        for (var e4 = t4.getModuleCount(), s4 = 0, n4 = 0; n4 < e4; n4++) for (var i4 = 0; i4 < e4; i4++) {
          for (var o4 = 0, r3 = t4.isDark(n4, i4), a4 = -1; a4 <= 1; a4++) if (!(n4 + a4 < 0 || e4 <= n4 + a4)) for (var l4 = -1; l4 <= 1; l4++) i4 + l4 < 0 || e4 <= i4 + l4 || 0 == a4 && 0 == l4 || r3 == t4.isDark(n4 + a4, i4 + l4) && o4++;
          o4 > 5 && (s4 += 3 + o4 - 5);
        }
        for (n4 = 0; n4 < e4 - 1; n4++) for (i4 = 0; i4 < e4 - 1; i4++) {
          var c3 = 0;
          t4.isDark(n4, i4) && c3++, t4.isDark(n4 + 1, i4) && c3++, t4.isDark(n4, i4 + 1) && c3++, t4.isDark(n4 + 1, i4 + 1) && c3++, 0 != c3 && 4 != c3 || (s4 += 3);
        }
        for (n4 = 0; n4 < e4; n4++) for (i4 = 0; i4 < e4 - 6; i4++) t4.isDark(n4, i4) && !t4.isDark(n4, i4 + 1) && t4.isDark(n4, i4 + 2) && t4.isDark(n4, i4 + 3) && t4.isDark(n4, i4 + 4) && !t4.isDark(n4, i4 + 5) && t4.isDark(n4, i4 + 6) && (s4 += 40);
        for (i4 = 0; i4 < e4; i4++) for (n4 = 0; n4 < e4 - 6; n4++) t4.isDark(n4, i4) && !t4.isDark(n4 + 1, i4) && t4.isDark(n4 + 2, i4) && t4.isDark(n4 + 3, i4) && t4.isDark(n4 + 4, i4) && !t4.isDark(n4 + 5, i4) && t4.isDark(n4 + 6, i4) && (s4 += 40);
        var d3 = 0;
        for (i4 = 0; i4 < e4; i4++) for (n4 = 0; n4 < e4; n4++) t4.isDark(n4, i4) && d3++;
        return s4 += 10 * (Math.abs(100 * d3 / e4 / e4 - 50) / 5);
      } }, m2 = { glog: function(t4) {
        if (t4 < 1) throw new Error("glog(" + t4 + ")");
        return m2.LOG_TABLE[t4];
      }, gexp: function(t4) {
        for (; t4 < 0; ) t4 += 255;
        for (; t4 >= 256; ) t4 -= 255;
        return m2.EXP_TABLE[t4];
      }, EXP_TABLE: new Array(256), LOG_TABLE: new Array(256) }, f2 = 0; f2 < 8; f2++) m2.EXP_TABLE[f2] = 1 << f2;
      for (f2 = 8; f2 < 256; f2++) m2.EXP_TABLE[f2] = m2.EXP_TABLE[f2 - 4] ^ m2.EXP_TABLE[f2 - 5] ^ m2.EXP_TABLE[f2 - 6] ^ m2.EXP_TABLE[f2 - 8];
      for (f2 = 0; f2 < 255; f2++) m2.LOG_TABLE[m2.EXP_TABLE[f2]] = f2;
      function b2(t4, e4) {
        if (null == t4.length) throw new Error(t4.length + "/" + e4);
        for (var s4 = 0; s4 < t4.length && 0 == t4[s4]; ) s4++;
        this.num = new Array(t4.length - s4 + e4);
        for (var n4 = 0; n4 < t4.length - s4; n4++) this.num[n4] = t4[n4 + s4];
      }
      function y2(t4, e4) {
        this.totalCount = t4, this.dataCount = e4;
      }
      function g2() {
        this.buffer = [], this.length = 0;
      }
      b2.prototype = { get: function(t4) {
        return this.num[t4];
      }, getLength: function() {
        return this.num.length;
      }, multiply: function(t4) {
        for (var e4 = new Array(this.getLength() + t4.getLength() - 1), s4 = 0; s4 < this.getLength(); s4++) for (var n4 = 0; n4 < t4.getLength(); n4++) e4[s4 + n4] ^= m2.gexp(m2.glog(this.get(s4)) + m2.glog(t4.get(n4)));
        return new b2(e4, 0);
      }, mod: function(t4) {
        if (this.getLength() - t4.getLength() < 0) return this;
        for (var e4 = m2.glog(this.get(0)) - m2.glog(t4.get(0)), s4 = new Array(this.getLength()), n4 = 0; n4 < this.getLength(); n4++) s4[n4] = this.get(n4);
        for (n4 = 0; n4 < t4.getLength(); n4++) s4[n4] ^= m2.gexp(m2.glog(t4.get(n4)) + e4);
        return new b2(s4, 0).mod(t4);
      } }, y2.RS_BLOCK_TABLE = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]], y2.getRSBlocks = function(t4, e4) {
        var s4 = y2.getRsBlockTable(t4, e4);
        if (null == s4) throw new Error("bad rs block @ typeNumber:" + t4 + "/errorCorrectLevel:" + e4);
        for (var n4 = s4.length / 3, i4 = [], o4 = 0; o4 < n4; o4++) for (var r3 = s4[3 * o4 + 0], a4 = s4[3 * o4 + 1], l4 = s4[3 * o4 + 2], c3 = 0; c3 < r3; c3++) i4.push(new y2(a4, l4));
        return i4;
      }, y2.getRsBlockTable = function(t4, e4) {
        switch (e4) {
          case n3.L:
            return y2.RS_BLOCK_TABLE[4 * (t4 - 1) + 0];
          case n3.M:
            return y2.RS_BLOCK_TABLE[4 * (t4 - 1) + 1];
          case n3.Q:
            return y2.RS_BLOCK_TABLE[4 * (t4 - 1) + 2];
          case n3.H:
            return y2.RS_BLOCK_TABLE[4 * (t4 - 1) + 3];
          default:
            return;
        }
      }, g2.prototype = { get: function(t4) {
        var e4 = Math.floor(t4 / 8);
        return 1 == (this.buffer[e4] >>> 7 - t4 % 8 & 1);
      }, put: function(t4, e4) {
        for (var s4 = 0; s4 < e4; s4++) this.putBit(1 == (t4 >>> e4 - s4 - 1 & 1));
      }, getLengthInBits: function() {
        return this.length;
      }, putBit: function(t4) {
        var e4 = Math.floor(this.length / 8);
        this.buffer.length <= e4 && this.buffer.push(0), t4 && (this.buffer[e4] |= 128 >>> this.length % 8), this.length++;
      } };
      var w2 = [[17, 14, 11, 7], [32, 26, 20, 14], [53, 42, 32, 24], [78, 62, 46, 34], [106, 84, 60, 44], [134, 106, 74, 58], [154, 122, 86, 64], [192, 152, 108, 84], [230, 180, 130, 98], [271, 213, 151, 119], [321, 251, 177, 137], [367, 287, 203, 155], [425, 331, 241, 177], [458, 362, 258, 194], [520, 412, 292, 220], [586, 450, 322, 250], [644, 504, 364, 280], [718, 560, 394, 310], [792, 624, 442, 338], [858, 666, 482, 382], [929, 711, 509, 403], [1003, 779, 565, 439], [1091, 857, 611, 461], [1171, 911, 661, 511], [1273, 997, 715, 535], [1367, 1059, 751, 593], [1465, 1125, 805, 625], [1528, 1190, 868, 658], [1628, 1264, 908, 698], [1732, 1370, 982, 742], [1840, 1452, 1030, 790], [1952, 1538, 1112, 842], [2068, 1628, 1168, 898], [2188, 1722, 1228, 958], [2303, 1809, 1283, 983], [2431, 1911, 1351, 1051], [2563, 1989, 1423, 1093], [2699, 2099, 1499, 1139], [2809, 2213, 1579, 1219], [2953, 2331, 1663, 1273]], Z2 = function() {
        var t4 = function(t5, e4) {
          this._bIsPainted = false, this._htOption = e4, this._elCanvas = document.createElement("canvas"), this._elCanvas.width = e4.width, this._elCanvas.height = e4.height, t5.appendChild(this._elCanvas), this._el = t5, this._oContext = this._elCanvas.getContext("2d"), this._bIsPainted = false, this._bSupportDataURI = null;
        };
        return t4.prototype.draw = function(t5) {
          var e4 = this._oContext, s4 = this._htOption, n4 = t5.getModuleCount(), i4 = s4.width / n4, o4 = s4.height / n4, r3 = Math.round(i4), a4 = Math.round(o4);
          this.clear();
          for (var l4 = 0; l4 < n4; l4++) for (var c3 = 0; c3 < n4; c3++) {
            var d3 = t5.isDark(l4, c3), h3 = c3 * i4, u3 = l4 * o4;
            e4.strokeStyle = d3 ? s4.colorDark : s4.colorLight, e4.lineWidth = 1, e4.fillStyle = d3 ? s4.colorDark : s4.colorLight, e4.fillRect(h3, u3, i4, o4), e4.strokeRect(Math.floor(h3) + 0.5, Math.floor(u3) + 0.5, r3, a4), e4.strokeRect(Math.ceil(h3) - 0.5, Math.ceil(u3) - 0.5, r3, a4);
          }
          this._bIsPainted = true;
        }, t4.prototype.isPainted = function() {
          return this._bIsPainted;
        }, t4.prototype.clear = function() {
          this._oContext.clearRect(0, 0, this._elCanvas.width, this._elCanvas.height), this._bIsPainted = false;
        }, t4.prototype.round = function(t5) {
          return t5 ? Math.floor(1e3 * t5) / 1e3 : t5;
        }, t4;
      }();
      function X2(t4, e4) {
        for (var s4 = 1, i4 = function(t5) {
          var e5 = encodeURI(t5).toString().replace(/\%[0-9a-fA-F]{2}/g, "a");
          return e5.length + (e5.length != t5 ? 3 : 0);
        }(t4), o4 = 0, r3 = w2.length; o4 <= r3; o4++) {
          var a4 = 0;
          switch (e4) {
            case n3.L:
              a4 = w2[o4][0];
              break;
            case n3.M:
              a4 = w2[o4][1];
              break;
            case n3.Q:
              a4 = w2[o4][2];
              break;
            case n3.H:
              a4 = w2[o4][3];
          }
          if (i4 <= a4) break;
          s4++;
        }
        if (s4 > w2.length) throw new Error("Too long data");
        return s4;
      }
      p = function(t4, e4) {
        if (this._htOption = { width: 256, height: 256, typeNumber: 4, colorDark: "#000000", colorLight: "#ffffff", correctLevel: n3.H }, "string" == typeof e4 && (e4 = { text: e4 }), e4) for (var s4 in e4) this._htOption[s4] = e4[s4];
        "string" == typeof t4 && (t4 = document.getElementById(t4)), this._htOption.useSVG && (Z2 = svgDrawer), this._el = t4, this._oQRCode = null, this._oDrawing = new Z2(this._el, this._htOption), this._htOption.text && this.makeCode(this._htOption.text);
      }, p.prototype.makeCode = function(t4) {
        this._oQRCode = new e3(X2(t4, this._htOption.correctLevel), this._htOption.correctLevel), this._oQRCode.addData(t4), this._oQRCode.make(), this._oDrawing.draw(this._oQRCode);
      }, p.prototype.clear = function() {
        this._oDrawing.clear();
      }, p.prototype.getCanvas = function() {
        for (let t4 = 0; t4 < this._el.children.length; t4++) {
          const e4 = this._el.children[t4];
          if ("CANVAS" === e4.tagName) return e4;
        }
        return null;
      }, p.CorrectLevel = n3;
    }();
    var x = p;
    var S = { exports: {} };
    var G;
    var T = { exports: {} };
    var W = o2(Object.freeze({ __proto__: null, default: {} }));
    function C() {
      return G || (G = 1, T.exports = (t3 = t3 || function(t4, e3) {
        var s3;
        if ("undefined" != typeof window && window.crypto && (s3 = window.crypto), "undefined" != typeof self && self.crypto && (s3 = self.crypto), "undefined" != typeof globalThis && globalThis.crypto && (s3 = globalThis.crypto), !s3 && "undefined" != typeof window && window.msCrypto && (s3 = window.msCrypto), !s3 && void 0 !== n2 && n2.crypto && (s3 = n2.crypto), !s3) try {
          s3 = W;
        } catch (t5) {
        }
        var i3 = function() {
          if (s3) {
            if ("function" == typeof s3.getRandomValues) try {
              return s3.getRandomValues(new Uint32Array(1))[0];
            } catch (t5) {
            }
            if ("function" == typeof s3.randomBytes) try {
              return s3.randomBytes(4).readInt32LE();
            } catch (t5) {
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        }, o3 = Object.create || /* @__PURE__ */ function() {
          function t5() {
          }
          return function(e4) {
            var s4;
            return t5.prototype = e4, s4 = new t5(), t5.prototype = null, s4;
          };
        }(), r2 = {}, a3 = r2.lib = {}, l3 = a3.Base = { extend: function(t5) {
          var e4 = o3(this);
          return t5 && e4.mixIn(t5), e4.hasOwnProperty("init") && this.init !== e4.init || (e4.init = function() {
            e4.$super.init.apply(this, arguments);
          }), e4.init.prototype = e4, e4.$super = this, e4;
        }, create: function() {
          var t5 = this.extend();
          return t5.init.apply(t5, arguments), t5;
        }, init: function() {
        }, mixIn: function(t5) {
          for (var e4 in t5) t5.hasOwnProperty(e4) && (this[e4] = t5[e4]);
          t5.hasOwnProperty("toString") && (this.toString = t5.toString);
        }, clone: function() {
          return this.init.prototype.extend(this);
        } }, c2 = a3.WordArray = l3.extend({ init: function(t5, s4) {
          t5 = this.words = t5 || [], this.sigBytes = s4 != e3 ? s4 : 4 * t5.length;
        }, toString: function(t5) {
          return (t5 || h2).stringify(this);
        }, concat: function(t5) {
          var e4 = this.words, s4 = t5.words, n3 = this.sigBytes, i4 = t5.sigBytes;
          if (this.clamp(), n3 % 4) for (var o4 = 0; o4 < i4; o4++) {
            var r3 = s4[o4 >>> 2] >>> 24 - o4 % 4 * 8 & 255;
            e4[n3 + o4 >>> 2] |= r3 << 24 - (n3 + o4) % 4 * 8;
          }
          else for (var a4 = 0; a4 < i4; a4 += 4) e4[n3 + a4 >>> 2] = s4[a4 >>> 2];
          return this.sigBytes += i4, this;
        }, clamp: function() {
          var e4 = this.words, s4 = this.sigBytes;
          e4[s4 >>> 2] &= 4294967295 << 32 - s4 % 4 * 8, e4.length = t4.ceil(s4 / 4);
        }, clone: function() {
          var t5 = l3.clone.call(this);
          return t5.words = this.words.slice(0), t5;
        }, random: function(t5) {
          for (var e4 = [], s4 = 0; s4 < t5; s4 += 4) e4.push(i3());
          return new c2.init(e4, t5);
        } }), d2 = r2.enc = {}, h2 = d2.Hex = { stringify: function(t5) {
          for (var e4 = t5.words, s4 = t5.sigBytes, n3 = [], i4 = 0; i4 < s4; i4++) {
            var o4 = e4[i4 >>> 2] >>> 24 - i4 % 4 * 8 & 255;
            n3.push((o4 >>> 4).toString(16)), n3.push((15 & o4).toString(16));
          }
          return n3.join("");
        }, parse: function(t5) {
          for (var e4 = t5.length, s4 = [], n3 = 0; n3 < e4; n3 += 2) s4[n3 >>> 3] |= parseInt(t5.substr(n3, 2), 16) << 24 - n3 % 8 * 4;
          return new c2.init(s4, e4 / 2);
        } }, u2 = d2.Latin1 = { stringify: function(t5) {
          for (var e4 = t5.words, s4 = t5.sigBytes, n3 = [], i4 = 0; i4 < s4; i4++) {
            var o4 = e4[i4 >>> 2] >>> 24 - i4 % 4 * 8 & 255;
            n3.push(String.fromCharCode(o4));
          }
          return n3.join("");
        }, parse: function(t5) {
          for (var e4 = t5.length, s4 = [], n3 = 0; n3 < e4; n3++) s4[n3 >>> 2] |= (255 & t5.charCodeAt(n3)) << 24 - n3 % 4 * 8;
          return new c2.init(s4, e4);
        } }, m2 = d2.Utf8 = { stringify: function(t5) {
          try {
            return decodeURIComponent(escape(u2.stringify(t5)));
          } catch (t6) {
            throw new Error("Malformed UTF-8 data");
          }
        }, parse: function(t5) {
          return u2.parse(unescape(encodeURIComponent(t5)));
        } }, p2 = a3.BufferedBlockAlgorithm = l3.extend({ reset: function() {
          this._data = new c2.init(), this._nDataBytes = 0;
        }, _append: function(t5) {
          "string" == typeof t5 && (t5 = m2.parse(t5)), this._data.concat(t5), this._nDataBytes += t5.sigBytes;
        }, _process: function(e4) {
          var s4, n3 = this._data, i4 = n3.words, o4 = n3.sigBytes, r3 = this.blockSize, a4 = o4 / (4 * r3), l4 = (a4 = e4 ? t4.ceil(a4) : t4.max((0 | a4) - this._minBufferSize, 0)) * r3, d3 = t4.min(4 * l4, o4);
          if (l4) {
            for (var h3 = 0; h3 < l4; h3 += r3) this._doProcessBlock(i4, h3);
            s4 = i4.splice(0, l4), n3.sigBytes -= d3;
          }
          return new c2.init(s4, d3);
        }, clone: function() {
          var t5 = l3.clone.call(this);
          return t5._data = this._data.clone(), t5;
        }, _minBufferSize: 0 });
        a3.Hasher = p2.extend({ cfg: l3.extend(), init: function(t5) {
          this.cfg = this.cfg.extend(t5), this.reset();
        }, reset: function() {
          p2.reset.call(this), this._doReset();
        }, update: function(t5) {
          return this._append(t5), this._process(), this;
        }, finalize: function(t5) {
          return t5 && this._append(t5), this._doFinalize();
        }, blockSize: 16, _createHelper: function(t5) {
          return function(e4, s4) {
            return new t5.init(s4).finalize(e4);
          };
        }, _createHmacHelper: function(t5) {
          return function(e4, s4) {
            return new f2.HMAC.init(t5, s4).finalize(e4);
          };
        } });
        var f2 = r2.algo = {};
        return r2;
      }(Math), t3)), T.exports;
      var t3;
    }
    var k;
    var P;
    var I;
    var R = (k || (k = 1, S.exports = (P = C(), function() {
      if ("function" == typeof ArrayBuffer) {
        var t3 = P.lib.WordArray, e3 = t3.init, s3 = t3.init = function(t4) {
          if (t4 instanceof ArrayBuffer && (t4 = new Uint8Array(t4)), (t4 instanceof Int8Array || "undefined" != typeof Uint8ClampedArray && t4 instanceof Uint8ClampedArray || t4 instanceof Int16Array || t4 instanceof Uint16Array || t4 instanceof Int32Array || t4 instanceof Uint32Array || t4 instanceof Float32Array || t4 instanceof Float64Array) && (t4 = new Uint8Array(t4.buffer, t4.byteOffset, t4.byteLength)), t4 instanceof Uint8Array) {
            for (var s4 = t4.byteLength, n3 = [], i3 = 0; i3 < s4; i3++) n3[i3 >>> 2] |= t4[i3] << 24 - i3 % 4 * 8;
            e3.call(this, n3, s4);
          } else e3.apply(this, arguments);
        };
        s3.prototype = t3;
      }
    }(), P.lib.WordArray)), S.exports);
    var V = i2(R);
    var Y = { exports: {} };
    function M() {
      return I || (I = 1, Y.exports = function(t3) {
        return function(e3) {
          var s3 = t3, n3 = s3.lib, i3 = n3.WordArray, o3 = n3.Hasher, r2 = s3.algo, a3 = [], l3 = [];
          !function() {
            function t4(t5) {
              for (var s5 = e3.sqrt(t5), n5 = 2; n5 <= s5; n5++) if (!(t5 % n5)) return false;
              return true;
            }
            function s4(t5) {
              return 4294967296 * (t5 - (0 | t5)) | 0;
            }
            for (var n4 = 2, i4 = 0; i4 < 64; ) t4(n4) && (i4 < 8 && (a3[i4] = s4(e3.pow(n4, 0.5))), l3[i4] = s4(e3.pow(n4, 1 / 3)), i4++), n4++;
          }();
          var c2 = [], d2 = r2.SHA256 = o3.extend({ _doReset: function() {
            this._hash = new i3.init(a3.slice(0));
          }, _doProcessBlock: function(t4, e4) {
            for (var s4 = this._hash.words, n4 = s4[0], i4 = s4[1], o4 = s4[2], r3 = s4[3], a4 = s4[4], d3 = s4[5], h2 = s4[6], u2 = s4[7], m2 = 0; m2 < 64; m2++) {
              if (m2 < 16) c2[m2] = 0 | t4[e4 + m2];
              else {
                var p2 = c2[m2 - 15], f2 = (p2 << 25 | p2 >>> 7) ^ (p2 << 14 | p2 >>> 18) ^ p2 >>> 3, b2 = c2[m2 - 2], y2 = (b2 << 15 | b2 >>> 17) ^ (b2 << 13 | b2 >>> 19) ^ b2 >>> 10;
                c2[m2] = f2 + c2[m2 - 7] + y2 + c2[m2 - 16];
              }
              var g2 = n4 & i4 ^ n4 & o4 ^ i4 & o4, w2 = (n4 << 30 | n4 >>> 2) ^ (n4 << 19 | n4 >>> 13) ^ (n4 << 10 | n4 >>> 22), Z2 = u2 + ((a4 << 26 | a4 >>> 6) ^ (a4 << 21 | a4 >>> 11) ^ (a4 << 7 | a4 >>> 25)) + (a4 & d3 ^ ~a4 & h2) + l3[m2] + c2[m2];
              u2 = h2, h2 = d3, d3 = a4, a4 = r3 + Z2 | 0, r3 = o4, o4 = i4, i4 = n4, n4 = Z2 + (w2 + g2) | 0;
            }
            s4[0] = s4[0] + n4 | 0, s4[1] = s4[1] + i4 | 0, s4[2] = s4[2] + o4 | 0, s4[3] = s4[3] + r3 | 0, s4[4] = s4[4] + a4 | 0, s4[5] = s4[5] + d3 | 0, s4[6] = s4[6] + h2 | 0, s4[7] = s4[7] + u2 | 0;
          }, _doFinalize: function() {
            var t4 = this._data, s4 = t4.words, n4 = 8 * this._nDataBytes, i4 = 8 * t4.sigBytes;
            return s4[i4 >>> 5] |= 128 << 24 - i4 % 32, s4[14 + (i4 + 64 >>> 9 << 4)] = e3.floor(n4 / 4294967296), s4[15 + (i4 + 64 >>> 9 << 4)] = n4, t4.sigBytes = 4 * s4.length, this._process(), this._hash;
          }, clone: function() {
            var t4 = o3.clone.call(this);
            return t4._hash = this._hash.clone(), t4;
          } });
          s3.SHA256 = o3._createHelper(d2), s3.HmacSHA256 = o3._createHmacHelper(d2);
        }(Math), t3.SHA256;
      }(C())), Y.exports;
    }
    var H = i2(M());
    var K = "node" === l2.CROQUET_PLATFORM;
    var N;
    function z(t3) {
      const e3 = t3.sigBytes, s3 = t3.words, n3 = new Uint8Array(e3);
      let i3 = 0, o3 = 0;
      for (; i3 < e3; ) {
        const t4 = s3[o3++];
        if (n3[i3++] = (4278190080 & t4) >>> 24, i3 === e3) break;
        if (n3[i3++] = (16711680 & t4) >>> 16, i3 === e3) break;
        if (n3[i3++] = (65280 & t4) >>> 8, i3 === e3) break;
        n3[i3++] = 255 & t4;
      }
      return n3;
    }
    function _(t3) {
      function e3(t4) {
        const e4 = t4.indexOf("{"), s4 = t4.lastIndexOf("}");
        if (-1 === e4 || -1 === s4 || s4 < e4) return t4;
        const n3 = t4.slice(0, e4).replace(/\s+/g, " ").replace(/\s\(/, "("), i3 = t4.slice(e4 + 1, s4);
        return `${n3.trim()}{${i3.trim()}}`;
      }
      let s3 = e3("" + t3);
      if (!s3.startsWith("class")) {
        const n3 = t3.prototype;
        n3 && (s3 += Object.getOwnPropertyNames(n3).map((t4) => `${t4}:${e3("" + n3[t4])}`).join(""));
      }
      return s3;
    }
    function F(t3) {
      return btoa(String.fromCharCode(...new Uint8Array(t3))).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function E() {
      return m.has("debug", "hashing", false);
    }
    N = globalThis.crypto && globalThis.crypto.subtle && "function" == typeof globalThis.crypto.subtle.digest ? globalThis.crypto.subtle.digest.bind(globalThis.crypto.subtle) : (t3, e3) => {
      if ("SHA-256" !== t3) throw Error(`${Qt.libName}: only SHA-256 available`);
      const s3 = V.create(e3);
      return z(H(s3)).buffer;
    };
    var j = {};
    var J = new TextEncoder();
    async function Q(t3) {
      const e3 = J.encode(t3), s3 = await async function(t4) {
        return 0 === t4.length ? "47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU" : F(await N("SHA-256", t4));
      }(e3);
      return j[s3] = { string: t3, buffer: e3 }, s3;
    }
    var U = [];
    var D = {};
    var O = /* @__PURE__ */ new Set();
    var B = Date.now();
    "undefined" == typeof performance && (window.performance = { now: () => Date.now() - B });
    var A = ["simulate", "update", "render", "snapshot"];
    var $ = { total: "black", update: "blue", render: "magenta", simulate: "yellow", snapshot: "green", backlog: "red", network: "lightgray" };
    var q;
    var tt;
    var et = null;
    var st = null;
    var nt = null;
    var it = 0;
    var ot = null;
    var rt = null;
    function at(t3) {
      for (et = t3; t3.firstChild; ) t3.removeChild(t3.firstChild);
      t3.style.background = "#faf0dc", ot = document.createElement("canvas"), rt = ot.getContext("2d"), ot.id = "text_stats", ot.width = Math.min(140, window.innerWidth), ot.height = 36, ot.style.width = ot.width, ot.style.height = ot.height, rt.font = "9.5pt sans-serif", t3.appendChild(ot), t3.title = Object.entries($).map((t4) => {
        let [e4, s3] = t4;
        return `${s3}: ${e4}`;
      }).join("\n"), st = document.createElement("canvas"), st.width = Math.min(125, window.innerWidth), st.height = 125, st.style.width = "100%";
      const e3 = document.createElement("div");
      e3.id = "innerDiv", t3.appendChild(e3), e3.appendChild(st), nt = st.getContext("2d");
    }
    var lt = [];
    var ct = 0;
    var dt = false;
    var ht = ft(0);
    var ut = 1e3 / 60;
    function mt(t3) {
      return 20 * (1 - t3 / ut) + 60;
    }
    function pt(t3) {
      q = function(t4) {
        const e3 = document.createElement("canvas");
        return e3.width = t4.width, e3.height = t4.height, e3.style.width = "100%", e3.style.position = "absolute", e3.style.left = "0px", et.querySelector("#innerDiv").appendChild(e3), e3;
      }(t3), tt = q.getContext("2d"), tt.strokeStyle = "rgba(255, 255, 255, 0.5)";
      for (let t4 = 0; t4 < 60; t4 += ut) {
        const e3 = mt(t4);
        tt.moveTo(0, e3), tt.lineTo(q.width, e3), tt.stroke();
      }
    }
    function ft(t3) {
      return { start: t3, total: 0, items: {}, users: 0, backlog: 0, network: 0, latency: 0, activity: 1e3, connected: dt };
    }
    function bt(t3) {
      ht.total = t3 - ht.start;
      const e3 = Math.min(120, window.innerWidth);
      if (lt.length >= e3 && lt.splice(0, lt.length - e3 + 1), lt.push(ht), lt.length <= 1) return;
      if (!et) return;
      if (0 === et.offsetHeight) return;
      const s3 = lt.slice(1).filter((t4) => t4.total), n3 = s3.map((t4) => t4.total).reduce((t4, e4) => t4 + e4, 0) / s3.length, i3 = Math.max(...s3.map((t4) => t4.total));
      Math.max(...s3.map((t4) => Math.max(t4.backlog, t4.network))), ct = 1e3, function(t4, e4) {
        rt.globalCompositeOperation = "copy", rt.fillStyle = "rgb(255, 255, 255, 0)", rt.fillRect(0, 0, ot.width, ot.height), rt.fillStyle = "rgb(0, 0, 0, 1)", rt.globalCompositeOperation = "source-over";
        let s4 = `${ht.users} users, ${Math.round(1e3 / t4)} fps`;
        e4 > 70 && (s4 += ` ${Math.ceil(e4).toLocaleString()}ms`), rt.fillText(s4, 2, 15), s4 = ht.backlog < 100 && ht.activity < 1e3 ? `latency: ${ht.latency} ms` : `backlog: ${ht.backlog < 100 ? "0.0" : (ht.backlog / 1e3).toFixed(1)} s`, rt.fillText(s4, 2, 33);
      }(n3, i3), q || pt(st), it === st.width ? (nt.globalCompositeOperation = "copy", nt.drawImage(st, 1, 0, st.width - 1, st.height, 0, 0, st.width - 1, st.height), nt.globalCompositeOperation = "source-over", nt.fillStyle = "transparent", nt.fillRect(st.width - 1, 0, 1, st.height)) : it++;
      const o3 = (t4) => mt(t4 / ct * -2 * ut) + 5;
      {
        const t4 = lt[lt.length - 1], e4 = it - 0.5;
        let s4 = mt(0);
        nt.beginPath(), nt.moveTo(e4, s4), nt.lineTo(e4, mt(t4.total)), nt.strokeStyle = $[t4.connected ? "total" : "network"], nt.stroke(), nt.beginPath(), nt.moveTo(e4, s4), s4 = mt(t4.total);
        let n4 = 0;
        for (const i4 of A) t4.items[i4] && (n4 += t4.items[i4], s4 = mt(n4), nt.lineTo(e4, s4), nt.strokeStyle = $[i4], nt.stroke(), nt.beginPath(), nt.moveTo(e4, s4));
        t4.network && (nt.beginPath(), nt.moveTo(e4, o3(0)), nt.lineTo(e4, o3(t4.network)), nt.strokeStyle = $.network, nt.stroke());
      }
    }
    var yt = [];
    var gt = {};
    var wt = {};
    var Zt = { frames: lt, animationFrame(t3) {
      let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      bt(t3), ht = ft(t3);
      for (const [t4, s3] of Object.entries(e3)) this[t4](s3);
    }, begin(t3) {
      const e3 = performance.now();
      ht.items[t3] = (ht.items[t3] || 0) - e3;
      const s3 = yt[yt.length - 1];
      return s3 && (ht.items[s3] += e3), yt.push(t3), e3;
    }, end(t3) {
      const e3 = performance.now();
      ht.items[t3] += e3;
      const s3 = yt.pop();
      if (s3 !== t3) throw Error(`Unmatched stats calls: expected end("${s3}"), got end("${t3}")`);
      const n3 = yt[yt.length - 1];
      return n3 && (ht.items[n3] -= e3), e3;
    }, backlog(t3) {
      ht.backlog = Math.max(t3, ht.backlog);
    }, starvation(t3) {
      ht.network = t3;
    }, latency(t3) {
      ht.latency = t3;
    }, activity(t3) {
      ht.activity = t3;
    }, users(t3) {
      ht.users = t3;
    }, connected(t3) {
      const e3 = dt;
      ht.connected = dt = t3, e3 && !dt && q && (q.remove(), tt = null);
    }, networkTraffic: gt, addNetworkTraffic(t3, e3) {
      let s3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      gt[t3] = (gt[t3] || 0) + e3, s3 && (gt[`audit_${t3}`] = (gt[`audit_${t3}`] || 0) + e3);
    }, resetAuditStats() {
      for (const t3 in gt) t3.startsWith("audit_") && (gt[t3] = 0);
    }, perSecondTally() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      if (window.logMessageStats) for (const [e3, s3] of Object.entries(t3)) wt[e3] = (wt[e3] || 0) + s3;
    }, stepSession(t3) {
      let e3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      const s3 = Math.floor(Date.now() / 1e3);
      if (!window.logMessageStats) return wt = { second: s3 }, null;
      let n3 = null;
      if (s3 !== wt.second) {
        if (wt.second && e3 && (wt.requestedMessages || wt.sentMessagesTotal)) {
          n3 = { ...wt };
          const t4 = s3 - wt.second;
          1 !== t4 && (n3.sampleSeconds = t4), n3.sentBundles && (n3.averageDelay = Math.round(10 * n3.sendDelay / n3.sentMessagesTotal) / 10, n3.averageBundlePayload = Math.round(n3.sentBundlePayload / n3.sentBundles)), delete n3.second, delete n3.sendDelay, delete n3.sentBundlePayload;
        }
        wt = { second: s3 };
      }
      return n3;
    } };
    globalThis.CROQUETSTATS = Zt;
    var Xt = "ontouchstart" in document.documentElement;
    var vt = window && window.parent !== window;
    var Lt = Xt ? 20 : 12;
    var xt = Xt ? 0 : 15;
    var St = false;
    var Gt = false;
    var Tt;
    var Wt = false;
    function Ct(t3) {
      let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return t3 && Qt.showMessage(t3, { ...e3, level: "warning" });
    }
    function kt(t3) {
      let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return t3 && Qt.showMessage(t3, { ...e3, level: "status" });
    }
    function Pt(t3, e3) {
      let s3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "error";
      console.error(`Error during ${t3}`, e3);
      const n3 = (e3.stack || "").split("\n").filter((t4) => !t4.match(/croquet-.*\.min.js/)).join("\n");
      Qt.showMessage(`Error during ${t3}: ${e3.message}

${n3}`, { level: s3, duration: "error" === s3 ? 1e4 : void 0, stopOnFocus: true });
    }
    try {
      if (Tt = window.localStorage, Tt["croquet-debug-persist-allowed"] = "true", "true" !== Tt["croquet-debug-persist-allowed"]) throw Error("localStorage not persisted");
      delete Tt["croquet-debug-persist-allowed"];
    } catch (_r2) {
      console.warn("localStorage not allowed"), Tt = {};
    }
    var It = { get pinned() {
      return "true" === Tt[window.location.pathname + "/croquet-debug-ui-pinned"];
    }, set pinned(t3) {
      Tt[window.location.pathname + "/croquet-debug-ui-pinned"] = !!t3;
    }, get activePage() {
      return Tt[window.location.pathname + "/croquet-debug-ui-activePage"];
    }, set activePage(t3) {
      Tt[window.location.pathname + "/croquet-debug-ui-activePage"] = t3;
    } };
    var Rt = (t3) => {
      t3.preventDefault(), t3.stopPropagation();
    };
    function Vt(t3, e3, s3) {
      const n3 = document.createElement("canvas"), i3 = n3.width = 40 * Lt / 12, o3 = n3.height = 60, r2 = n3.getContext("2d");
      r2.font = "36px Arial", r2.textAlign = "center", r2.textBaseline = "middle", r2.fillStyle = "black", r2.fillText(t3, i3 / 2, 0.55 * o3);
      const a3 = document.createElement("button");
      a3.id = e3, a3.className = "croquet_dock_button";
      const l3 = (t4) => {
        t4.preventDefault(), t4.stopPropagation(), s3();
      };
      return Xt ? (a3.ontouchstart = l3, a3.ontouchend = Rt, a3.onpointerdown = Rt, a3.onpointerup = Rt) : (a3.onclick = l3, a3.onpointerdown = Rt, a3.onpointerup = Rt), a3.appendChild(n3), a3;
    }
    function Yt(t3, e3) {
      if (false === Qt.badge) return;
      const s3 = function(t4) {
        const e4 = new Z(t4), s4 = ["bcdfghjklmnpqrstvwxyz", "aeiou"];
        let n4 = "";
        for (let t5 = 0; t5 < 5; t5++) n4 += s4[t5 % 2][e4.quick() * s4[t5 % 2].length | 0];
        return n4;
      }(e3);
      for (document.title = document.title.replace(/:.*/, ""), document.title += ":" + s3; t3.firstChild; ) t3.removeChild(t3.firstChild);
      const n3 = document.createElement("canvas"), i3 = n3.width = 120, o3 = n3.height = 40;
      n3.style.width = "100%", t3.appendChild(n3);
      const r2 = n3.getContext("2d"), a3 = function(t4) {
        let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
        const s4 = new Z(t4), n4 = [];
        for (let t5 = 0; t5 < e4; t5++) n4.push(`hsl(${360 * s4.quick()}, 50%, 70%)`);
        return n4;
      }(e3, 2);
      r2.fillStyle = a3[0], r2.beginPath(), r2.moveTo(0, 0), r2.lineTo(0, o3), r2.lineTo(i3, 0), r2.closePath(), r2.fill(), r2.fillStyle = a3[1], r2.beginPath(), r2.moveTo(i3, o3), r2.lineTo(i3, 0), r2.lineTo(0, o3), r2.closePath(), r2.fill(), r2.font = "30px Arial", r2.textAlign = "center", r2.textBaseline = "middle", r2.fillStyle = "black", r2.fillText(s3, i3 / 2, o3 / 2);
    }
    function Mt(t3, e3) {
      let s3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
      for (; t3.firstChild; ) t3.removeChild(t3.firstChild);
      return new x(t3, { text: e3, width: 128, height: 128, colorDark: "#000000", colorLight: "#ffffff", correctLevel: x.CorrectLevel.L, ...s3 });
    }
    function Ht() {
      if (false === Qt.root || false === Qt.qrcode) return;
      if (m.noqr) return;
      const t3 = Qt.sessionURL;
      if (!t3) return void console.warn("App.sessionURL is not set");
      const e3 = Ft(Qt.qrcode);
      if (!e3) return;
      Xt || (e3.onclick = (e4) => {
        e4.preventDefault(), e4.stopPropagation(), e4.shiftKey ? function() {
          const t4 = document.getElementById("croquet_dock");
          t4 && t4.classList.toggle("debug");
        }() : window.open(t3);
      });
      Mt(e3, t3).getCanvas().style.width = "100%";
    }
    var Kt;
    var Nt;
    var zt = 0;
    function _t() {
      !function() {
        if (Gt) return;
        Gt = true;
        const t4 = `
        ${vt ? "body { min-height: 100vh }" : ""}
        #croquet_spinnerOverlay {
            z-index: 1000;
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color:#333;
            opacity:0.9;
            display:flex;
            align-items:center;
            justify-content:center;
            transition: opacity 1.0s ease-out;
        }
        /* https://github.com/lukehaas/css-loaders */
        @keyframes croquet_dots {
            0%, 80%, 100% { box-shadow: 0 2.5em 0 -1.3em; }
            40% { box-shadow: 0 2.5em 0 0; }
        }
        #croquet_loader,
        #croquet_loader::before,
        #croquet_loader::after {
          border-radius: 50%;
          width: 2.5em;
          height: 2.5em;
          animation: croquet_dots 1.8s infinite ease-in-out;
        }
        #croquet_loader {
          color: #fff;
          font-size: 10px;
          margin: 80px auto;
          position: relative;
          text-indent: -9999em;
          animation-delay: -0.16s;
        }
        #croquet_loader::before,
        #croquet_loader::after {
          content: '';
          position: absolute;
          top: 0;
        }
        #croquet_loader::before { left: -3.5em; animation-delay: -0.32s; }
        #croquet_loader::after { left: 3.5em; }
        #croquet_spinnerOverlay.croquet_error>*,
        #croquet_spinnerOverlay.croquet_error>*::before,
        #croquet_spinnerOverlay.croquet_error>*::after {
            color: #f00;
        }
        #croquet_spinnerOverlay.croquet_fatal>*,
        #croquet_spinnerOverlay.croquet_fatal>*::before,
        #croquet_spinnerOverlay.croquet_fatal>*::after {
            color: #f00;
            box-shadow: 0 2.5em 0 0 !important;
            animation: none !important;
        }
`, e4 = document.createElement("style");
        e4.innerHTML = t4, document.head.insertBefore(e4, document.head.querySelector("style,link[rel=stylesheet]"));
      }();
      const t3 = document.createElement("div");
      t3.id = "croquet_spinnerOverlay";
      const e3 = document.createElement("div");
      return e3.id = "croquet_loader", e3.innerText = "Catching up...", t3.appendChild(e3), t3;
    }
    function Ft(t3, e3) {
      if (false === t3) return false;
      if (t3 instanceof Element) return t3;
      if ("string" == typeof t3) {
        const e4 = document.getElementById(t3);
        if (e4) return e4;
      }
      return e3 ? e3() : null;
    }
    function Et() {
      const t3 = new Uint8Array(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 16);
      return window.crypto.getRandomValues(t3), F(t3.buffer);
    }
    var jt = /* @__PURE__ */ new Set();
    var Jt = function() {
      let t3 = null;
      const e3 = document.getElementsByTagName("link");
      for (const s3 of e3) if ("canonical" === s3.getAttribute("rel")) {
        t3 = s3.getAttribute("href");
        break;
      }
      return t3 || window.location.href;
    }();
    var Qt = { get libName() {
      return globalThis.__MULTISYNQ__ ? "Multisynq" : "Croquet";
    }, get sessionURL() {
      return Jt;
    }, set sessionURL(t3) {
      Jt = t3, Ht();
    }, root: null, sync: true, messages: false, badge: false, stats: false, qrcode: false, makeWidgetDock: function() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      if (m.nodock) return;
      const e3 = t3.debug || m.debug, s3 = document.getElementById("croquet_dock");
      s3 && s3.parentElement.removeChild(s3);
      const n3 = Ft(Qt.root, () => document.body);
      if (!n3) return;
      !function() {
        if (St) return;
        St = true;
        const t4 = `
        #croquet_dock { position: fixed; z-index: 2; border: 3px solid white; bottom: 6px; left: 6px; width: 36px; height: 36px; box-sizing: border-box; background: white; opacity: 0.4; transition: all 0.3s ease; }
        #croquet_dock.active { opacity: 0.95; border-radius: 12px; }
        #croquet_dock.debug { width: 84px; }
        #croquet_dock_bar { position: absolute; border: 3px solid white; width: 100%; height: 30px; box-sizing: border-box; background: white; }

        #croquet_badge { position: absolute; width: 72px; height: 24px; top: 50%; transform: translate(0px, -50%); cursor: none; }
        #croquet_dock.active #croquet_badge { left: 2%; }
        #croquet_dock:not(.debug) #croquet_badge { display: none; }

        .croquet_dock_button { position: absolute; width: ${Lt}%; height: 90%; top: 50%; transform: translate(0px, -50%); border-radius: 20%; }
        .croquet_dock_button:focus { outline: 0; }
        .croquet_dock_button canvas { position: absolute; width: 100%; height: 100%; top: 0px; left: 0px; }
        #croquet_dock:not(.active) .croquet_dock_button { display: none; }
        #croquet_dock_left { right: ${2 + xt + Lt + 2}% }
        #croquet_dock:not(.debug) #croquet_dock_left { display: none; }
        #croquet_dock_right { right: ${2 + xt}%; }
        #croquet_dock:not(.debug) #croquet_dock_right { display: none; }
        #croquet_dock_pin { right: 2%; }
        #croquet_dock_pin.pinned { background: #cce6ff; }

        #croquet_dock_content { position: absolute; left: 2px; top: 2px; right: 2px; bottom: 2px; background: white; overflow: hidden; }
        #croquet_dock.debug:not(.active) #croquet_dock_content { display: none; }
        #croquet_dock.debug:not(.active) #croquet_dock_content div { display: none; }

        #croquet_qrcode { position: absolute; width: 100%; height: 100%;box-sizing: border-box; cursor: crosshair; }
        #croquet_dock.active #croquet_qrcode { border: 6px solid white; }
        #croquet_dock.debug #croquet_qrcode:not(.active) { display: none; }
        #croquet_qrcode canvas { image-rendering: pixelated; }

        #croquet_stats { position: absolute; width: 70%; height: 90%; left: 15%; top: 5%; opacity: 0.8; font-family: sans-serif; }
        #croquet_stats:not(.active) { display: none; }
`, e4 = document.createElement("style");
        e4.innerHTML = t4, document.head.insertBefore(e4, document.head.querySelector("style,link[rel=stylesheet]"));
      }();
      const i3 = document.createElement("div");
      i3.id = "croquet_dock", e3 && i3.classList.add("debug"), vt && false === t3.iframe && (i3.style.display = "none"), n3.appendChild(i3);
      const o3 = document.createElement("div");
      let r2;
      o3.id = "croquet_dock_bar", i3.appendChild(o3), false !== t3.badge && (r2 = document.createElement("div"), r2.id = "croquet_badge", o3.appendChild(r2), Qt.badge = r2);
      const a3 = document.createElement("div");
      a3.id = "croquet_dock_content", i3.appendChild(a3);
      const l3 = [];
      let c2, d2;
      if (false !== t3.qrcode) {
        Qt.sessionURL && (c2 = document.createElement("div"), c2.id = "croquet_qrcode", a3.appendChild(c2), l3.push(c2.id), Qt.qrcode = c2, e3 || (It.activePage = c2.id));
      }
      if (false !== t3.stats && (d2 = document.createElement("div"), d2.id = "croquet_stats", a3.appendChild(d2), l3.push(d2.id), Qt.stats = d2), l3.length) {
        let b2 = function(t4) {
          const e4 = l3.length;
          let s4, n4 = 0;
          if (It.activePage) {
            const t5 = l3.indexOf(It.activePage);
            t5 >= 0 ? (n4 = t5, s4 = document.getElementById(It.activePage)) : It.activePage = null;
          }
          const i4 = l3[(n4 + e4 + t4) % e4];
          let o4;
          i4 === It.activePage ? o4 = s4 : (s4 && s4.classList.remove("active"), o4 = document.getElementById(i4)), o4 && o4.classList.add("active"), It.activePage = i4;
        };
        l3.length > 1 && (o3.appendChild(Vt("<", "croquet_dock_left", () => b2(-1))), o3.appendChild(Vt(">", "croquet_dock_right", () => b2(1)))), b2(0);
      }
      if (!Xt && !t3.alwaysPinned) {
        const y2 = Vt("📌", "croquet_dock_pin", () => {
          It.pinned = !It.pinned, g2();
        }), g2 = () => {
          It.pinned ? y2.classList.add("pinned") : y2.classList.remove("pinned");
        };
        g2(), o3.appendChild(y2);
      }
      const h2 = (t4) => {
        i3.style.width = `${t4}px`;
        const e4 = 1.18 * t4;
        i3.style.height = `${e4}px`;
        const s4 = 18 * t4 / 100;
        o3.style.height = `${s4}px`, a3.style.top = `${s4 + 2}px`, r2 && (r2.style.height = 0.9 * s4 + "px", r2.style.width = 0.9 * s4 * 3 + "px"), c2 && (c2.style.border = 8 * t4 / 200 + "px solid white");
      };
      let u2 = t3.fixedSize || 200;
      const p2 = () => {
        i3.classList.add("active"), h2(u2), setTimeout(() => i3.style.transition = "none", 300);
      }, f2 = () => {
        i3.style.transition = "", i3.classList.remove("active"), i3.style.width = i3.style.height = "", o3.style.height = "", a3.style.top = "", r2 && (r2.style.height = r2.style.width = ""), c2 && (c2.style.border = "");
      };
      if (Xt) f2(), i3.ontouchstart = (t4) => {
        t4.preventDefault(), t4.stopPropagation(), i3.classList.contains("active") ? f2() : p2();
      }, i3.ontouchend = Rt, i3.onpointerdown = Rt, i3.onpointerup = Rt;
      else if (t3.alwaysPinned ? p2() : (It.pinned ? p2() : f2(), i3.onmouseenter = p2, i3.onmouseleave = () => {
        It.pinned || f2();
      }), !t3.fixedSize) {
        let w2 = 0;
        i3.addEventListener("wheel", (t4) => {
          t4.stopPropagation();
          const e4 = Date.now();
          if (e4 - w2 < 100) return;
          w2 = e4;
          let { deltaY: s4 } = t4;
          s4 = Math.sign(s4) * Math.min(5, Math.abs(s4));
          const n4 = 0.8 * Math.min(window.innerWidth, window.innerHeight);
          u2 = Math.max(166, Math.min(n4, i3.offsetWidth / 1.05 ** s4)), h2(u2);
        }, { passive: true });
      }
    }, makeSessionWidgets: function(t3) {
      !function(t4) {
        if (!t4 || false === Qt.root) return;
        const e3 = Ft(Qt.badge);
        e3 && Yt(e3, t4);
      }(t3), Ht(), function() {
        if (false === Qt.root) return;
        if (m.nostats) return;
        const t4 = Ft(Qt.stats);
        t4 && at(t4);
      }();
    }, makeQRCanvas() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      if (!Qt.sessionURL) return null;
      const e3 = Mt(document.createElement("div"), Qt.sessionURL, t3);
      return e3 && e3.getCanvas();
    }, clearSessionMoniker: function() {
      false !== Qt.badge && (document.title = document.title.replace(/:.*/, ""));
    }, showSyncWait(t3) {
      false === Qt.root ? t3 = false : Kt || (Kt = _t()), function(t4) {
        if (Nt !== t4 && ("string" != typeof Nt || true !== t4)) if (false === Qt.sync && (t4 = false), Nt = t4, t4) clearTimeout(zt), zt = setTimeout(() => {
          Nt && (Ft(Qt.root, () => document.body).appendChild(Kt), Kt.style.opacity = 0.9, Kt.className = "error" === Nt ? "croquet_error" : "fatal" === Nt ? "croquet_fatal" : "");
        }, 500);
        else {
          if (!Kt) return;
          clearTimeout(zt), Kt.style.opacity = 0, Kt.className = "", zt = setTimeout(() => {
            Nt || Kt.parentElement && Kt.parentElement.removeChild(Kt);
          }, 500);
        }
      }(t3);
    }, messageFunction: function(e3) {
      let s3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const n3 = s3.level;
      let i3;
      return "error" === n3 ? (i3 = "orangered,red", console.error(e3)) : "warning" === n3 ? (i3 = "gold,orange", console.warn(e3)) : i3 = "silver,gray", function(e4, s4) {
        const n4 = Ft(Qt.root, () => document.body);
        if (false === n4) return null;
        !function() {
          if (Wt) return;
          Wt = true;
          let t3 = "/*!\n        * Toastify js 1.5.0\n        * https://github.com/apvarun/toastify-js\n        * @license MIT licensed\n        *\n        * Copyright (C) 2018 Varun A P\n        */\n        .toastify {\n            padding: 12px 20px;\n            color: #ffffff;\n            display: inline-block;\n            box-shadow: 0 3px 6px -1px rgba(0, 0, 0, 0.12), 0 10px 36px -4px rgba(77, 96, 232, 0.3);\n            background: -webkit-linear-gradient(315deg, #73a5ff, #5477f5);\n            background: linear-gradient(135deg, #73a5ff, #5477f5);\n            position: fixed;\n            opacity: 0;\n            transition: all 0.4s cubic-bezier(0.215, 0.61, 0.355, 1);\n            border-radius: 2px;\n            cursor: pointer;\n            text-decoration: none;\n            max-width: calc(50% - 20px);\n            z-index: 2147483647;\n        }\n        .toastify.on {\n            opacity: 1;\n        }\n        .toast-close {\n            opacity: 0.4;\n            padding: 0 5px;\n        }\n        .toastify-right {\n            right: 15px;\n        }\n        .toastify-left {\n            left: 15px;\n        }\n        .toastify-top {\n            top: -150px;\n        }\n        .toastify-bottom {\n            bottom: -150px;\n        }\n        .toastify-rounded {\n            border-radius: 25px;\n        }\n        .toastify-avatar {\n            width: 1.5em;\n            height: 1.5em;\n            margin: 0 5px;\n            border-radius: 2px;\n        }\n        @media only screen and (max-width: 360px) {\n            .toastify-right, .toastify-left {\n                margin-left: auto;\n                margin-right: auto;\n                left: 0;\n                right: 0;\n                max-width: fit-content;\n            }\n        }\n";
          t3 += "\n        .toastify {\n            font-family: sans-serif;\n            border-radius: 8px;\n        }\n\n        .toastify-center {\n            margin-left: auto;\n            margin-right: auto;\n            left: 0;\n            right: 0;\n            max-width: fit-content;\n            max-width: -moz-fit-content;\n        }\n";
          const e5 = document.createElement("style");
          e5.innerHTML = "/*!\n        * Toastify js 1.5.0\n        * https://github.com/apvarun/toastify-js\n        * @license MIT licensed\n        *\n        * Copyright (C) 2018 Varun A P\n        */\n        .toastify {\n            padding: 12px 20px;\n            color: #ffffff;\n            display: inline-block;\n            box-shadow: 0 3px 6px -1px rgba(0, 0, 0, 0.12), 0 10px 36px -4px rgba(77, 96, 232, 0.3);\n            background: -webkit-linear-gradient(315deg, #73a5ff, #5477f5);\n            background: linear-gradient(135deg, #73a5ff, #5477f5);\n            position: fixed;\n            opacity: 0;\n            transition: all 0.4s cubic-bezier(0.215, 0.61, 0.355, 1);\n            border-radius: 2px;\n            cursor: pointer;\n            text-decoration: none;\n            max-width: calc(50% - 20px);\n            z-index: 2147483647;\n        }\n        .toastify.on {\n            opacity: 1;\n        }\n        .toast-close {\n            opacity: 0.4;\n            padding: 0 5px;\n        }\n        .toastify-right {\n            right: 15px;\n        }\n        .toastify-left {\n            left: 15px;\n        }\n        .toastify-top {\n            top: -150px;\n        }\n        .toastify-bottom {\n            bottom: -150px;\n        }\n        .toastify-rounded {\n            border-radius: 25px;\n        }\n        .toastify-avatar {\n            width: 1.5em;\n            height: 1.5em;\n            margin: 0 5px;\n            border-radius: 2px;\n        }\n        @media only screen and (max-width: 360px) {\n            .toastify-right, .toastify-left {\n                margin-left: auto;\n                margin-right: auto;\n                left: 0;\n                right: 0;\n                max-width: fit-content;\n            }\n        }\n\n        .toastify {\n            font-family: sans-serif;\n            border-radius: 8px;\n        }\n\n        .toastify-center {\n            margin-left: auto;\n            margin-right: auto;\n            left: 0;\n            right: 0;\n            max-width: fit-content;\n            max-width: -moz-fit-content;\n        }\n", document.head.insertBefore(e5, document.head.querySelector("style,link[rel=stylesheet]"));
        }();
        const i4 = { text: e4, duration: 3e3, gravity: "bottom", position: "right", stopOnFocus: true, ...s4 };
        let o3;
        n4 instanceof Element && n4 !== document.body ? (o3 = n4.id, o3 || (n4.id = o3 = "_croquetToastParent")) : "string" == typeof n4 && (o3 = n4);
        o3 && (i4.selector = o3);
        return t2(i4).showToast();
      }(e3, { style: { background: `linear-gradient(90deg,${i3})` }, ...s3 });
    }, showMessage(t3) {
      let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      if ("once" === e3.only) {
        if (jt.has(t3)) return null;
        jt.add(t3);
      }
      return "fatal" === e3.level && (e3.level = "error", e3.showSyncWait = "fatal"), e3.showSyncWait && ("fatal" !== e3.showSyncWait || e3.duration || (e3.duration = -1), Qt.showSyncWait(e3.showSyncWait)), m.nomessages || false === Qt.root || false === Qt.messages || !Qt.messageFunction ? ("warning" === e3.level && console.warn(t3), "error" === e3.level && console.error(t3), null) : Qt.messageFunction(t3, e3);
    }, isCroquetHost: (t3) => t3.endsWith("croquet.io") || ["localhost", "127.0.0.1", "[::1]"].includes(t3) || t3.endsWith("ngrok.io"), referrerURL() {
      const t3 = new URL(Qt.sessionURL), e3 = this.isCroquetHost(t3.hostname);
      return `${t3.protocol}//${t3.host}${t3.pathname}${e3 ? t3.search : ""}`;
    }, autoSession() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { key: "q", force: false, default: "", keyless: false };
      "string" == typeof t3 && (t3 = { key: t3 }), t3 || (t3 = {});
      const e3 = t3.key || "q", s3 = new URL(Qt.sessionURL);
      let n3 = "";
      if (!t3.force) {
        const i4 = s3.search.slice(1).split("&"), o3 = i4.find((t4) => t4.split("=")[0] === e3);
        o3 ? n3 = o3.replace(/[^=]*=/, "") : t3.keyless && (n3 = i4.find((t4) => !t4.includes("=")), n3 || (n3 = s3.hash.slice(1), n3 && (s3.hash = "", s3.search ? s3.searchParams.set(e3, n3) : s3.search = n3)));
      }
      if (n3) try {
        n3 = decodeURIComponent(n3);
      } catch (t4) {
      }
      else n3 = t3.default ? t3.default : this.randomSession(), s3.searchParams.set(e3, n3);
      if (Qt.sessionURL = s3.href, window.location.href !== s3.href) try {
        window.history.replaceState({}, "", s3.href);
      } catch (t4) {
        Qt.showMessage(`Setting address bar to ${s3.href}`, { only: "once" }), Qt.showMessage(`Failed to change address bar: ${t4.message}`, { level: "warning", only: "once" });
      }
      m.has("debug", "session") && console.log(`${Qt.libName}.App.autoSession: "${n3}"`);
      const i3 = Promise.resolve(n3);
      return i3[Symbol.toPrimitive] = () => (console.warn(`Deprecated: ${Qt.libName}.App.autoSession() return value used directly. It returns a promise now!`), n3), i3;
    }, autoPassword() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { key: "pw", default: "", force: false, scrub: false, keyless: false };
      "string" == typeof t3 && (t3 = { key: t3 });
      const e3 = t3.key || "pw", s3 = t3.scrub && !m.has("debug", "password"), n3 = t3.keyless, i3 = new URL(Qt.sessionURL);
      let o3 = "";
      const r2 = t3.force ? "" : i3.hash.slice(1);
      if (r2) {
        const t4 = r2.split("&"), a4 = t4.find((t5) => t5.split("=")[0] === e3);
        a4 ? (o3 = a4.replace(/[^=]*=/, ""), o3 && s3 && (i3.hash = t4.filter((t5) => t5.split("=")[0] !== e3).join("&"))) : n3 && (o3 = t4.find((t5) => !t5.includes("=")), o3 && s3 && (i3.hash = t4.filter((t5) => t5 !== o3).join("&")));
      }
      if (o3 || (o3 = t3.default ? t3.default : this.randomPassword(), i3.hash = r2 ? `${r2}&${e3}=${o3}` : n3 ? o3 : `${e3}=${o3}`, Qt.sessionURL = i3.href, s3 && (i3.hash = n3 ? "" : r2)), m.has("debug", "session") && console.log(`${Qt.libName}.App.sessionUrl: ${Qt.sessionURL}`), window.location.href !== i3.href) try {
        window.history.replaceState({}, "", i3.href);
      } catch (t4) {
        Qt.showMessage(`Setting address bar to ${i3.href}`, { only: "once" }), Qt.showMessage(`Failed to change address bar: ${t4.message}`, { level: "warning", only: "once" });
      }
      if (o3) try {
        o3 = decodeURIComponent(o3);
      } catch (t4) {
      }
      m.has("debug", "session") && console.log(`${Qt.libName}.App.autoPassword: "${o3}"`);
      const a3 = Promise.resolve(o3);
      return a3[Symbol.toPrimitive] = () => (console.warn(`Deprecated: ${Qt.libName}.App.autoPassword() return value used directly. It returns a promise now!`), o3), a3;
    }, randomSession() {
      return Et(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10);
    }, randomPassword() {
      return Et(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 16);
    } };
    var Ut = "#__vote";
    function Dt(t3, e3) {
      let s3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, n3 = "none";
      for (const i3 of ["immediate", "queued", "oncePerFrame", "oncePerFrameWhileSynced"]) for (const o3 of t3[i3]) o3.for === e3 ? null === s3 || o3.unbound === s3 ? t3[i3].delete(o3) : n3 = "subscriber" : "none" === n3 && (n3 = "others");
      return n3;
    }
    var Ot = globalThis.CROQUETVD = new class {
      constructor() {
        this.subscriptions = {}, this.subscribers = /* @__PURE__ */ new Map(), this.genericSubscriptions = false, this.queuedEvents = [], this.perFrameEvents = /* @__PURE__ */ new Map(), this.perSyncedFrameEvents = /* @__PURE__ */ new Map(), this.subscriberIds = 0, this.currentEvent = void 0, this.currentEventFromModel = false;
      }
      register(t3) {
        return "V" + ++this.subscriberIds;
      }
      deregister(t3) {
      }
      addSubscription(t3, e3, s3, n3, i3) {
        if (t3.includes(":")) throw Error(`Invalid subscription scope "${t3}" (must not contain ':')`);
        if ("vote" === i3) return void this.addSubscription(t3, e3 + Ut, s3, n3, "immediate");
        "*" !== t3 && "*" !== e3 || (this.genericSubscriptions = true);
        const o3 = t3 + ":" + e3, r2 = n3;
        r2.for = s3;
        let a3 = this.subscriptions[o3];
        if (a3 || (a3 = this.subscriptions[o3] = { immediate: /* @__PURE__ */ new Set(), queued: /* @__PURE__ */ new Set(), oncePerFrame: /* @__PURE__ */ new Set(), oncePerFrameWhileSynced: /* @__PURE__ */ new Set() }), !a3[i3]) throw Error(`Unknown subscribe() option: handling="${i3}"`);
        a3[i3].add(r2);
        let l3 = this.subscribers.get(s3);
        l3 || this.subscribers.set(s3, l3 = /* @__PURE__ */ new Set()), l3.add(o3);
      }
      removeSubscription(t3, e3, s3) {
        let n3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
        const i3 = t3 + ":" + e3, o3 = this.subscriptions[i3];
        if (o3) {
          const t4 = Dt(o3, s3, n3);
          if ("none" === t4 && delete this.subscriptions[i3], "subscriber" !== t4) {
            const t5 = this.subscribers.get(s3);
            t5 && (t5.delete(i3), 0 === t5.size && this.subscribers.delete(s3));
          }
        }
        e3.endsWith(Ut) || this.removeSubscription(t3, e3 + Ut, s3);
      }
      removeAllSubscriptionsFor(t3) {
        const e3 = this.subscribers.get(t3);
        if (e3) {
          for (const s3 of e3) {
            const e4 = this.subscriptions[s3];
            if (e4) {
              "none" === Dt(e4, t3) && delete this.subscriptions[s3];
            } else console.error(`${Qt.libName}: topic ${s3} not found in subscriptions table for ${t3} during removeAllSubscriptionsFor()`);
          }
          this.subscribers.delete(t3);
        }
      }
      subscriptionsFor(t3) {
        const e3 = this.subscriptions[t3];
        if (!e3 && !this.genericSubscriptions) return null;
        const s3 = [];
        let n3 = !!e3;
        if (this.genericSubscriptions) {
          const [e4, i3] = t3.split(":");
          if (!(e4.startsWith("__") && e4.endsWith("__") || i3.startsWith("__") && i3.endsWith("__"))) for (const t4 of ["*:*", e4 + ":*", "*:" + i3]) {
            const e5 = this.subscriptions[t4];
            e5 && (s3.push([e5, t4]), !n3 && this.hasUserSubcription(e5) && (n3 = true));
          }
          const o3 = !n3;
          if (o3) for (const t4 of s3) t4.push(o3);
        }
        return e3 && s3.push([e3, t3]), 0 === s3.length ? null : s3;
      }
      hasUserSubcription(t3) {
        for (const e3 of ["immediate", "queued", "oncePerFrame", "oncePerFrameWhileSynced"]) for (const s3 of t3[e3]) if (!s3.unbound.__CROQUET__) return true;
        return false;
      }
      handleEvent(t3, e3) {
        let s3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
        const n3 = this.subscriptionsFor(t3);
        if (!n3) return;
        const i3 = !!s3;
        let o3 = 0, r2 = 0, a3 = 0;
        for (const [l3, c2, d2] of n3) o3 += l3.queued.size, r2 += l3.oncePerFrame.size, a3 += l3.oncePerFrameWhileSynced.size, l3.immediate.size > 0 && (s3 || (s3 = (t4) => t4()), s3(() => {
          for (const s4 of l3.immediate) {
            const n4 = this.currentEvent, o4 = this.currentEventFromModel, r3 = this.currentEventOnlyGeneric;
            this.currentEvent = t3, this.currentEventFromModel = i3, this.currentEventOnlyGeneric = d2;
            try {
              s4(e3);
            } catch (t4) {
              console.error(t4), console.warn(`${Qt.libName}: error "${t4.message}" in "immediate" subscription ${c2}`);
            }
            this.currentEvent = n4, this.currentEventFromModel = o4, this.currentEventOnlyGeneric = r3;
          }
        }));
        o3 > 0 && this.queuedEvents.push({ topic: t3, data: e3, fromModel: i3 }), r2 > 0 && this.perFrameEvents.set(t3, { data: e3, fromModel: i3 }), a3 > 0 && this.perSyncedFrameEvents.set(t3, { data: e3, fromModel: i3 });
      }
      processFrameEvents(t3, e3) {
        let s3 = 0;
        const n3 = (t4, e4, n4, i3) => {
          const o3 = this.subscriptionsFor(e4);
          if (!o3) return;
          const r2 = this.currentEvent, a3 = this.currentEventFromModel;
          this.currentEvent = e4, this.currentEventFromModel = i3;
          for (const [i4, r3, a4] of o3) {
            const o4 = this.currentEventOnlyGeneric;
            this.currentEventOnlyGeneric = a4;
            for (const o5 of i4[t4]) {
              try {
                o5(n4);
              } catch (s4) {
                console.error(s4), console.warn(`${Qt.libName}: error "${s4.message}" in "${t4}" subscription ${e4}`);
              }
              s3++;
            }
            this.currentEventOnlyGeneric = o4;
          }
          this.currentEvent = r2, this.currentEventFromModel = a3;
        };
        for (const { topic: t4, data: e4, fromModel: s4 } of this.queuedEvents) n3("queued", t4, e4, s4);
        if (this.queuedEvents.length = 0, t3) {
          for (const [t4, { data: e4, fromModel: s4 }] of this.perFrameEvents) n3("oncePerFrame", t4, e4, s4);
          if (this.perFrameEvents.clear(), e3) {
            for (const [t4, { data: e4, fromModel: s4 }] of this.perSyncedFrameEvents) n3("oncePerFrameWhileSynced", t4, e4, s4);
            this.perSyncedFrameEvents.clear();
          }
          for (const { topic: t4, data: e4, fromModel: s4 } of this.queuedEvents) n3("queued", t4, e4, s4);
          this.queuedEvents.length = 0;
        }
        return s3;
      }
    }();
    var Bt = { get subscribe() {
      return Bt = { subscribe: m.has("debug", "subscribe", false) }, Bt.subscribe;
    } };
    var At = class _At {
      constructor(t3) {
        this.vm = t3;
      }
      register(t3) {
        return this.vm.registerModel(t3);
      }
      deregister(t3) {
        this.vm.deregisterModel(t3.id);
      }
      publish(t3, e3, s3) {
        this.vm.publishFromModel(s3, t3, e3);
      }
      subscribe(t3, e3, s3, n3) {
        return Bt.subscribe && console.log(`Model.subscribe("${e3}:${s3}", ${t3} ${("" + n3).replace(/\([\s\S]*/, "")})`), this.vm.addSubscription(t3, e3, s3, n3);
      }
      unsubscribe(t3, e3, s3) {
        let n3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "*";
        Bt.subscribe && console.log(`Model.unsubscribe(${e3}:${s3}", ${t3} ${("" + n3).replace(/\([\s\S]*/, "")})`), this.vm.removeSubscription(t3, e3, s3, n3);
      }
      unsubscribeAll(t3) {
        Bt.subscribe && console.log(`Model.unsubscribeAll(${t3} ${t3.id})`), this.vm.removeAllSubscriptionsFor(t3);
      }
      future(t3, e3, s3, n3) {
        if (qt && qt.equal(this)) return this.vm.future(t3, e3, s3, n3);
        throw Error(`Model.future() called from outside: ${t3}`);
      }
      cancelFuture(t3, e3) {
        if (qt && qt.equal(this)) return this.vm.cancelFuture(t3, e3);
        throw Error(`Model.cancelFuture() called from outside: ${t3}`);
      }
      random() {
        return this.vm.random();
      }
      now() {
        return this.vm.time;
      }
      equal(t3) {
        return t3 instanceof _At && t3.vm === this.vm;
      }
      isViewRealm() {
        return false;
      }
    };
    var $t = class _$t {
      constructor(t3) {
        this.vd = Ot, this.vm = t3, this.controller = t3.controller;
      }
      valid() {
        return this.vm === this.controller.vm;
      }
      register(t3) {
        return Ot.register(t3);
      }
      deregister(t3) {
        Ot.deregister(t3);
      }
      publish(t3, e3, s3) {
        this.vm.publishFromView(s3, t3, e3);
      }
      subscribe(t3, e3, s3, n3) {
        let i3 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "queued";
        Bt.subscribe && console.log(`View[${e3}].subscribe("${n3}:${t3}" ${s3 ? s3.name || ("" + s3).replace(/\([\s\S]*/, "") : "" + s3} [${i3}])`), Ot.addSubscription(n3, t3, e3, s3, i3);
      }
      unsubscribe(t3, e3) {
        let s3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, n3 = arguments.length > 3 ? arguments[3] : void 0;
        Bt.subscribe && console.log(`View[${e3}].unsubscribe("${n3}:${t3}" ${s3 ? s3.name || ("" + s3).replace(/\([\s\S]*/, "") : "*"})`), Ot.removeSubscription(n3, t3, e3, s3);
      }
      unsubscribeAll(t3) {
        Bt.subscribe && console.log(`View[${t3}].unsubscribeAll()`), Ot.removeAllSubscriptionsFor(t3);
      }
      future(t3, e3) {
        const s3 = this.vm;
        return new Proxy(t3, { get(n3, i3) {
          if ("function" == typeof t3[i3]) {
            return new Proxy(t3[i3], { apply(n4, o3, r2) {
              setTimeout(() => {
                t3.id && se(s3, () => t3[i3](...r2), true);
              }, e3);
            } });
          }
          throw Error("Tried to call " + i3 + "() on future of " + Object.getPrototypeOf(t3).constructor.name + " which is not a function");
        } });
      }
      random() {
        return Math.random();
      }
      now() {
        return this.vm.time;
      }
      externalNow() {
        return this.controller.reflectorTime;
      }
      extrapolatedNow() {
        return this.controller.extrapolatedTime;
      }
      isSynced() {
        return !!this.controller.synced;
      }
      equal(t3) {
        return t3 instanceof _$t && t3.vm === this.vm;
      }
      isViewRealm() {
        return true;
      }
    };
    var qt = null;
    function te() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "Tried to execute code that requires realm outside of realm.";
      if (!qt && t3) throw Error(t3);
      return qt;
    }
    function ee(t3, e3) {
      if (null !== qt) throw Error("Can't switch realms from inside realm");
      try {
        return qt = new At(t3), e3();
      } finally {
        qt = null;
      }
    }
    function se(t3, e3) {
      if (null !== qt && !(arguments.length > 2 && void 0 !== arguments[2] && arguments[2])) throw Error("Can't switch realms from inside realm");
      const s3 = qt;
      try {
        return qt = new $t(t3), e3();
      } finally {
        qt = s3;
      }
    }
    var ne = function(t3) {
      return t3 != t3;
    };
    var ie = Math.sqrt;
    var oe = 0.7853981633974483;
    var re = function(t3) {
      var e3, s3;
      return 0 === t3 ? 0.16666666666666713 : ((t3 < 0 ? -t3 : t3) <= 1 ? (e3 = t3 * (19.562619833175948 + t3 * (t3 * (5.444622390564711 + t3 * (0.004253011369004428 * t3 - 0.6019598008014124)) - 16.262479672107002)) - 8.198089802484825, s3 = t3 * (139.51056146574857 + t3 * (t3 * (70.49610280856842 + t3 * (1 * t3 - 14.740913729888538)) - 147.1791292232726)) - 49.18853881490881) : (e3 = 0.004253011369004428 + (t3 = 1 / t3) * (t3 * (5.444622390564711 + t3 * (t3 * (19.562619833175948 + -8.198089802484825 * t3) - 16.262479672107002)) - 0.6019598008014124), s3 = 1 + t3 * (t3 * (70.49610280856842 + t3 * (t3 * (139.51056146574857 + -49.18853881490881 * t3) - 147.1791292232726)) - 14.740913729888538)), e3 / s3);
    };
    var ae = function(t3) {
      var e3, s3;
      return 0 === t3 ? 0.08333333333333809 : ((t3 < 0 ? -t3 : t3) <= 1 ? (e3 = 28.536655482610616 + t3 * (t3 * (6.968710824104713 + t3 * (0.002967721961301243 * t3 - 0.5634242780008963)) - 25.56901049652825), s3 = 342.43986579130785 + t3 * (t3 * (147.0656354026815 + t3 * (1 * t3 - 21.947795316429207)) - 383.8770957603691)) : (e3 = 0.002967721961301243 + (t3 = 1 / t3) * (t3 * (6.968710824104713 + t3 * (28.536655482610616 * t3 - 25.56901049652825)) - 0.5634242780008963), s3 = 1 + t3 * (t3 * (147.0656354026815 + t3 * (342.43986579130785 * t3 - 383.8770957603691)) - 21.947795316429207)), e3 / s3);
    };
    var le = function(t3) {
      var e3, s3, n3, i3, o3;
      if (ne(t3)) return NaN;
      if (t3 > 0 ? n3 = t3 : (e3 = true, n3 = -t3), n3 > 1) return NaN;
      if (n3 > 0.625) i3 = (s3 = 1 - n3) * ae(s3), s3 = ie(s3 + s3), o3 = oe - s3, o3 -= s3 = s3 * i3 - 6123233995736766e-32, o3 += oe;
      else {
        if (n3 < 1e-8) return t3;
        o3 = n3 * (o3 = (s3 = n3 * n3) * re(s3)) + n3;
      }
      return e3 ? -o3 : o3;
    };
    var ce = function(t3) {
      var e3;
      return ne(t3) || t3 < -1 || t3 > 1 ? NaN : t3 > 0.5 ? 2 * le(ie(0.5 - 0.5 * t3)) : (e3 = oe - le(t3), e3 += 6123233995736766e-32, e3 += oe);
    };
    var de = function() {
      return "function" == typeof Symbol && "symbol" == typeof Symbol("foo");
    }();
    var he = function() {
      return de && "symbol" == typeof Symbol.toStringTag;
    };
    var ue = Object.prototype.toString;
    var me = function(t3) {
      return ue.call(t3);
    };
    var pe = Object.prototype.hasOwnProperty;
    var fe = function(t3, e3) {
      return null != t3 && pe.call(t3, e3);
    };
    var be = "function" == typeof Symbol ? Symbol.toStringTag : "";
    var ye = function(t3) {
      var e3, s3, n3;
      if (null == t3) return ue.call(t3);
      s3 = t3[be], e3 = fe(t3, be);
      try {
        t3[be] = void 0;
      } catch (e4) {
        return ue.call(t3);
      }
      return n3 = ue.call(t3), e3 ? t3[be] = s3 : delete t3[be], n3;
    };
    var ge = he() ? ye : me;
    var we = "function" == typeof Uint32Array;
    var Ze = function(t3) {
      return we && t3 instanceof Uint32Array || "[object Uint32Array]" === ge(t3);
    };
    var Xe = 4294967295;
    var ve = "function" == typeof Uint32Array ? Uint32Array : null;
    var Le = function() {
      var t3, e3;
      if ("function" != typeof ve) return false;
      try {
        e3 = new ve(e3 = [1, 3.14, -3.14, Xe + 1, Xe + 2]), t3 = Ze(e3) && 1 === e3[0] && 3 === e3[1] && e3[2] === Xe - 2 && 0 === e3[3] && 1 === e3[4];
      } catch (e4) {
        t3 = false;
      }
      return t3;
    };
    var xe = "function" == typeof Uint32Array ? Uint32Array : null;
    var Se = function() {
      throw new Error("not implemented");
    };
    var Ge = Le() ? xe : Se;
    var Te = "function" == typeof Float64Array;
    var We = function(t3) {
      return Te && t3 instanceof Float64Array || "[object Float64Array]" === ge(t3);
    };
    var Ce = "function" == typeof Float64Array ? Float64Array : null;
    var ke = function() {
      var t3, e3;
      if ("function" != typeof Ce) return false;
      try {
        e3 = new Ce([1, 3.14, -3.14, NaN]), t3 = We(e3) && 1 === e3[0] && 3.14 === e3[1] && -3.14 === e3[2] && e3[3] != e3[3];
      } catch (e4) {
        t3 = false;
      }
      return t3;
    };
    var Pe = "function" == typeof Float64Array ? Float64Array : null;
    var Ie = function() {
      throw new Error("not implemented");
    };
    var Re = ke() ? Pe : Ie;
    var Ve = "function" == typeof Uint8Array;
    var Ye = function(t3) {
      return Ve && t3 instanceof Uint8Array || "[object Uint8Array]" === ge(t3);
    };
    var Me = "function" == typeof Uint8Array ? Uint8Array : null;
    var He = function() {
      var t3, e3;
      if ("function" != typeof Me) return false;
      try {
        e3 = new Me(e3 = [1, 3.14, -3.14, 256, 257]), t3 = Ye(e3) && 1 === e3[0] && 3 === e3[1] && 253 === e3[2] && 0 === e3[3] && 1 === e3[4];
      } catch (e4) {
        t3 = false;
      }
      return t3;
    };
    var Ke = "function" == typeof Uint8Array ? Uint8Array : null;
    var Ne = function() {
      throw new Error("not implemented");
    };
    var ze = He() ? Ke : Ne;
    var _e = "function" == typeof Uint16Array;
    var Fe = function(t3) {
      return _e && t3 instanceof Uint16Array || "[object Uint16Array]" === ge(t3);
    };
    var Ee = "function" == typeof Uint16Array ? Uint16Array : null;
    var je = function() {
      var t3, e3;
      if ("function" != typeof Ee) return false;
      try {
        e3 = new Ee(e3 = [1, 3.14, -3.14, 65536, 65537]), t3 = Fe(e3) && 1 === e3[0] && 3 === e3[1] && 65533 === e3[2] && 0 === e3[3] && 1 === e3[4];
      } catch (e4) {
        t3 = false;
      }
      return t3;
    };
    var Je = "function" == typeof Uint16Array ? Uint16Array : null;
    var Qe;
    var Ue = function() {
      throw new Error("not implemented");
    };
    var De = { uint16: je() ? Je : Ue, uint8: ze };
    (Qe = new De.uint16(1))[0] = 4660;
    var Oe = 52 === new De.uint8(Qe.buffer)[0];
    var Be = true === Oe ? 1 : 0;
    var Ae = new Re(1);
    var $e = new Ge(Ae.buffer);
    var qe = function(t3) {
      return Ae[0] = t3, $e[Be];
    };
    var ts = true === Oe ? 1 : 0;
    var es = new Re(1);
    var ss = new Ge(es.buffer);
    var ns = function(t3, e3) {
      return es[0] = t3, ss[ts] = e3 >>> 0, es[0];
    };
    var is = ns;
    var os = Number.POSITIVE_INFINITY;
    var rs = Number.NEGATIVE_INFINITY;
    var as = 1023;
    var ls = function(t3) {
      return 0 === t3 ? 0.6666666666666735 : 0.6666666666666735 + t3 * (0.3999999999940942 + t3 * (0.2857142874366239 + t3 * (0.22222198432149784 + t3 * (0.1818357216161805 + t3 * (0.15313837699209373 + 0.14798198605116586 * t3)))));
    };
    var cs = 0.6931471803691238;
    var ds = 19082149292705877e-26;
    var hs = function(t3) {
      var e3, s3, n3, i3, o3, r2, a3, l3, c2, d2;
      if (t3 < -1 || ne(t3)) return NaN;
      if (-1 === t3) return rs;
      if (t3 === os) return t3;
      if (0 === t3) return t3;
      if (d2 = 1, (n3 = t3 < 0 ? -t3 : t3) < 0.41421356237309503) {
        if (n3 < 1862645149230957e-24) return n3 < 5551115123125783e-32 ? t3 : t3 - t3 * t3 * 0.5;
        t3 > -0.2928932188134525 && (d2 = 0, i3 = t3, s3 = 1);
      }
      return 0 !== d2 && (n3 < 9007199254740992 ? (o3 = (d2 = ((s3 = qe(c2 = 1 + t3)) >> 20) - as) > 0 ? 1 - (c2 - t3) : t3 - (c2 - 1), o3 /= c2) : (d2 = ((s3 = qe(c2 = t3)) >> 20) - as, o3 = 0), (s3 &= 1048575) < 434334 ? c2 = is(c2, 1072693248 | s3) : (d2 += 1, c2 = is(c2, 1071644672 | s3), s3 = 1048576 - s3 >> 2), i3 = c2 - 1), e3 = 0.5 * i3 * i3, 0 === s3 ? 0 === i3 ? d2 * cs + (o3 += d2 * ds) : d2 * cs - ((l3 = e3 * (1 - 0.6666666666666666 * i3)) - (d2 * ds + o3) - i3) : (l3 = (a3 = (r2 = i3 / (2 + i3)) * r2) * ls(a3), 0 === d2 ? i3 - (e3 - r2 * (e3 + l3)) : d2 * cs - (e3 - (r2 * (e3 + l3) + (d2 * ds + o3)) - i3));
    };
    var us = 0.6931471805599453;
    var ms = function(t3) {
      return 0 === t3 ? 0.3999999999940942 : 0.3999999999940942 + t3 * (0.22222198432149784 + 0.15313837699209373 * t3);
    };
    var ps = function(t3) {
      return 0 === t3 ? 0.6666666666666735 : 0.6666666666666735 + t3 * (0.2857142874366239 + t3 * (0.1818357216161805 + 0.14798198605116586 * t3));
    };
    var fs = 0.6931471803691238;
    var bs = 19082149292705877e-26;
    var ys = 1048575;
    var gs = function(t3) {
      var e3, s3, n3, i3, o3, r2, a3, l3, c2, d2, h2;
      return 0 === t3 ? rs : ne(t3) || t3 < 0 ? NaN : (i3 = 0, (s3 = qe(t3)) < 1048576 && (i3 -= 54, s3 = qe(t3 *= 18014398509481984)), s3 >= 2146435072 ? t3 + t3 : (i3 += (s3 >> 20) - as | 0, i3 += (a3 = (s3 &= ys) + 614244 & 1048576) >> 20, r2 = (t3 = is(t3, s3 | 1072693248 ^ a3)) - 1, (ys & 2 + s3) < 3 ? 0 === r2 ? 0 === i3 ? 0 : i3 * fs + i3 * bs : (o3 = r2 * r2 * (0.5 - 0.3333333333333333 * r2), 0 === i3 ? r2 - o3 : i3 * fs - (o3 - i3 * bs - r2)) : (a3 = s3 - 398458 | 0, l3 = 440401 - s3 | 0, n3 = (d2 = (h2 = (c2 = r2 / (2 + r2)) * c2) * h2) * ms(d2), o3 = h2 * ps(d2) + n3, (a3 |= l3) > 0 ? (e3 = 0.5 * r2 * r2, 0 === i3 ? r2 - (e3 - c2 * (e3 + o3)) : i3 * fs - (e3 - (c2 * (e3 + o3) + i3 * bs) - r2)) : 0 === i3 ? r2 - c2 * (r2 - o3) : i3 * fs - (c2 * (r2 - o3) - i3 * bs - r2))));
    };
    var ws = function(t3) {
      var e3;
      return ne(t3) || t3 < 1 ? NaN : 1 === t3 ? 0 : t3 >= 268435456 ? gs(t3) + us : t3 > 2 ? gs(2 * t3 - 1 / (t3 + ie(t3 * t3 - 1))) : hs((e3 = t3 - 1) + ie(2 * e3 + e3 * e3));
    };
    var Zs = function(t3) {
      return t3 === os || t3 === rs;
    };
    var Xs = 1 / (1 << 28);
    var vs = function(t3) {
      var e3, s3, n3;
      return ne(t3) || Zs(t3) ? t3 : (t3 < 0 && (t3 = -t3, e3 = true), n3 = t3 < Xs ? t3 : t3 > 268435456 ? gs(t3) + us : t3 > 2 ? gs(2 * t3 + 1 / (ie(t3 * t3 + 1) + t3)) : hs(t3 + (s3 = t3 * t3) / (1 + ie(1 + s3))), e3 ? -n3 : n3);
    };
    var Ls = 1.5707963267948966;
    var xs = function(t3) {
      return 0 === t3 ? -64.85021904942025 : t3 * (t3 * (t3 * (-0.8750608600031904 * t3 - 16.157537187333652) - 75.00855792314705) - 122.88666844901361) - 64.85021904942025;
    };
    var Ss = function(t3) {
      return 0 === t3 ? 194.5506571482614 : 194.5506571482614 + t3 * (485.3903996359137 + t3 * (432.88106049129027 + t3 * (165.02700983169885 + t3 * (24.858464901423062 + 1 * t3))));
    };
    var Gs = 6123233995736766e-32;
    var Ts = function(t3) {
      var e3, s3, n3, i3;
      return ne(t3) || 0 === t3 ? t3 : t3 === os ? Ls : t3 === rs ? -1.5707963267948966 : (t3 < 0 && (s3 = true, t3 = -t3), e3 = 0, t3 > 2.414213562373095 ? (n3 = Ls, e3 = 1, t3 = -1 / t3) : t3 <= 0.66 ? n3 = 0 : (n3 = oe, e3 = 2, t3 = (t3 - 1) / (t3 + 1)), i3 = t3 * (i3 = (i3 = t3 * t3) * xs(i3) / Ss(i3)) + t3, 2 === e3 ? i3 += 0.5 * Gs : 1 === e3 && (i3 += Gs), n3 += i3, s3 ? -n3 : n3);
    };
    var Ws = 1 / (1 << 28);
    var Cs;
    var ks;
    var Ps = function(t3) {
      var e3, s3;
      return ne(t3) || t3 < -1 || t3 > 1 ? NaN : 1 === t3 ? os : -1 === t3 ? rs : (t3 < 0 && (e3 = true, t3 = -t3), t3 < Ws ? e3 ? -t3 : t3 : (s3 = t3 < 0.5 ? 0.5 * hs((s3 = t3 + t3) + s3 * t3 / (1 - t3)) : 0.5 * hs((t3 + t3) / (1 - t3)), e3 ? -s3 : s3));
    };
    true === Oe ? (Cs = 1, ks = 0) : (Cs = 0, ks = 1);
    var Is = { HIGH: Cs, LOW: ks };
    var Rs = new Re(1);
    var Vs = new Ge(Rs.buffer);
    var Ys = Is.HIGH;
    var Ms = Is.LOW;
    var Hs = function(t3, e3) {
      return Rs[0] = e3, t3[0] = Vs[Ys], t3[1] = Vs[Ms], t3;
    };
    var Ks;
    var Ns;
    var zs = function(t3, e3) {
      return 1 === arguments.length ? Hs([0, 0], t3) : Hs(t3, e3);
    };
    true === Oe ? (Ks = 1, Ns = 0) : (Ks = 0, Ns = 1);
    var _s = { HIGH: Ks, LOW: Ns };
    var Fs = new Re(1);
    var Es = new Ge(Fs.buffer);
    var js = _s.HIGH;
    var Js = _s.LOW;
    var Qs = function(t3, e3) {
      return Es[js] = t3, Es[Js] = e3, Fs[0];
    };
    var Us = Qs;
    var Ds = [0, 0];
    var Os = function(t3, e3) {
      var s3, n3;
      return zs(Ds, t3), s3 = Ds[0], s3 &= 2147483647, n3 = qe(e3), Us(s3 |= n3 &= 2147483648, Ds[1]);
    };
    var Bs = function(t3) {
      return !!(qe(t3) >>> 31);
    };
    var As = 3.141592653589793;
    var $s = function(t3, e3) {
      var s3;
      return ne(e3) || ne(t3) ? NaN : Zs(e3) ? e3 === os ? Zs(t3) ? Os(As / 4, t3) : Os(0, t3) : Zs(t3) ? Os(3 * As / 4, t3) : Os(As, t3) : Zs(t3) ? Os(As / 2, t3) : 0 === t3 ? e3 >= 0 && !Bs(e3) ? Os(0, t3) : Os(As, t3) : 0 === e3 ? Os(As / 2, t3) : (s3 = Ts(t3 / e3), e3 < 0 ? s3 <= 0 ? s3 + As : s3 - As : s3);
    };
    var qs = 22250738585072014e-324;
    var tn = function(t3) {
      return 0 === t3 ? 1.87595182427177 : 1.87595182427177 + t3 * (t3 * (1.6214297201053545 + t3 * (0.14599619288661245 * t3 - 0.758397934778766)) - 1.8849797954337717);
    };
    var en = 2147483647;
    var sn = function(t3) {
      var e3, s3, n3, i3, o3;
      return ne(t3) || Zs(t3) || 0 === t3 ? t3 : (s3 = -2147483648 & (n3 = qe(t3)), n3 &= en, o3 = 0, t3 < qs ? (o3 = 18014398509481984, e3 = qe(o3 *= t3), o3 = Us(s3 | (e3 = (e3 & en) / 3 + 696219795), 0)) : o3 = is(o3, s3 | (e3 = n3 / 3 + 715094163)), o3 *= tn(i3 = o3 * o3 * (o3 / t3)), e3 = qe(o3), o3 = Us(e3 + 1, 0), o3 += o3 * (i3 = ((i3 = t3 / (o3 * o3)) - o3) / (o3 + o3 + i3)));
    };
    var nn = sn;
    var on = function(t3) {
      return 0 === t3 ? 0.0416666666666666 : 0.0416666666666666 + t3 * (2480158728947673e-20 * t3 - 0.001388888888887411);
    };
    var rn = function(t3) {
      return 0 === t3 ? -27557314351390663e-23 : t3 * (2087572321298175e-24 + -11359647557788195e-27 * t3) - 27557314351390663e-23;
    };
    var an = function(t3, e3) {
      var s3, n3, i3, o3;
      return i3 = (o3 = t3 * t3) * o3, n3 = o3 * on(o3), n3 += i3 * i3 * rn(o3), (i3 = 1 - (s3 = 0.5 * o3)) + (1 - i3 - s3 + (o3 * n3 - t3 * e3));
    };
    var ln = -0.16666666666666632;
    var cn = function(t3, e3) {
      var s3, n3, i3;
      return s3 = 0.00833333333332249 + (i3 = t3 * t3) * (27557313707070068e-22 * i3 - 1984126982985795e-19) + i3 * (i3 * i3) * (158969099521155e-24 * i3 - 25050760253406863e-24), n3 = i3 * t3, 0 === e3 ? t3 + n3 * (ln + i3 * s3) : t3 - (i3 * (0.5 * e3 - n3 * s3) - e3 - n3 * ln);
    };
    var dn = true === Oe ? 0 : 1;
    var hn = new Re(1);
    var un = new Ge(hn.buffer);
    var mn = function(t3) {
      return hn[0] = t3, un[dn];
    };
    var pn = Math.floor;
    var fn = function(t3) {
      return t3 < 0 ? -t3 : 0 === t3 ? 0 : t3;
    };
    var bn = function(t3, e3) {
      return ne(e3) || Zs(e3) ? (t3[0] = e3, t3[1] = 0, t3) : 0 !== e3 && fn(e3) < qs ? (t3[0] = 4503599627370496 * e3, t3[1] = -52, t3) : (t3[0] = e3, t3[1] = 0, t3);
    };
    var yn = function(t3, e3) {
      return 1 === arguments.length ? bn([0, 0], t3) : bn(t3, e3);
    };
    var gn = function(t3) {
      var e3 = qe(t3);
      return (e3 = (2146435072 & e3) >>> 20) - as | 0;
    };
    var wn = gn;
    var Zn = [0, 0];
    var Xn = [0, 0];
    var vn = function(t3, e3) {
      var s3, n3;
      return 0 === t3 || ne(t3) || Zs(t3) ? t3 : (yn(Zn, t3), e3 += Zn[1], (e3 += wn(t3 = Zn[0])) < -1074 ? Os(0, t3) : e3 > 1023 ? t3 < 0 ? rs : os : (e3 <= -1023 ? (e3 += 52, n3 = 2220446049250313e-31) : n3 = 1, zs(Xn, t3), s3 = Xn[0], s3 &= 2148532223, n3 * Us(s3 |= e3 + as << 20, Xn[1])));
    };
    var Ln = vn;
    var xn = [10680707, 7228996, 1387004, 2578385, 16069853, 12639074, 9804092, 4427841, 16666979, 11263675, 12935607, 2387514, 4345298, 14681673, 3074569, 13734428, 16653803, 1880361, 10960616, 8533493, 3062596, 8710556, 7349940, 6258241, 3772886, 3769171, 3798172, 8675211, 12450088, 3874808, 9961438, 366607, 15675153, 9132554, 7151469, 3571407, 2607881, 12013382, 4155038, 6285869, 7677882, 13102053, 15825725, 473591, 9065106, 15363067, 6271263, 9264392, 5636912, 4652155, 7056368, 13614112, 10155062, 1944035, 9527646, 15080200, 6658437, 6231200, 6832269, 16767104, 5075751, 3212806, 1398474, 7579849, 6349435, 12618859];
    var Sn = [1.570796251296997, 7549789415861596e-23, 5390302529957765e-30, 3282003415807913e-37, 1270655753080676e-44, 12293330898111133e-52, 27337005381646456e-60, 21674168387780482e-67];
    var Gn = 16777216;
    var Tn = 5960464477539063e-23;
    var Wn = In(new Array(20));
    var Cn = In(new Array(20));
    var kn = In(new Array(20));
    var Pn = In(new Array(20));
    function In(t3) {
      var e3, s3 = t3.length;
      for (e3 = 0; e3 < s3; e3++) t3[e3] = 0;
      return t3;
    }
    function Rn(t3, e3, s3, n3, i3, o3, r2, a3, l3) {
      var c2, d2, h2, u2, m2, p2, f2, b2, y2;
      for (u2 = o3, y2 = n3[s3], b2 = s3, m2 = 0; b2 > 0; m2++) d2 = Tn * y2 | 0, Pn[m2] = y2 - Gn * d2 | 0, y2 = n3[b2 - 1] + d2, b2 -= 1;
      if (y2 = Ln(y2, i3), y2 -= 8 * pn(0.125 * y2), y2 -= f2 = 0 | y2, h2 = 0, i3 > 0 ? (f2 += m2 = Pn[s3 - 1] >> 24 - i3, Pn[s3 - 1] -= m2 << 24 - i3, h2 = Pn[s3 - 1] >> 23 - i3) : 0 === i3 ? h2 = Pn[s3 - 1] >> 23 : y2 >= 0.5 && (h2 = 2), h2 > 0) {
        for (f2 += 1, c2 = 0, m2 = 0; m2 < s3; m2++) b2 = Pn[m2], 0 === c2 ? 0 !== b2 && (c2 = 1, Pn[m2] = 16777216 - b2) : Pn[m2] = 16777215 - b2;
        if (i3 > 0) switch (i3) {
          case 1:
            Pn[s3 - 1] &= 8388607;
            break;
          case 2:
            Pn[s3 - 1] &= 4194303;
        }
        2 === h2 && (y2 = 1 - y2, 0 !== c2 && (y2 -= Ln(1, i3)));
      }
      if (0 === y2) {
        for (b2 = 0, m2 = s3 - 1; m2 >= o3; m2--) b2 |= Pn[m2];
        if (0 === b2) {
          for (p2 = 1; 0 === Pn[o3 - p2]; p2++) ;
          for (m2 = s3 + 1; m2 <= s3 + p2; m2++) {
            for (l3[a3 + m2] = xn[r2 + m2], d2 = 0, b2 = 0; b2 <= a3; b2++) d2 += t3[b2] * l3[a3 + (m2 - b2)];
            n3[m2] = d2;
          }
          return Rn(t3, e3, s3 += p2, n3, i3, o3, r2, a3, l3);
        }
      }
      if (0 === y2) for (s3 -= 1, i3 -= 24; 0 === Pn[s3]; ) s3 -= 1, i3 -= 24;
      else (y2 = Ln(y2, -i3)) >= Gn ? (d2 = Tn * y2 | 0, Pn[s3] = y2 - Gn * d2 | 0, i3 += 24, Pn[s3 += 1] = d2) : Pn[s3] = 0 | y2;
      for (d2 = Ln(1, i3), m2 = s3; m2 >= 0; m2--) n3[m2] = d2 * Pn[m2], d2 *= Tn;
      for (m2 = s3; m2 >= 0; m2--) {
        for (d2 = 0, p2 = 0; p2 <= u2 && p2 <= s3 - m2; p2++) d2 += Sn[p2] * n3[m2 + p2];
        kn[s3 - m2] = d2;
      }
      for (d2 = 0, m2 = s3; m2 >= 0; m2--) d2 += kn[m2];
      for (e3[0] = 0 === h2 ? d2 : -d2, d2 = kn[0] - d2, m2 = 1; m2 <= s3; m2++) d2 += kn[m2];
      return e3[1] = 0 === h2 ? d2 : -d2, 7 & f2;
    }
    var Vn = function(t3, e3, s3, n3) {
      var i3, o3, r2, a3, l3, c2, d2;
      for ((o3 = (s3 - 3) / 24 | 0) < 0 && (o3 = 0), a3 = s3 - 24 * (o3 + 1), c2 = o3 - (r2 = n3 - 1), d2 = r2 + 4, l3 = 0; l3 <= d2; l3++) Wn[l3] = c2 < 0 ? 0 : xn[c2], c2 += 1;
      for (l3 = 0; l3 <= 4; l3++) {
        for (i3 = 0, c2 = 0; c2 <= r2; c2++) i3 += t3[c2] * Wn[r2 + (l3 - c2)];
        Cn[l3] = i3;
      }
      return Rn(t3, e3, 4, Cn, a3, 4, o3, r2, Wn);
    };
    var Yn = Math.round;
    var Mn = function(t3, e3, s3) {
      var n3, i3, o3, r2, a3;
      return o3 = t3 - 1.5707963267341256 * (n3 = Yn(0.6366197723675814 * t3)), r2 = 6077100506506192e-26 * n3, a3 = e3 >> 20, s3[0] = o3 - r2, a3 - (qe(s3[0]) >> 20 & 2047) > 16 && (r2 = 20222662487959506e-37 * n3 - ((i3 = o3) - (o3 = i3 - (r2 = 6077100506303966e-26 * n3)) - r2), s3[0] = o3 - r2, a3 - (qe(s3[0]) >> 20 & 2047) > 49 && (r2 = 84784276603689e-45 * n3 - ((i3 = o3) - (o3 = i3 - (r2 = 20222662487111665e-37 * n3)) - r2), s3[0] = o3 - r2)), s3[1] = o3 - s3[0] - r2, n3;
    };
    var Hn = 1.5707963267341256;
    var Kn = 6077100506506192e-26;
    var Nn = 2 * Kn;
    var zn = 3 * Kn;
    var _n = 4 * Kn;
    var Fn = new Array(3);
    var En = new Array(2);
    var jn = function(t3, e3) {
      var s3, n3, i3, o3, r2, a3, l3;
      if ((i3 = 2147483647 & qe(t3)) <= 1072243195) return e3[0] = t3, e3[1] = 0, 0;
      if (i3 <= 1074752122) return 598523 == (1048575 & i3) ? Mn(t3, i3, e3) : i3 <= 1073928572 ? t3 > 0 ? (l3 = t3 - Hn, e3[0] = l3 - Kn, e3[1] = l3 - e3[0] - Kn, 1) : (l3 = t3 + Hn, e3[0] = l3 + Kn, e3[1] = l3 - e3[0] + Kn, -1) : t3 > 0 ? (l3 = t3 - 2 * Hn, e3[0] = l3 - Nn, e3[1] = l3 - e3[0] - Nn, 2) : (l3 = t3 + 2 * Hn, e3[0] = l3 + Nn, e3[1] = l3 - e3[0] + Nn, -2);
      if (i3 <= 1075594811) return i3 <= 1075183036 ? 1074977148 === i3 ? Mn(t3, i3, e3) : t3 > 0 ? (l3 = t3 - 3 * Hn, e3[0] = l3 - zn, e3[1] = l3 - e3[0] - zn, 3) : (l3 = t3 + 3 * Hn, e3[0] = l3 + zn, e3[1] = l3 - e3[0] + zn, -3) : 1075388923 === i3 ? Mn(t3, i3, e3) : t3 > 0 ? (l3 = t3 - 4 * Hn, e3[0] = l3 - _n, e3[1] = l3 - e3[0] - _n, 4) : (l3 = t3 + 4 * Hn, e3[0] = l3 + _n, e3[1] = l3 - e3[0] + _n, -4);
      if (i3 < 1094263291) return Mn(t3, i3, e3);
      if (i3 >= 2146435072) return e3[0] = NaN, e3[1] = NaN, 0;
      for (s3 = mn(t3), l3 = Us(i3 - ((n3 = (i3 >> 20) - 1046) << 20), s3), r2 = 0; r2 < 2; r2++) Fn[r2] = 0 | l3, l3 = 16777216 * (l3 - Fn[r2]);
      for (Fn[2] = l3, o3 = 3; 0 === Fn[o3 - 1]; ) o3 -= 1;
      return a3 = Vn(Fn, En, n3, o3), t3 < 0 ? (e3[0] = -En[0], e3[1] = -En[1], -a3) : (e3[0] = En[0], e3[1] = En[1], a3);
    };
    var Jn = jn;
    var Qn = [0, 0];
    var Un = function(t3) {
      var e3;
      if (e3 = qe(t3), (e3 &= 2147483647) <= 1072243195) return e3 < 1044381696 ? 1 : an(t3, 0);
      if (e3 >= 2146435072) return NaN;
      switch (3 & Jn(t3, Qn)) {
        case 0:
          return an(Qn[0], Qn[1]);
        case 1:
          return -cn(Qn[0], Qn[1]);
        case 2:
          return -an(Qn[0], Qn[1]);
        default:
          return cn(Qn[0], Qn[1]);
      }
    };
    var Dn = Math.ceil;
    var On = function(t3) {
      return t3 < 0 ? Dn(t3) : pn(t3);
    };
    var Bn = function(t3) {
      return 0 === t3 ? 0.16666666666666602 : 0.16666666666666602 + t3 * (t3 * (6613756321437934e-20 + t3 * (41381367970572385e-24 * t3 - 16533902205465252e-22)) - 0.0027777777777015593);
    };
    var An = function(t3, e3, s3) {
      var n3, i3, o3;
      return o3 = (n3 = t3 - e3) - (i3 = n3 * n3) * Bn(i3), Ln(1 - (e3 - n3 * o3 / (2 - o3) - t3), s3);
    };
    var $n = 1.4426950408889634;
    var qn = 1 / (1 << 28);
    var ti = function(t3) {
      var e3;
      return ne(t3) || t3 === os ? t3 : t3 === rs ? 0 : t3 > 709.782712893384 ? os : t3 < -745.1332191019411 ? 0 : t3 > -3725290298461914e-24 && t3 < qn ? 1 + t3 : (e3 = On(t3 < 0 ? $n * t3 - 0.5 : $n * t3 + 0.5), An(t3 - 0.6931471803691238 * e3, 19082149292705877e-26 * e3, e3));
    };
    var ei = function(t3) {
      return ne(t3) ? t3 : (t3 < 0 && (t3 = -t3), t3 > 21 ? ti(t3) / 2 : (ti(t3) + ti(-t3)) / 2);
    };
    var si = function(t3) {
      return 0 === t3 ? -0.03333333333333313 : t3 * (0.0015873015872548146 + t3 * (t3 * (4008217827329362e-21 + -20109921818362437e-23 * t3) - 793650757867488e-19)) - 0.03333333333333313;
    };
    var ni = 0.6931471803691238;
    var ii = 19082149292705877e-26;
    var oi = 1.4426950408889634;
    var ri = function(t3) {
      var e3, s3, n3, i3, o3, r2, a3, l3, c2, d2, h2, u2;
      if (t3 === os || ne(t3)) return t3;
      if (t3 === rs) return -1;
      if (0 === t3) return t3;
      if (t3 < 0 ? (s3 = true, a3 = -t3) : (s3 = false, a3 = t3), a3 >= 38.816242111356935) {
        if (s3) return -1;
        if (a3 >= 709.782712893384) return os;
      }
      if (o3 = 0 | qe(a3), a3 > 0.34657359027997264) a3 < 1.0397207708399179 ? s3 ? (n3 = t3 + ni, i3 = -19082149292705877e-26, u2 = -1) : (n3 = t3 - ni, i3 = ii, u2 = 1) : (u2 = s3 ? oi * t3 - 0.5 : oi * t3 + 0.5, n3 = t3 - (d2 = u2 |= 0) * ni, i3 = d2 * ii), c2 = n3 - (t3 = n3 - i3) - i3;
      else {
        if (o3 < 1016070144) return t3;
        u2 = 0;
      }
      return h2 = (l3 = t3 * (e3 = 0.5 * t3)) * (((r2 = 1 + l3 * si(l3)) - (d2 = 3 - r2 * e3)) / (6 - t3 * d2)), 0 === u2 ? t3 - (t3 * h2 - l3) : (h2 = t3 * (h2 - c2) - c2, h2 -= l3, -1 === u2 ? 0.5 * (t3 - h2) - 0.5 : 1 === u2 ? t3 < -0.25 ? -2 * (h2 - (t3 + 0.5)) : 1 + 2 * (t3 - h2) : u2 <= -2 || u2 > 56 ? (n3 = qe(a3 = 1 - (h2 - t3)) + (u2 << 20) | 0, (a3 = is(a3, n3)) - 1) : (d2 = 1, u2 < 20 ? a3 = (d2 = is(d2, n3 = 1072693248 - (2097152 >> u2) | 0)) - (h2 - t3) : (a3 = t3 - (h2 + (d2 = is(d2, n3 = as - u2 << 20))), a3 += 1), n3 = qe(a3) + (u2 << 20) | 0, is(a3, n3)));
    };
    var ai = true === Oe ? 0 : 1;
    var li = new Re(1);
    var ci = new Ge(li.buffer);
    var di = function(t3, e3) {
      return li[0] = t3, ci[ai] = e3 >>> 0, li[0];
    };
    var hi = di;
    var ui = function(t3) {
      return 0 === t3 ? 0.3999999999940942 : 0.3999999999940942 + t3 * (0.22222198432149784 + 0.15313837699209373 * t3);
    };
    var mi = function(t3) {
      return 0 === t3 ? 0.6666666666666735 : 0.6666666666666735 + t3 * (0.2857142874366239 + t3 * (0.1818357216161805 + 0.14798198605116586 * t3));
    };
    var pi = 1048575;
    var fi = function(t3) {
      var e3, s3, n3, i3, o3, r2, a3, l3, c2, d2;
      return n3 = qe(t3), i3 = t3 - 1, (pi & 2 + n3) < 3 ? 0 === i3 ? 0 : i3 * i3 * (0.3333333333333333 * i3 - 0.5) : (c2 = (n3 &= pi) - 398458 | 0, d2 = 440401 - n3 | 0, s3 = (l3 = (r2 = (o3 = i3 / (2 + i3)) * o3) * r2) * ui(l3), a3 = r2 * mi(l3) + s3, (c2 |= d2) > 0 ? o3 * ((e3 = 0.5 * i3 * i3) + a3) - e3 : o3 * (a3 - i3));
    };
    var bi = 0.4342944818781689;
    var yi = function(t3) {
      var e3, s3, n3, i3, o3, r2, a3;
      return ne(t3) || t3 < 0 ? NaN : 0 === t3 ? rs : (o3 = 0, (s3 = qe(t3)) < 1048576 && (o3 -= 54, s3 = qe(t3 *= 18014398509481984)), s3 >= 2146435072 ? t3 + t3 : (o3 += (s3 >> 20) - as | 0, t3 = is(t3, (s3 &= 1048575) | 1072693248 ^ (i3 = s3 + 614244 & 1048576)), r2 = o3 += i3 >> 20, n3 = fi(t3), a3 = 3694239077158931e-28 * r2 + 25082946711645275e-27 * ((t3 -= 1) + n3), (a3 += (t3 - (e3 = hi(t3, 0)) + n3) * bi + e3 * bi) + 0.30102999566361177 * r2));
    };
    var gi = function(t3) {
      return 0 === t3 ? 0.3999999999940942 : 0.3999999999940942 + t3 * (0.22222198432149784 + 0.15313837699209373 * t3);
    };
    var wi = function(t3) {
      return 0 === t3 ? 0.6666666666666735 : 0.6666666666666735 + t3 * (0.2857142874366239 + t3 * (0.1818357216161805 + 0.14798198605116586 * t3));
    };
    var Zi = 1048575;
    var Xi = function(t3) {
      var e3, s3, n3, i3, o3, r2, a3, l3, c2, d2;
      return n3 = qe(t3), i3 = t3 - 1, (Zi & 2 + n3) < 3 ? 0 === i3 ? 0 : i3 * i3 * (0.3333333333333333 * i3 - 0.5) : (c2 = (n3 &= Zi) - 398458 | 0, d2 = 440401 - n3 | 0, s3 = (l3 = (r2 = (o3 = i3 / (2 + i3)) * o3) * r2) * gi(l3), a3 = r2 * wi(l3) + s3, (c2 |= d2) > 0 ? o3 * ((e3 = 0.5 * i3 * i3) + a3) - e3 : o3 * (a3 - i3));
    };
    var vi = 1.4426950407214463;
    var Li = [0, 0];
    var xi = function(t3) {
      var e3, s3, n3, i3, o3;
      if (ne(t3) || t3 < 0) return NaN;
      if (zs(Li, t3), o3 = 0, (s3 = Li[0]) < 1048576) {
        if (!(2147483647 & s3 | Li[1])) return rs;
        o3 -= 54, s3 = qe(t3 *= 18014398509481984);
      }
      return s3 >= 2146435072 ? t3 + t3 : (o3 += (s3 >> 20) - as | 0, t3 = is(t3, (s3 &= 1048575) | 1072693248 ^ (i3 = s3 + 614244 & 1048576)), o3 += i3 >> 20, n3 = Xi(t3), 16751713164886512e-26 * ((t3 -= 1) + n3) + (t3 - (e3 = hi(t3, 0)) + n3) * vi + e3 * vi + o3);
    };
    var Si = [0, 0];
    var Gi = function(t3) {
      var e3;
      if (e3 = qe(t3), (e3 &= 2147483647) <= 1072243195) return e3 < 1045430272 ? t3 : cn(t3, 0);
      if (e3 >= 2146435072) return NaN;
      switch (3 & Jn(t3, Si)) {
        case 0:
          return cn(Si[0], Si[1]);
        case 1:
          return an(Si[0], Si[1]);
        case 2:
          return -cn(Si[0], Si[1]);
        default:
          return -an(Si[0], Si[1]);
      }
    };
    var Ti = function(t3) {
      var e3, s3;
      return 0 === t3 ? 0.16666666666666666 : ((t3 < 0 ? -t3 : t3) <= 1 ? (e3 = t3 * (t3 * (-0.789474443963537 * t3 - 163.72585752598383) - 11561.443576500522) - 351754.9648081514, s3 = t3 * (36157.827983443196 + t3 * (1 * t3 - 277.7110814206028)) - 2.1105297888489086e6) : (e3 = (t3 = 1 / t3) * (t3 * (-351754.9648081514 * t3 - 11561.443576500522) - 163.72585752598383) - 0.789474443963537, s3 = 1 + t3 * (t3 * (36157.827983443196 + -2.1105297888489086e6 * t3) - 277.7110814206028)), e3 / s3);
    };
    var Wi = 709.782712893384;
    var Ci = Wi + us;
    var ki = Wi - us;
    var Pi = function(t3) {
      var e3;
      return 0 === t3 ? t3 : (e3 = fn(t3), t3 > Ci || t3 < -709.089565712824 ? t3 > 0 ? os : rs : e3 > 1 ? e3 >= ki ? (e3 = ti(0.5 * e3), e3 *= 0.5 * e3, t3 < 0 && (e3 = -e3), e3) : (e3 = 0.5 * (e3 = ti(e3)) - 0.5 / e3, t3 < 0 && (e3 = -e3), e3) : t3 + t3 * (e3 *= e3) * Ti(e3));
    };
    var Ii = function(t3) {
      return 0 === t3 ? 0.13333333333320124 : 0.13333333333320124 + t3 * (0.021869488294859542 + t3 * (0.0035920791075913124 + t3 * (5880412408202641e-19 + t3 * (7817944429395571e-20 + -18558637485527546e-21 * t3))));
    };
    var Ri = function(t3) {
      return 0 === t3 ? 0.05396825397622605 : 0.05396825397622605 + t3 * (0.0088632398235993 + t3 * (0.0014562094543252903 + t3 * (2464631348184699e-19 + t3 * (7140724913826082e-20 + 2590730518636337e-20 * t3))));
    };
    var Vi = function(t3, e3, s3) {
      var n3, i3, o3, r2, a3, l3, c2, d2, h2;
      return (i3 = 2147483647 & (n3 = qe(t3))) >= 1072010280 && (t3 < 0 && (t3 = -t3, e3 = -e3), t3 = (h2 = 0.7853981633974483 - t3) + (d2 = 3061616997868383e-32 - e3), e3 = 0), r2 = e3 + (h2 = t3 * t3) * ((a3 = h2 * t3) * ((r2 = Ii(d2 = h2 * h2)) + (c2 = h2 * Ri(d2))) + e3), d2 = t3 + (r2 += 0.3333333333333341 * a3), i3 >= 1072010280 ? (1 - (n3 >> 30 & 2)) * ((c2 = s3) - 2 * (t3 - (d2 * d2 / (d2 + c2) - r2))) : 1 === s3 ? d2 : (hi(h2 = d2, 0), c2 = r2 - (h2 - t3), hi(l3 = o3 = -1 / d2, 0), l3 + o3 * ((a3 = 1 + l3 * h2) + l3 * c2));
    };
    var Yi = [0, 0];
    var Mi = function(t3) {
      var e3, s3;
      return e3 = qe(t3), (e3 &= 2147483647) <= 1072243195 ? e3 < 1044381696 ? t3 : Vi(t3, 0, 1) : e3 >= 2146435072 ? NaN : (s3 = Jn(t3, Yi), Vi(Yi[0], Yi[1], 1 - ((1 & s3) << 1)));
    };
    var Hi = function(t3) {
      var e3, s3;
      return 0 === t3 ? -0.3333333333333332 : ((t3 < 0 ? -t3 : t3) <= 1 ? (e3 = t3 * (t3 * (0 * t3 - 0.9643991794250523) - 99.28772310019185) - 1614.6876844170845, s3 = 4844.063053251255 + t3 * (2235.4883906010045 + t3 * (112.81167849163293 + 1 * t3))) : (e3 = 0 + (t3 = 1 / t3) * (t3 * (-1614.6876844170845 * t3 - 99.28772310019185) - 0.9643991794250523), s3 = 1 + t3 * (112.81167849163293 + t3 * (2235.4883906010045 + 4844.063053251255 * t3))), e3 / s3);
    };
    var Ki = function(t3) {
      var e3, s3;
      if ((s3 = fn(t3)) > 44.014845965556525) return t3 < 0 ? -1 : 1;
      if (s3 >= 0.625) s3 = 1 - 2 / ((e3 = ti(2 * s3)) + 1), t3 < 0 && (s3 = -s3);
      else {
        if (0 === t3) return t3;
        s3 = t3 + t3 * (e3 = t3 * t3) * Hi(e3);
      }
      return s3;
    };
    void 0 === globalThis.CroquetMath && (globalThis.CroquetMath = {}), Object.assign(globalThis.CroquetMath, { acos: ce, acosh: ws, asin: le, asinh: vs, atan: Ts, atanh: Ps, atan2: $s, cbrt: nn, cos: Un, cosh: ei, exp: ti, expm1: ri, log: gs, log1p: hs, log10: yi, log2: xi, sin: Gi, sinh: Pi, tan: Mi, tanh: Ki });
    var Ni = Math.pow;
    function zi(t3) {
      return t3 === 1 / 0 || t3 === -1 / 0;
    }
    globalThis.CroquetMath.pow = (t3, e3) => {
      if (isNaN(t3) || isNaN(e3)) return NaN;
      if (zi(t3) || zi(e3)) return Ni(t3, e3);
      if (0 === t3 || 0 === e3) return Ni(t3, e3);
      if (t3 < 0 && !function(t4) {
        return Number.isInteger(t4);
      }(e3)) return NaN;
      if (1 === e3) return t3;
      if (2 === e3) return t3 * t3;
      if (3 === e3) return t3 * t3 * t3;
      if (4 === e3) return t3 * t3 * t3 * t3;
      let s3 = 1;
      t3 < 0 && (t3 *= -1, s3 = Ni(-1, e3));
      return globalThis.CroquetMath.exp(globalThis.CroquetMath.log(t3) * e3) * s3;
    };
    var _i = class extends s2 {
      poll() {
        const t3 = super.poll();
        return this.array[this.size] = null, t3;
      }
      asArray() {
        const t3 = [];
        return this.forEach((e3) => t3.push(e3)), t3;
      }
      asUnsortedArray() {
        return this.array.slice(0, this.size);
      }
    };
    var Fi;
    var Ei = { exports: {} };
    function ji() {
      return Fi || (Fi = 1, Ei.exports = function(t3) {
        return function() {
          var e3 = t3, s3 = e3.lib.WordArray;
          function n3(t4, e4, n4) {
            for (var i3 = [], o3 = 0, r2 = 0; r2 < e4; r2++) if (r2 % 4) {
              var a3 = n4[t4.charCodeAt(r2 - 1)] << r2 % 4 * 2 | n4[t4.charCodeAt(r2)] >>> 6 - r2 % 4 * 2;
              i3[o3 >>> 2] |= a3 << 24 - o3 % 4 * 8, o3++;
            }
            return s3.create(i3, o3);
          }
          e3.enc.Base64 = { stringify: function(t4) {
            var e4 = t4.words, s4 = t4.sigBytes, n4 = this._map;
            t4.clamp();
            for (var i3 = [], o3 = 0; o3 < s4; o3 += 3) for (var r2 = (e4[o3 >>> 2] >>> 24 - o3 % 4 * 8 & 255) << 16 | (e4[o3 + 1 >>> 2] >>> 24 - (o3 + 1) % 4 * 8 & 255) << 8 | e4[o3 + 2 >>> 2] >>> 24 - (o3 + 2) % 4 * 8 & 255, a3 = 0; a3 < 4 && o3 + 0.75 * a3 < s4; a3++) i3.push(n4.charAt(r2 >>> 6 * (3 - a3) & 63));
            var l3 = n4.charAt(64);
            if (l3) for (; i3.length % 4; ) i3.push(l3);
            return i3.join("");
          }, parse: function(t4) {
            var e4 = t4.length, s4 = this._map, i3 = this._reverseMap;
            if (!i3) {
              i3 = this._reverseMap = [];
              for (var o3 = 0; o3 < s4.length; o3++) i3[s4.charCodeAt(o3)] = o3;
            }
            var r2 = s4.charAt(64);
            if (r2) {
              var a3 = t4.indexOf(r2);
              -1 !== a3 && (e4 = a3);
            }
            return n3(t4, e4, i3);
          }, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" };
        }(), t3.enc.Base64;
      }(C())), Ei.exports;
    }
    var Ji;
    var Qi = i2(ji());
    var Ui = C();
    var Di = { exports: {} };
    var Oi;
    var Bi = (Ji || (Ji = 1, Di.exports = function(t3) {
      return t3.enc.Utf8;
    }(C())), Di.exports);
    var Ai = i2(Bi);
    var $i = { exports: {} };
    var qi = { exports: {} };
    function to() {
      return Oi || (Oi = 1, qi.exports = function(t3) {
        !function() {
          var e3 = t3, s3 = e3.lib.Base, n3 = e3.enc.Utf8;
          e3.algo.HMAC = s3.extend({ init: function(t4, e4) {
            t4 = this._hasher = new t4.init(), "string" == typeof e4 && (e4 = n3.parse(e4));
            var s4 = t4.blockSize, i3 = 4 * s4;
            e4.sigBytes > i3 && (e4 = t4.finalize(e4)), e4.clamp();
            for (var o3 = this._oKey = e4.clone(), r2 = this._iKey = e4.clone(), a3 = o3.words, l3 = r2.words, c2 = 0; c2 < s4; c2++) a3[c2] ^= 1549556828, l3[c2] ^= 909522486;
            o3.sigBytes = r2.sigBytes = i3, this.reset();
          }, reset: function() {
            var t4 = this._hasher;
            t4.reset(), t4.update(this._iKey);
          }, update: function(t4) {
            return this._hasher.update(t4), this;
          }, finalize: function(t4) {
            var e4 = this._hasher, s4 = e4.finalize(t4);
            return e4.reset(), e4.finalize(this._oKey.clone().concat(s4));
          } });
        }();
      }(C())), qi.exports;
    }
    var eo;
    var so;
    var no = (eo || (eo = 1, $i.exports = function(t3) {
      return function() {
        var e3 = t3, s3 = e3.lib, n3 = s3.Base, i3 = s3.WordArray, o3 = e3.algo, r2 = o3.SHA256, a3 = o3.HMAC, l3 = o3.PBKDF2 = n3.extend({ cfg: n3.extend({ keySize: 4, hasher: r2, iterations: 25e4 }), init: function(t4) {
          this.cfg = this.cfg.extend(t4);
        }, compute: function(t4, e4) {
          for (var s4 = this.cfg, n4 = a3.create(s4.hasher, t4), o4 = i3.create(), r3 = i3.create([1]), l4 = o4.words, c2 = r3.words, d2 = s4.keySize, h2 = s4.iterations; l4.length < d2; ) {
            var u2 = n4.update(e4).finalize(r3);
            n4.reset();
            for (var m2 = u2.words, p2 = m2.length, f2 = u2, b2 = 1; b2 < h2; b2++) {
              f2 = n4.finalize(f2), n4.reset();
              for (var y2 = f2.words, g2 = 0; g2 < p2; g2++) m2[g2] ^= y2[g2];
            }
            o4.concat(u2), c2[0]++;
          }
          return o4.sigBytes = 4 * d2, o4;
        } });
        e3.PBKDF2 = function(t4, e4, s4) {
          return l3.create(s4).compute(t4, e4);
        };
      }(), t3.PBKDF2;
    }(C(), M(), to())), $i.exports);
    var io = i2(no);
    var oo = { exports: {} };
    var ro = { exports: {} };
    function ao() {
      return so || (so = 1, ro.exports = function(t3) {
        return function(e3) {
          var s3 = t3, n3 = s3.lib, i3 = n3.WordArray, o3 = n3.Hasher, r2 = s3.algo, a3 = [];
          !function() {
            for (var t4 = 0; t4 < 64; t4++) a3[t4] = 4294967296 * e3.abs(e3.sin(t4 + 1)) | 0;
          }();
          var l3 = r2.MD5 = o3.extend({ _doReset: function() {
            this._hash = new i3.init([1732584193, 4023233417, 2562383102, 271733878]);
          }, _doProcessBlock: function(t4, e4) {
            for (var s4 = 0; s4 < 16; s4++) {
              var n4 = e4 + s4, i4 = t4[n4];
              t4[n4] = 16711935 & (i4 << 8 | i4 >>> 24) | 4278255360 & (i4 << 24 | i4 >>> 8);
            }
            var o4 = this._hash.words, r3 = t4[e4 + 0], l4 = t4[e4 + 1], m2 = t4[e4 + 2], p2 = t4[e4 + 3], f2 = t4[e4 + 4], b2 = t4[e4 + 5], y2 = t4[e4 + 6], g2 = t4[e4 + 7], w2 = t4[e4 + 8], Z2 = t4[e4 + 9], X2 = t4[e4 + 10], v2 = t4[e4 + 11], L2 = t4[e4 + 12], x2 = t4[e4 + 13], S2 = t4[e4 + 14], G2 = t4[e4 + 15], T2 = o4[0], W2 = o4[1], C2 = o4[2], k2 = o4[3];
            T2 = c2(T2, W2, C2, k2, r3, 7, a3[0]), k2 = c2(k2, T2, W2, C2, l4, 12, a3[1]), C2 = c2(C2, k2, T2, W2, m2, 17, a3[2]), W2 = c2(W2, C2, k2, T2, p2, 22, a3[3]), T2 = c2(T2, W2, C2, k2, f2, 7, a3[4]), k2 = c2(k2, T2, W2, C2, b2, 12, a3[5]), C2 = c2(C2, k2, T2, W2, y2, 17, a3[6]), W2 = c2(W2, C2, k2, T2, g2, 22, a3[7]), T2 = c2(T2, W2, C2, k2, w2, 7, a3[8]), k2 = c2(k2, T2, W2, C2, Z2, 12, a3[9]), C2 = c2(C2, k2, T2, W2, X2, 17, a3[10]), W2 = c2(W2, C2, k2, T2, v2, 22, a3[11]), T2 = c2(T2, W2, C2, k2, L2, 7, a3[12]), k2 = c2(k2, T2, W2, C2, x2, 12, a3[13]), C2 = c2(C2, k2, T2, W2, S2, 17, a3[14]), T2 = d2(T2, W2 = c2(W2, C2, k2, T2, G2, 22, a3[15]), C2, k2, l4, 5, a3[16]), k2 = d2(k2, T2, W2, C2, y2, 9, a3[17]), C2 = d2(C2, k2, T2, W2, v2, 14, a3[18]), W2 = d2(W2, C2, k2, T2, r3, 20, a3[19]), T2 = d2(T2, W2, C2, k2, b2, 5, a3[20]), k2 = d2(k2, T2, W2, C2, X2, 9, a3[21]), C2 = d2(C2, k2, T2, W2, G2, 14, a3[22]), W2 = d2(W2, C2, k2, T2, f2, 20, a3[23]), T2 = d2(T2, W2, C2, k2, Z2, 5, a3[24]), k2 = d2(k2, T2, W2, C2, S2, 9, a3[25]), C2 = d2(C2, k2, T2, W2, p2, 14, a3[26]), W2 = d2(W2, C2, k2, T2, w2, 20, a3[27]), T2 = d2(T2, W2, C2, k2, x2, 5, a3[28]), k2 = d2(k2, T2, W2, C2, m2, 9, a3[29]), C2 = d2(C2, k2, T2, W2, g2, 14, a3[30]), T2 = h2(T2, W2 = d2(W2, C2, k2, T2, L2, 20, a3[31]), C2, k2, b2, 4, a3[32]), k2 = h2(k2, T2, W2, C2, w2, 11, a3[33]), C2 = h2(C2, k2, T2, W2, v2, 16, a3[34]), W2 = h2(W2, C2, k2, T2, S2, 23, a3[35]), T2 = h2(T2, W2, C2, k2, l4, 4, a3[36]), k2 = h2(k2, T2, W2, C2, f2, 11, a3[37]), C2 = h2(C2, k2, T2, W2, g2, 16, a3[38]), W2 = h2(W2, C2, k2, T2, X2, 23, a3[39]), T2 = h2(T2, W2, C2, k2, x2, 4, a3[40]), k2 = h2(k2, T2, W2, C2, r3, 11, a3[41]), C2 = h2(C2, k2, T2, W2, p2, 16, a3[42]), W2 = h2(W2, C2, k2, T2, y2, 23, a3[43]), T2 = h2(T2, W2, C2, k2, Z2, 4, a3[44]), k2 = h2(k2, T2, W2, C2, L2, 11, a3[45]), C2 = h2(C2, k2, T2, W2, G2, 16, a3[46]), T2 = u2(T2, W2 = h2(W2, C2, k2, T2, m2, 23, a3[47]), C2, k2, r3, 6, a3[48]), k2 = u2(k2, T2, W2, C2, g2, 10, a3[49]), C2 = u2(C2, k2, T2, W2, S2, 15, a3[50]), W2 = u2(W2, C2, k2, T2, b2, 21, a3[51]), T2 = u2(T2, W2, C2, k2, L2, 6, a3[52]), k2 = u2(k2, T2, W2, C2, p2, 10, a3[53]), C2 = u2(C2, k2, T2, W2, X2, 15, a3[54]), W2 = u2(W2, C2, k2, T2, l4, 21, a3[55]), T2 = u2(T2, W2, C2, k2, w2, 6, a3[56]), k2 = u2(k2, T2, W2, C2, G2, 10, a3[57]), C2 = u2(C2, k2, T2, W2, y2, 15, a3[58]), W2 = u2(W2, C2, k2, T2, x2, 21, a3[59]), T2 = u2(T2, W2, C2, k2, f2, 6, a3[60]), k2 = u2(k2, T2, W2, C2, v2, 10, a3[61]), C2 = u2(C2, k2, T2, W2, m2, 15, a3[62]), W2 = u2(W2, C2, k2, T2, Z2, 21, a3[63]), o4[0] = o4[0] + T2 | 0, o4[1] = o4[1] + W2 | 0, o4[2] = o4[2] + C2 | 0, o4[3] = o4[3] + k2 | 0;
          }, _doFinalize: function() {
            var t4 = this._data, s4 = t4.words, n4 = 8 * this._nDataBytes, i4 = 8 * t4.sigBytes;
            s4[i4 >>> 5] |= 128 << 24 - i4 % 32;
            var o4 = e3.floor(n4 / 4294967296), r3 = n4;
            s4[15 + (i4 + 64 >>> 9 << 4)] = 16711935 & (o4 << 8 | o4 >>> 24) | 4278255360 & (o4 << 24 | o4 >>> 8), s4[14 + (i4 + 64 >>> 9 << 4)] = 16711935 & (r3 << 8 | r3 >>> 24) | 4278255360 & (r3 << 24 | r3 >>> 8), t4.sigBytes = 4 * (s4.length + 1), this._process();
            for (var a4 = this._hash, l4 = a4.words, c3 = 0; c3 < 4; c3++) {
              var d3 = l4[c3];
              l4[c3] = 16711935 & (d3 << 8 | d3 >>> 24) | 4278255360 & (d3 << 24 | d3 >>> 8);
            }
            return a4;
          }, clone: function() {
            var t4 = o3.clone.call(this);
            return t4._hash = this._hash.clone(), t4;
          } });
          function c2(t4, e4, s4, n4, i4, o4, r3) {
            var a4 = t4 + (e4 & s4 | ~e4 & n4) + i4 + r3;
            return (a4 << o4 | a4 >>> 32 - o4) + e4;
          }
          function d2(t4, e4, s4, n4, i4, o4, r3) {
            var a4 = t4 + (e4 & n4 | s4 & ~n4) + i4 + r3;
            return (a4 << o4 | a4 >>> 32 - o4) + e4;
          }
          function h2(t4, e4, s4, n4, i4, o4, r3) {
            var a4 = t4 + (e4 ^ s4 ^ n4) + i4 + r3;
            return (a4 << o4 | a4 >>> 32 - o4) + e4;
          }
          function u2(t4, e4, s4, n4, i4, o4, r3) {
            var a4 = t4 + (s4 ^ (e4 | ~n4)) + i4 + r3;
            return (a4 << o4 | a4 >>> 32 - o4) + e4;
          }
          s3.MD5 = o3._createHelper(l3), s3.HmacMD5 = o3._createHmacHelper(l3);
        }(Math), t3.MD5;
      }(C())), ro.exports;
    }
    var lo;
    var co = { exports: {} };
    var ho = { exports: {} };
    function uo() {
      return lo || (lo = 1, ho.exports = function(t3) {
        return function() {
          var e3 = t3, s3 = e3.lib, n3 = s3.WordArray, i3 = s3.Hasher, o3 = e3.algo, r2 = [], a3 = o3.SHA1 = i3.extend({ _doReset: function() {
            this._hash = new n3.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          }, _doProcessBlock: function(t4, e4) {
            for (var s4 = this._hash.words, n4 = s4[0], i4 = s4[1], o4 = s4[2], a4 = s4[3], l3 = s4[4], c2 = 0; c2 < 80; c2++) {
              if (c2 < 16) r2[c2] = 0 | t4[e4 + c2];
              else {
                var d2 = r2[c2 - 3] ^ r2[c2 - 8] ^ r2[c2 - 14] ^ r2[c2 - 16];
                r2[c2] = d2 << 1 | d2 >>> 31;
              }
              var h2 = (n4 << 5 | n4 >>> 27) + l3 + r2[c2];
              h2 += c2 < 20 ? 1518500249 + (i4 & o4 | ~i4 & a4) : c2 < 40 ? 1859775393 + (i4 ^ o4 ^ a4) : c2 < 60 ? (i4 & o4 | i4 & a4 | o4 & a4) - 1894007588 : (i4 ^ o4 ^ a4) - 899497514, l3 = a4, a4 = o4, o4 = i4 << 30 | i4 >>> 2, i4 = n4, n4 = h2;
            }
            s4[0] = s4[0] + n4 | 0, s4[1] = s4[1] + i4 | 0, s4[2] = s4[2] + o4 | 0, s4[3] = s4[3] + a4 | 0, s4[4] = s4[4] + l3 | 0;
          }, _doFinalize: function() {
            var t4 = this._data, e4 = t4.words, s4 = 8 * this._nDataBytes, n4 = 8 * t4.sigBytes;
            return e4[n4 >>> 5] |= 128 << 24 - n4 % 32, e4[14 + (n4 + 64 >>> 9 << 4)] = Math.floor(s4 / 4294967296), e4[15 + (n4 + 64 >>> 9 << 4)] = s4, t4.sigBytes = 4 * e4.length, this._process(), this._hash;
          }, clone: function() {
            var t4 = i3.clone.call(this);
            return t4._hash = this._hash.clone(), t4;
          } });
          e3.SHA1 = i3._createHelper(a3), e3.HmacSHA1 = i3._createHmacHelper(a3);
        }(), t3.SHA1;
      }(C())), ho.exports;
    }
    var mo;
    function po() {
      return mo || (mo = 1, co.exports = function(t3) {
        return function() {
          var e3 = t3, s3 = e3.lib, n3 = s3.Base, i3 = s3.WordArray, o3 = e3.algo, r2 = o3.MD5, a3 = o3.EvpKDF = n3.extend({ cfg: n3.extend({ keySize: 4, hasher: r2, iterations: 1 }), init: function(t4) {
            this.cfg = this.cfg.extend(t4);
          }, compute: function(t4, e4) {
            for (var s4, n4 = this.cfg, o4 = n4.hasher.create(), r3 = i3.create(), a4 = r3.words, l3 = n4.keySize, c2 = n4.iterations; a4.length < l3; ) {
              s4 && o4.update(s4), s4 = o4.update(t4).finalize(e4), o4.reset();
              for (var d2 = 1; d2 < c2; d2++) s4 = o4.finalize(s4), o4.reset();
              r3.concat(s4);
            }
            return r3.sigBytes = 4 * l3, r3;
          } });
          e3.EvpKDF = function(t4, e4, s4) {
            return a3.create(s4).compute(t4, e4);
          };
        }(), t3.EvpKDF;
      }(C(), uo(), to())), co.exports;
    }
    var fo;
    var bo = { exports: {} };
    var yo;
    var go;
    var wo = (yo || (yo = 1, oo.exports = function(t3) {
      return function() {
        var e3 = t3, s3 = e3.lib.BlockCipher, n3 = e3.algo, i3 = [], o3 = [], r2 = [], a3 = [], l3 = [], c2 = [], d2 = [], h2 = [], u2 = [], m2 = [];
        !function() {
          for (var t4 = [], e4 = 0; e4 < 256; e4++) t4[e4] = e4 < 128 ? e4 << 1 : e4 << 1 ^ 283;
          var s4 = 0, n4 = 0;
          for (e4 = 0; e4 < 256; e4++) {
            var p3 = n4 ^ n4 << 1 ^ n4 << 2 ^ n4 << 3 ^ n4 << 4;
            p3 = p3 >>> 8 ^ 255 & p3 ^ 99, i3[s4] = p3, o3[p3] = s4;
            var f3 = t4[s4], b2 = t4[f3], y2 = t4[b2], g2 = 257 * t4[p3] ^ 16843008 * p3;
            r2[s4] = g2 << 24 | g2 >>> 8, a3[s4] = g2 << 16 | g2 >>> 16, l3[s4] = g2 << 8 | g2 >>> 24, c2[s4] = g2, g2 = 16843009 * y2 ^ 65537 * b2 ^ 257 * f3 ^ 16843008 * s4, d2[p3] = g2 << 24 | g2 >>> 8, h2[p3] = g2 << 16 | g2 >>> 16, u2[p3] = g2 << 8 | g2 >>> 24, m2[p3] = g2, s4 ? (s4 = f3 ^ t4[t4[t4[y2 ^ f3]]], n4 ^= t4[t4[n4]]) : s4 = n4 = 1;
          }
        }();
        var p2 = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], f2 = n3.AES = s3.extend({ _doReset: function() {
          if (!this._nRounds || this._keyPriorReset !== this._key) {
            for (var t4 = this._keyPriorReset = this._key, e4 = t4.words, s4 = t4.sigBytes / 4, n4 = 4 * ((this._nRounds = s4 + 6) + 1), o4 = this._keySchedule = [], r3 = 0; r3 < n4; r3++) r3 < s4 ? o4[r3] = e4[r3] : (c3 = o4[r3 - 1], r3 % s4 ? s4 > 6 && r3 % s4 == 4 && (c3 = i3[c3 >>> 24] << 24 | i3[c3 >>> 16 & 255] << 16 | i3[c3 >>> 8 & 255] << 8 | i3[255 & c3]) : (c3 = i3[(c3 = c3 << 8 | c3 >>> 24) >>> 24] << 24 | i3[c3 >>> 16 & 255] << 16 | i3[c3 >>> 8 & 255] << 8 | i3[255 & c3], c3 ^= p2[r3 / s4 | 0] << 24), o4[r3] = o4[r3 - s4] ^ c3);
            for (var a4 = this._invKeySchedule = [], l4 = 0; l4 < n4; l4++) {
              if (r3 = n4 - l4, l4 % 4) var c3 = o4[r3];
              else c3 = o4[r3 - 4];
              a4[l4] = l4 < 4 || r3 <= 4 ? c3 : d2[i3[c3 >>> 24]] ^ h2[i3[c3 >>> 16 & 255]] ^ u2[i3[c3 >>> 8 & 255]] ^ m2[i3[255 & c3]];
            }
          }
        }, encryptBlock: function(t4, e4) {
          this._doCryptBlock(t4, e4, this._keySchedule, r2, a3, l3, c2, i3);
        }, decryptBlock: function(t4, e4) {
          var s4 = t4[e4 + 1];
          t4[e4 + 1] = t4[e4 + 3], t4[e4 + 3] = s4, this._doCryptBlock(t4, e4, this._invKeySchedule, d2, h2, u2, m2, o3), s4 = t4[e4 + 1], t4[e4 + 1] = t4[e4 + 3], t4[e4 + 3] = s4;
        }, _doCryptBlock: function(t4, e4, s4, n4, i4, o4, r3, a4) {
          for (var l4 = this._nRounds, c3 = t4[e4] ^ s4[0], d3 = t4[e4 + 1] ^ s4[1], h3 = t4[e4 + 2] ^ s4[2], u3 = t4[e4 + 3] ^ s4[3], m3 = 4, p3 = 1; p3 < l4; p3++) {
            var f3 = n4[c3 >>> 24] ^ i4[d3 >>> 16 & 255] ^ o4[h3 >>> 8 & 255] ^ r3[255 & u3] ^ s4[m3++], b2 = n4[d3 >>> 24] ^ i4[h3 >>> 16 & 255] ^ o4[u3 >>> 8 & 255] ^ r3[255 & c3] ^ s4[m3++], y2 = n4[h3 >>> 24] ^ i4[u3 >>> 16 & 255] ^ o4[c3 >>> 8 & 255] ^ r3[255 & d3] ^ s4[m3++], g2 = n4[u3 >>> 24] ^ i4[c3 >>> 16 & 255] ^ o4[d3 >>> 8 & 255] ^ r3[255 & h3] ^ s4[m3++];
            c3 = f3, d3 = b2, h3 = y2, u3 = g2;
          }
          f3 = (a4[c3 >>> 24] << 24 | a4[d3 >>> 16 & 255] << 16 | a4[h3 >>> 8 & 255] << 8 | a4[255 & u3]) ^ s4[m3++], b2 = (a4[d3 >>> 24] << 24 | a4[h3 >>> 16 & 255] << 16 | a4[u3 >>> 8 & 255] << 8 | a4[255 & c3]) ^ s4[m3++], y2 = (a4[h3 >>> 24] << 24 | a4[u3 >>> 16 & 255] << 16 | a4[c3 >>> 8 & 255] << 8 | a4[255 & d3]) ^ s4[m3++], g2 = (a4[u3 >>> 24] << 24 | a4[c3 >>> 16 & 255] << 16 | a4[d3 >>> 8 & 255] << 8 | a4[255 & h3]) ^ s4[m3++], t4[e4] = f3, t4[e4 + 1] = b2, t4[e4 + 2] = y2, t4[e4 + 3] = g2;
        }, keySize: 8 });
        e3.AES = s3._createHelper(f2);
      }(), t3.AES;
    }(C(), ji(), ao(), po(), fo || (fo = 1, bo.exports = function(t3) {
      t3.lib.Cipher || function(e3) {
        var s3 = t3, n3 = s3.lib, i3 = n3.Base, o3 = n3.WordArray, r2 = n3.BufferedBlockAlgorithm, a3 = s3.enc;
        a3.Utf8;
        var l3 = a3.Base64, c2 = s3.algo.EvpKDF, d2 = n3.Cipher = r2.extend({ cfg: i3.extend(), createEncryptor: function(t4, e4) {
          return this.create(this._ENC_XFORM_MODE, t4, e4);
        }, createDecryptor: function(t4, e4) {
          return this.create(this._DEC_XFORM_MODE, t4, e4);
        }, init: function(t4, e4, s4) {
          this.cfg = this.cfg.extend(s4), this._xformMode = t4, this._key = e4, this.reset();
        }, reset: function() {
          r2.reset.call(this), this._doReset();
        }, process: function(t4) {
          return this._append(t4), this._process();
        }, finalize: function(t4) {
          return t4 && this._append(t4), this._doFinalize();
        }, keySize: 4, ivSize: 4, _ENC_XFORM_MODE: 1, _DEC_XFORM_MODE: 2, _createHelper: /* @__PURE__ */ function() {
          function t4(t5) {
            return "string" == typeof t5 ? w2 : y2;
          }
          return function(e4) {
            return { encrypt: function(s4, n4, i4) {
              return t4(n4).encrypt(e4, s4, n4, i4);
            }, decrypt: function(s4, n4, i4) {
              return t4(n4).decrypt(e4, s4, n4, i4);
            } };
          };
        }() });
        n3.StreamCipher = d2.extend({ _doFinalize: function() {
          return this._process(true);
        }, blockSize: 1 });
        var h2 = s3.mode = {}, u2 = n3.BlockCipherMode = i3.extend({ createEncryptor: function(t4, e4) {
          return this.Encryptor.create(t4, e4);
        }, createDecryptor: function(t4, e4) {
          return this.Decryptor.create(t4, e4);
        }, init: function(t4, e4) {
          this._cipher = t4, this._iv = e4;
        } }), m2 = h2.CBC = function() {
          var t4 = u2.extend();
          function s4(t5, s5, n4) {
            var i4, o4 = this._iv;
            o4 ? (i4 = o4, this._iv = e3) : i4 = this._prevBlock;
            for (var r3 = 0; r3 < n4; r3++) t5[s5 + r3] ^= i4[r3];
          }
          return t4.Encryptor = t4.extend({ processBlock: function(t5, e4) {
            var n4 = this._cipher, i4 = n4.blockSize;
            s4.call(this, t5, e4, i4), n4.encryptBlock(t5, e4), this._prevBlock = t5.slice(e4, e4 + i4);
          } }), t4.Decryptor = t4.extend({ processBlock: function(t5, e4) {
            var n4 = this._cipher, i4 = n4.blockSize, o4 = t5.slice(e4, e4 + i4);
            n4.decryptBlock(t5, e4), s4.call(this, t5, e4, i4), this._prevBlock = o4;
          } }), t4;
        }(), p2 = (s3.pad = {}).Pkcs7 = { pad: function(t4, e4) {
          for (var s4 = 4 * e4, n4 = s4 - t4.sigBytes % s4, i4 = n4 << 24 | n4 << 16 | n4 << 8 | n4, r3 = [], a4 = 0; a4 < n4; a4 += 4) r3.push(i4);
          var l4 = o3.create(r3, n4);
          t4.concat(l4);
        }, unpad: function(t4) {
          var e4 = 255 & t4.words[t4.sigBytes - 1 >>> 2];
          t4.sigBytes -= e4;
        } };
        n3.BlockCipher = d2.extend({ cfg: d2.cfg.extend({ mode: m2, padding: p2 }), reset: function() {
          var t4;
          d2.reset.call(this);
          var e4 = this.cfg, s4 = e4.iv, n4 = e4.mode;
          this._xformMode == this._ENC_XFORM_MODE ? t4 = n4.createEncryptor : (t4 = n4.createDecryptor, this._minBufferSize = 1), this._mode && this._mode.__creator == t4 ? this._mode.init(this, s4 && s4.words) : (this._mode = t4.call(n4, this, s4 && s4.words), this._mode.__creator = t4);
        }, _doProcessBlock: function(t4, e4) {
          this._mode.processBlock(t4, e4);
        }, _doFinalize: function() {
          var t4, e4 = this.cfg.padding;
          return this._xformMode == this._ENC_XFORM_MODE ? (e4.pad(this._data, this.blockSize), t4 = this._process(true)) : (t4 = this._process(true), e4.unpad(t4)), t4;
        }, blockSize: 4 });
        var f2 = n3.CipherParams = i3.extend({ init: function(t4) {
          this.mixIn(t4);
        }, toString: function(t4) {
          return (t4 || this.formatter).stringify(this);
        } }), b2 = (s3.format = {}).OpenSSL = { stringify: function(t4) {
          var e4 = t4.ciphertext, s4 = t4.salt;
          return (s4 ? o3.create([1398893684, 1701076831]).concat(s4).concat(e4) : e4).toString(l3);
        }, parse: function(t4) {
          var e4, s4 = l3.parse(t4), n4 = s4.words;
          return 1398893684 == n4[0] && 1701076831 == n4[1] && (e4 = o3.create(n4.slice(2, 4)), n4.splice(0, 4), s4.sigBytes -= 16), f2.create({ ciphertext: s4, salt: e4 });
        } }, y2 = n3.SerializableCipher = i3.extend({ cfg: i3.extend({ format: b2 }), encrypt: function(t4, e4, s4, n4) {
          n4 = this.cfg.extend(n4);
          var i4 = t4.createEncryptor(s4, n4), o4 = i4.finalize(e4), r3 = i4.cfg;
          return f2.create({ ciphertext: o4, key: s4, iv: r3.iv, algorithm: t4, mode: r3.mode, padding: r3.padding, blockSize: t4.blockSize, formatter: n4.format });
        }, decrypt: function(t4, e4, s4, n4) {
          return n4 = this.cfg.extend(n4), e4 = this._parse(e4, n4.format), t4.createDecryptor(s4, n4).finalize(e4.ciphertext);
        }, _parse: function(t4, e4) {
          return "string" == typeof t4 ? e4.parse(t4, this) : t4;
        } }), g2 = (s3.kdf = {}).OpenSSL = { execute: function(t4, e4, s4, n4, i4) {
          if (n4 || (n4 = o3.random(8)), i4) r3 = c2.create({ keySize: e4 + s4, hasher: i4 }).compute(t4, n4);
          else var r3 = c2.create({ keySize: e4 + s4 }).compute(t4, n4);
          var a4 = o3.create(r3.words.slice(e4), 4 * s4);
          return r3.sigBytes = 4 * e4, f2.create({ key: r3, iv: a4, salt: n4 });
        } }, w2 = n3.PasswordBasedCipher = y2.extend({ cfg: y2.cfg.extend({ kdf: g2 }), encrypt: function(t4, e4, s4, n4) {
          var i4 = (n4 = this.cfg.extend(n4)).kdf.execute(s4, t4.keySize, t4.ivSize, n4.salt, n4.hasher);
          n4.iv = i4.iv;
          var o4 = y2.encrypt.call(this, t4, e4, i4.key, n4);
          return o4.mixIn(i4), o4;
        }, decrypt: function(t4, e4, s4, n4) {
          n4 = this.cfg.extend(n4), e4 = this._parse(e4, n4.format);
          var i4 = n4.kdf.execute(s4, t4.keySize, t4.ivSize, e4.salt, n4.hasher);
          return n4.iv = i4.iv, y2.decrypt.call(this, t4, e4, i4.key, n4);
        } });
      }();
    }(C(), po())))), oo.exports);
    var Zo = i2(wo);
    var Xo = { exports: {} };
    var vo = (go || (go = 1, Xo.exports = function(t3) {
      return t3.HmacSHA256;
    }(C(), M(), to())), Xo.exports);
    var Lo = i2(vo);
    function xo(t3) {
      let e3 = t3.length;
      for (; --e3 >= 0; ) t3[e3] = 0;
    }
    var So = 256;
    var Go = 286;
    var To = 30;
    var Wo = 15;
    var Co = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
    var ko = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
    var Po = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
    var Io = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    var Ro = new Array(576);
    xo(Ro);
    var Vo = new Array(60);
    xo(Vo);
    var Yo = new Array(512);
    xo(Yo);
    var Mo = new Array(256);
    xo(Mo);
    var Ho = new Array(29);
    xo(Ho);
    var Ko = new Array(To);
    function No(t3, e3, s3, n3, i3) {
      this.static_tree = t3, this.extra_bits = e3, this.extra_base = s3, this.elems = n3, this.max_length = i3, this.has_stree = t3 && t3.length;
    }
    var zo;
    var _o;
    var Fo;
    function Eo(t3, e3) {
      this.dyn_tree = t3, this.max_code = 0, this.stat_desc = e3;
    }
    xo(Ko);
    var jo = (t3) => t3 < 256 ? Yo[t3] : Yo[256 + (t3 >>> 7)];
    var Jo = (t3, e3) => {
      t3.pending_buf[t3.pending++] = 255 & e3, t3.pending_buf[t3.pending++] = e3 >>> 8 & 255;
    };
    var Qo = (t3, e3, s3) => {
      t3.bi_valid > 16 - s3 ? (t3.bi_buf |= e3 << t3.bi_valid & 65535, Jo(t3, t3.bi_buf), t3.bi_buf = e3 >> 16 - t3.bi_valid, t3.bi_valid += s3 - 16) : (t3.bi_buf |= e3 << t3.bi_valid & 65535, t3.bi_valid += s3);
    };
    var Uo = (t3, e3, s3) => {
      Qo(t3, s3[2 * e3], s3[2 * e3 + 1]);
    };
    var Do = (t3, e3) => {
      let s3 = 0;
      do {
        s3 |= 1 & t3, t3 >>>= 1, s3 <<= 1;
      } while (--e3 > 0);
      return s3 >>> 1;
    };
    var Oo = (t3, e3, s3) => {
      const n3 = new Array(16);
      let i3, o3, r2 = 0;
      for (i3 = 1; i3 <= Wo; i3++) r2 = r2 + s3[i3 - 1] << 1, n3[i3] = r2;
      for (o3 = 0; o3 <= e3; o3++) {
        let e4 = t3[2 * o3 + 1];
        0 !== e4 && (t3[2 * o3] = Do(n3[e4]++, e4));
      }
    };
    var Bo = (t3) => {
      let e3;
      for (e3 = 0; e3 < Go; e3++) t3.dyn_ltree[2 * e3] = 0;
      for (e3 = 0; e3 < To; e3++) t3.dyn_dtree[2 * e3] = 0;
      for (e3 = 0; e3 < 19; e3++) t3.bl_tree[2 * e3] = 0;
      t3.dyn_ltree[512] = 1, t3.opt_len = t3.static_len = 0, t3.sym_next = t3.matches = 0;
    };
    var Ao = (t3) => {
      t3.bi_valid > 8 ? Jo(t3, t3.bi_buf) : t3.bi_valid > 0 && (t3.pending_buf[t3.pending++] = t3.bi_buf), t3.bi_buf = 0, t3.bi_valid = 0;
    };
    var $o = (t3, e3, s3, n3) => {
      const i3 = 2 * e3, o3 = 2 * s3;
      return t3[i3] < t3[o3] || t3[i3] === t3[o3] && n3[e3] <= n3[s3];
    };
    var qo = (t3, e3, s3) => {
      const n3 = t3.heap[s3];
      let i3 = s3 << 1;
      for (; i3 <= t3.heap_len && (i3 < t3.heap_len && $o(e3, t3.heap[i3 + 1], t3.heap[i3], t3.depth) && i3++, !$o(e3, n3, t3.heap[i3], t3.depth)); ) t3.heap[s3] = t3.heap[i3], s3 = i3, i3 <<= 1;
      t3.heap[s3] = n3;
    };
    var tr = (t3, e3, s3) => {
      let n3, i3, o3, r2, a3 = 0;
      if (0 !== t3.sym_next) do {
        n3 = 255 & t3.pending_buf[t3.sym_buf + a3++], n3 += (255 & t3.pending_buf[t3.sym_buf + a3++]) << 8, i3 = t3.pending_buf[t3.sym_buf + a3++], 0 === n3 ? Uo(t3, i3, e3) : (o3 = Mo[i3], Uo(t3, o3 + So + 1, e3), r2 = Co[o3], 0 !== r2 && (i3 -= Ho[o3], Qo(t3, i3, r2)), n3--, o3 = jo(n3), Uo(t3, o3, s3), r2 = ko[o3], 0 !== r2 && (n3 -= Ko[o3], Qo(t3, n3, r2)));
      } while (a3 < t3.sym_next);
      Uo(t3, 256, e3);
    };
    var er = (t3, e3) => {
      const s3 = e3.dyn_tree, n3 = e3.stat_desc.static_tree, i3 = e3.stat_desc.has_stree, o3 = e3.stat_desc.elems;
      let r2, a3, l3, c2 = -1;
      for (t3.heap_len = 0, t3.heap_max = 573, r2 = 0; r2 < o3; r2++) 0 !== s3[2 * r2] ? (t3.heap[++t3.heap_len] = c2 = r2, t3.depth[r2] = 0) : s3[2 * r2 + 1] = 0;
      for (; t3.heap_len < 2; ) l3 = t3.heap[++t3.heap_len] = c2 < 2 ? ++c2 : 0, s3[2 * l3] = 1, t3.depth[l3] = 0, t3.opt_len--, i3 && (t3.static_len -= n3[2 * l3 + 1]);
      for (e3.max_code = c2, r2 = t3.heap_len >> 1; r2 >= 1; r2--) qo(t3, s3, r2);
      l3 = o3;
      do {
        r2 = t3.heap[1], t3.heap[1] = t3.heap[t3.heap_len--], qo(t3, s3, 1), a3 = t3.heap[1], t3.heap[--t3.heap_max] = r2, t3.heap[--t3.heap_max] = a3, s3[2 * l3] = s3[2 * r2] + s3[2 * a3], t3.depth[l3] = (t3.depth[r2] >= t3.depth[a3] ? t3.depth[r2] : t3.depth[a3]) + 1, s3[2 * r2 + 1] = s3[2 * a3 + 1] = l3, t3.heap[1] = l3++, qo(t3, s3, 1);
      } while (t3.heap_len >= 2);
      t3.heap[--t3.heap_max] = t3.heap[1], ((t4, e4) => {
        const s4 = e4.dyn_tree, n4 = e4.max_code, i4 = e4.stat_desc.static_tree, o4 = e4.stat_desc.has_stree, r3 = e4.stat_desc.extra_bits, a4 = e4.stat_desc.extra_base, l4 = e4.stat_desc.max_length;
        let c3, d2, h2, u2, m2, p2, f2 = 0;
        for (u2 = 0; u2 <= Wo; u2++) t4.bl_count[u2] = 0;
        for (s4[2 * t4.heap[t4.heap_max] + 1] = 0, c3 = t4.heap_max + 1; c3 < 573; c3++) d2 = t4.heap[c3], u2 = s4[2 * s4[2 * d2 + 1] + 1] + 1, u2 > l4 && (u2 = l4, f2++), s4[2 * d2 + 1] = u2, d2 > n4 || (t4.bl_count[u2]++, m2 = 0, d2 >= a4 && (m2 = r3[d2 - a4]), p2 = s4[2 * d2], t4.opt_len += p2 * (u2 + m2), o4 && (t4.static_len += p2 * (i4[2 * d2 + 1] + m2)));
        if (0 !== f2) {
          do {
            for (u2 = l4 - 1; 0 === t4.bl_count[u2]; ) u2--;
            t4.bl_count[u2]--, t4.bl_count[u2 + 1] += 2, t4.bl_count[l4]--, f2 -= 2;
          } while (f2 > 0);
          for (u2 = l4; 0 !== u2; u2--) for (d2 = t4.bl_count[u2]; 0 !== d2; ) h2 = t4.heap[--c3], h2 > n4 || (s4[2 * h2 + 1] !== u2 && (t4.opt_len += (u2 - s4[2 * h2 + 1]) * s4[2 * h2], s4[2 * h2 + 1] = u2), d2--);
        }
      })(t3, e3), Oo(s3, c2, t3.bl_count);
    };
    var sr = (t3, e3, s3) => {
      let n3, i3, o3 = -1, r2 = e3[1], a3 = 0, l3 = 7, c2 = 4;
      for (0 === r2 && (l3 = 138, c2 = 3), e3[2 * (s3 + 1) + 1] = 65535, n3 = 0; n3 <= s3; n3++) i3 = r2, r2 = e3[2 * (n3 + 1) + 1], ++a3 < l3 && i3 === r2 || (a3 < c2 ? t3.bl_tree[2 * i3] += a3 : 0 !== i3 ? (i3 !== o3 && t3.bl_tree[2 * i3]++, t3.bl_tree[32]++) : a3 <= 10 ? t3.bl_tree[34]++ : t3.bl_tree[36]++, a3 = 0, o3 = i3, 0 === r2 ? (l3 = 138, c2 = 3) : i3 === r2 ? (l3 = 6, c2 = 3) : (l3 = 7, c2 = 4));
    };
    var nr = (t3, e3, s3) => {
      let n3, i3, o3 = -1, r2 = e3[1], a3 = 0, l3 = 7, c2 = 4;
      for (0 === r2 && (l3 = 138, c2 = 3), n3 = 0; n3 <= s3; n3++) if (i3 = r2, r2 = e3[2 * (n3 + 1) + 1], !(++a3 < l3 && i3 === r2)) {
        if (a3 < c2) do {
          Uo(t3, i3, t3.bl_tree);
        } while (0 != --a3);
        else 0 !== i3 ? (i3 !== o3 && (Uo(t3, i3, t3.bl_tree), a3--), Uo(t3, 16, t3.bl_tree), Qo(t3, a3 - 3, 2)) : a3 <= 10 ? (Uo(t3, 17, t3.bl_tree), Qo(t3, a3 - 3, 3)) : (Uo(t3, 18, t3.bl_tree), Qo(t3, a3 - 11, 7));
        a3 = 0, o3 = i3, 0 === r2 ? (l3 = 138, c2 = 3) : i3 === r2 ? (l3 = 6, c2 = 3) : (l3 = 7, c2 = 4);
      }
    };
    var ir = false;
    var or = (t3, e3, s3, n3) => {
      Qo(t3, 0 + (n3 ? 1 : 0), 3), Ao(t3), Jo(t3, s3), Jo(t3, ~s3), s3 && t3.pending_buf.set(t3.window.subarray(e3, e3 + s3), t3.pending), t3.pending += s3;
    };
    var rr = (t3, e3, s3, n3) => {
      let i3, o3, r2 = 0;
      t3.level > 0 ? (2 === t3.strm.data_type && (t3.strm.data_type = ((t4) => {
        let e4, s4 = 4093624447;
        for (e4 = 0; e4 <= 31; e4++, s4 >>>= 1) if (1 & s4 && 0 !== t4.dyn_ltree[2 * e4]) return 0;
        if (0 !== t4.dyn_ltree[18] || 0 !== t4.dyn_ltree[20] || 0 !== t4.dyn_ltree[26]) return 1;
        for (e4 = 32; e4 < So; e4++) if (0 !== t4.dyn_ltree[2 * e4]) return 1;
        return 0;
      })(t3)), er(t3, t3.l_desc), er(t3, t3.d_desc), r2 = ((t4) => {
        let e4;
        for (sr(t4, t4.dyn_ltree, t4.l_desc.max_code), sr(t4, t4.dyn_dtree, t4.d_desc.max_code), er(t4, t4.bl_desc), e4 = 18; e4 >= 3 && 0 === t4.bl_tree[2 * Io[e4] + 1]; e4--) ;
        return t4.opt_len += 3 * (e4 + 1) + 5 + 5 + 4, e4;
      })(t3), i3 = t3.opt_len + 3 + 7 >>> 3, o3 = t3.static_len + 3 + 7 >>> 3, o3 <= i3 && (i3 = o3)) : i3 = o3 = s3 + 5, s3 + 4 <= i3 && -1 !== e3 ? or(t3, e3, s3, n3) : 4 === t3.strategy || o3 === i3 ? (Qo(t3, 2 + (n3 ? 1 : 0), 3), tr(t3, Ro, Vo)) : (Qo(t3, 4 + (n3 ? 1 : 0), 3), ((t4, e4, s4, n4) => {
        let i4;
        for (Qo(t4, e4 - 257, 5), Qo(t4, s4 - 1, 5), Qo(t4, n4 - 4, 4), i4 = 0; i4 < n4; i4++) Qo(t4, t4.bl_tree[2 * Io[i4] + 1], 3);
        nr(t4, t4.dyn_ltree, e4 - 1), nr(t4, t4.dyn_dtree, s4 - 1);
      })(t3, t3.l_desc.max_code + 1, t3.d_desc.max_code + 1, r2 + 1), tr(t3, t3.dyn_ltree, t3.dyn_dtree)), Bo(t3), n3 && Ao(t3);
    };
    var ar = { _tr_init: (t3) => {
      ir || ((() => {
        let t4, e3, s3, n3, i3;
        const o3 = new Array(16);
        for (s3 = 0, n3 = 0; n3 < 28; n3++) for (Ho[n3] = s3, t4 = 0; t4 < 1 << Co[n3]; t4++) Mo[s3++] = n3;
        for (Mo[s3 - 1] = n3, i3 = 0, n3 = 0; n3 < 16; n3++) for (Ko[n3] = i3, t4 = 0; t4 < 1 << ko[n3]; t4++) Yo[i3++] = n3;
        for (i3 >>= 7; n3 < To; n3++) for (Ko[n3] = i3 << 7, t4 = 0; t4 < 1 << ko[n3] - 7; t4++) Yo[256 + i3++] = n3;
        for (e3 = 0; e3 <= Wo; e3++) o3[e3] = 0;
        for (t4 = 0; t4 <= 143; ) Ro[2 * t4 + 1] = 8, t4++, o3[8]++;
        for (; t4 <= 255; ) Ro[2 * t4 + 1] = 9, t4++, o3[9]++;
        for (; t4 <= 279; ) Ro[2 * t4 + 1] = 7, t4++, o3[7]++;
        for (; t4 <= 287; ) Ro[2 * t4 + 1] = 8, t4++, o3[8]++;
        for (Oo(Ro, 287, o3), t4 = 0; t4 < To; t4++) Vo[2 * t4 + 1] = 5, Vo[2 * t4] = Do(t4, 5);
        zo = new No(Ro, Co, 257, Go, Wo), _o = new No(Vo, ko, 0, To, Wo), Fo = new No(new Array(0), Po, 0, 19, 7);
      })(), ir = true), t3.l_desc = new Eo(t3.dyn_ltree, zo), t3.d_desc = new Eo(t3.dyn_dtree, _o), t3.bl_desc = new Eo(t3.bl_tree, Fo), t3.bi_buf = 0, t3.bi_valid = 0, Bo(t3);
    }, _tr_stored_block: or, _tr_flush_block: rr, _tr_tally: (t3, e3, s3) => (t3.pending_buf[t3.sym_buf + t3.sym_next++] = e3, t3.pending_buf[t3.sym_buf + t3.sym_next++] = e3 >> 8, t3.pending_buf[t3.sym_buf + t3.sym_next++] = s3, 0 === e3 ? t3.dyn_ltree[2 * s3]++ : (t3.matches++, e3--, t3.dyn_ltree[2 * (Mo[s3] + So + 1)]++, t3.dyn_dtree[2 * jo(e3)]++), t3.sym_next === t3.sym_end), _tr_align: (t3) => {
      Qo(t3, 2, 3), Uo(t3, 256, Ro), ((t4) => {
        16 === t4.bi_valid ? (Jo(t4, t4.bi_buf), t4.bi_buf = 0, t4.bi_valid = 0) : t4.bi_valid >= 8 && (t4.pending_buf[t4.pending++] = 255 & t4.bi_buf, t4.bi_buf >>= 8, t4.bi_valid -= 8);
      })(t3);
    } };
    var lr = (t3, e3, s3, n3) => {
      let i3 = 65535 & t3, o3 = t3 >>> 16 & 65535, r2 = 0;
      for (; 0 !== s3; ) {
        r2 = s3 > 2e3 ? 2e3 : s3, s3 -= r2;
        do {
          i3 = i3 + e3[n3++] | 0, o3 = o3 + i3 | 0;
        } while (--r2);
        i3 %= 65521, o3 %= 65521;
      }
      return i3 | o3 << 16;
    };
    var cr = new Uint32Array((() => {
      let t3, e3 = [];
      for (var s3 = 0; s3 < 256; s3++) {
        t3 = s3;
        for (var n3 = 0; n3 < 8; n3++) t3 = 1 & t3 ? 3988292384 ^ t3 >>> 1 : t3 >>> 1;
        e3[s3] = t3;
      }
      return e3;
    })());
    var dr = (t3, e3, s3, n3) => {
      const i3 = cr, o3 = n3 + s3;
      t3 ^= -1;
      for (let s4 = n3; s4 < o3; s4++) t3 = t3 >>> 8 ^ i3[255 & (t3 ^ e3[s4])];
      return ~t3;
    };
    var hr = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    var ur = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_MEM_ERROR: -4, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    var { _tr_init: mr, _tr_stored_block: pr, _tr_flush_block: fr, _tr_tally: br, _tr_align: yr } = ar;
    var { Z_NO_FLUSH: gr, Z_PARTIAL_FLUSH: wr, Z_FULL_FLUSH: Zr, Z_FINISH: Xr, Z_BLOCK: vr, Z_OK: Lr, Z_STREAM_END: xr, Z_STREAM_ERROR: Sr, Z_DATA_ERROR: Gr, Z_BUF_ERROR: Tr, Z_DEFAULT_COMPRESSION: Wr, Z_FILTERED: Cr, Z_HUFFMAN_ONLY: kr, Z_RLE: Pr, Z_FIXED: Ir, Z_DEFAULT_STRATEGY: Rr, Z_UNKNOWN: Vr, Z_DEFLATED: Yr } = ur;
    var Mr = 258;
    var Hr = 262;
    var Kr = 42;
    var Nr = 113;
    var zr = 666;
    var _r = (t3, e3) => (t3.msg = hr[e3], e3);
    var Fr = (t3) => 2 * t3 - (t3 > 4 ? 9 : 0);
    var Er = (t3) => {
      let e3 = t3.length;
      for (; --e3 >= 0; ) t3[e3] = 0;
    };
    var jr = (t3) => {
      let e3, s3, n3, i3 = t3.w_size;
      e3 = t3.hash_size, n3 = e3;
      do {
        s3 = t3.head[--n3], t3.head[n3] = s3 >= i3 ? s3 - i3 : 0;
      } while (--e3);
      e3 = i3, n3 = e3;
      do {
        s3 = t3.prev[--n3], t3.prev[n3] = s3 >= i3 ? s3 - i3 : 0;
      } while (--e3);
    };
    var Jr = (t3, e3, s3) => (e3 << t3.hash_shift ^ s3) & t3.hash_mask;
    var Qr = (t3) => {
      const e3 = t3.state;
      let s3 = e3.pending;
      s3 > t3.avail_out && (s3 = t3.avail_out), 0 !== s3 && (t3.output.set(e3.pending_buf.subarray(e3.pending_out, e3.pending_out + s3), t3.next_out), t3.next_out += s3, e3.pending_out += s3, t3.total_out += s3, t3.avail_out -= s3, e3.pending -= s3, 0 === e3.pending && (e3.pending_out = 0));
    };
    var Ur = (t3, e3) => {
      fr(t3, t3.block_start >= 0 ? t3.block_start : -1, t3.strstart - t3.block_start, e3), t3.block_start = t3.strstart, Qr(t3.strm);
    };
    var Dr = (t3, e3) => {
      t3.pending_buf[t3.pending++] = e3;
    };
    var Or = (t3, e3) => {
      t3.pending_buf[t3.pending++] = e3 >>> 8 & 255, t3.pending_buf[t3.pending++] = 255 & e3;
    };
    var Br = (t3, e3, s3, n3) => {
      let i3 = t3.avail_in;
      return i3 > n3 && (i3 = n3), 0 === i3 ? 0 : (t3.avail_in -= i3, e3.set(t3.input.subarray(t3.next_in, t3.next_in + i3), s3), 1 === t3.state.wrap ? t3.adler = lr(t3.adler, e3, i3, s3) : 2 === t3.state.wrap && (t3.adler = dr(t3.adler, e3, i3, s3)), t3.next_in += i3, t3.total_in += i3, i3);
    };
    var Ar = (t3, e3) => {
      let s3, n3, i3 = t3.max_chain_length, o3 = t3.strstart, r2 = t3.prev_length, a3 = t3.nice_match;
      const l3 = t3.strstart > t3.w_size - Hr ? t3.strstart - (t3.w_size - Hr) : 0, c2 = t3.window, d2 = t3.w_mask, h2 = t3.prev, u2 = t3.strstart + Mr;
      let m2 = c2[o3 + r2 - 1], p2 = c2[o3 + r2];
      t3.prev_length >= t3.good_match && (i3 >>= 2), a3 > t3.lookahead && (a3 = t3.lookahead);
      do {
        if (s3 = e3, c2[s3 + r2] === p2 && c2[s3 + r2 - 1] === m2 && c2[s3] === c2[o3] && c2[++s3] === c2[o3 + 1]) {
          o3 += 2, s3++;
          do {
          } while (c2[++o3] === c2[++s3] && c2[++o3] === c2[++s3] && c2[++o3] === c2[++s3] && c2[++o3] === c2[++s3] && c2[++o3] === c2[++s3] && c2[++o3] === c2[++s3] && c2[++o3] === c2[++s3] && c2[++o3] === c2[++s3] && o3 < u2);
          if (n3 = Mr - (u2 - o3), o3 = u2 - Mr, n3 > r2) {
            if (t3.match_start = e3, r2 = n3, n3 >= a3) break;
            m2 = c2[o3 + r2 - 1], p2 = c2[o3 + r2];
          }
        }
      } while ((e3 = h2[e3 & d2]) > l3 && 0 != --i3);
      return r2 <= t3.lookahead ? r2 : t3.lookahead;
    };
    var $r = (t3) => {
      const e3 = t3.w_size;
      let s3, n3, i3;
      do {
        if (n3 = t3.window_size - t3.lookahead - t3.strstart, t3.strstart >= e3 + (e3 - Hr) && (t3.window.set(t3.window.subarray(e3, e3 + e3 - n3), 0), t3.match_start -= e3, t3.strstart -= e3, t3.block_start -= e3, t3.insert > t3.strstart && (t3.insert = t3.strstart), jr(t3), n3 += e3), 0 === t3.strm.avail_in) break;
        if (s3 = Br(t3.strm, t3.window, t3.strstart + t3.lookahead, n3), t3.lookahead += s3, t3.lookahead + t3.insert >= 3) for (i3 = t3.strstart - t3.insert, t3.ins_h = t3.window[i3], t3.ins_h = Jr(t3, t3.ins_h, t3.window[i3 + 1]); t3.insert && (t3.ins_h = Jr(t3, t3.ins_h, t3.window[i3 + 3 - 1]), t3.prev[i3 & t3.w_mask] = t3.head[t3.ins_h], t3.head[t3.ins_h] = i3, i3++, t3.insert--, !(t3.lookahead + t3.insert < 3)); ) ;
      } while (t3.lookahead < Hr && 0 !== t3.strm.avail_in);
    };
    var qr = (t3, e3) => {
      let s3, n3, i3, o3 = t3.pending_buf_size - 5 > t3.w_size ? t3.w_size : t3.pending_buf_size - 5, r2 = 0, a3 = t3.strm.avail_in;
      do {
        if (s3 = 65535, i3 = t3.bi_valid + 42 >> 3, t3.strm.avail_out < i3) break;
        if (i3 = t3.strm.avail_out - i3, n3 = t3.strstart - t3.block_start, s3 > n3 + t3.strm.avail_in && (s3 = n3 + t3.strm.avail_in), s3 > i3 && (s3 = i3), s3 < o3 && (0 === s3 && e3 !== Xr || e3 === gr || s3 !== n3 + t3.strm.avail_in)) break;
        r2 = e3 === Xr && s3 === n3 + t3.strm.avail_in ? 1 : 0, pr(t3, 0, 0, r2), t3.pending_buf[t3.pending - 4] = s3, t3.pending_buf[t3.pending - 3] = s3 >> 8, t3.pending_buf[t3.pending - 2] = ~s3, t3.pending_buf[t3.pending - 1] = ~s3 >> 8, Qr(t3.strm), n3 && (n3 > s3 && (n3 = s3), t3.strm.output.set(t3.window.subarray(t3.block_start, t3.block_start + n3), t3.strm.next_out), t3.strm.next_out += n3, t3.strm.avail_out -= n3, t3.strm.total_out += n3, t3.block_start += n3, s3 -= n3), s3 && (Br(t3.strm, t3.strm.output, t3.strm.next_out, s3), t3.strm.next_out += s3, t3.strm.avail_out -= s3, t3.strm.total_out += s3);
      } while (0 === r2);
      return a3 -= t3.strm.avail_in, a3 && (a3 >= t3.w_size ? (t3.matches = 2, t3.window.set(t3.strm.input.subarray(t3.strm.next_in - t3.w_size, t3.strm.next_in), 0), t3.strstart = t3.w_size, t3.insert = t3.strstart) : (t3.window_size - t3.strstart <= a3 && (t3.strstart -= t3.w_size, t3.window.set(t3.window.subarray(t3.w_size, t3.w_size + t3.strstart), 0), t3.matches < 2 && t3.matches++, t3.insert > t3.strstart && (t3.insert = t3.strstart)), t3.window.set(t3.strm.input.subarray(t3.strm.next_in - a3, t3.strm.next_in), t3.strstart), t3.strstart += a3, t3.insert += a3 > t3.w_size - t3.insert ? t3.w_size - t3.insert : a3), t3.block_start = t3.strstart), t3.high_water < t3.strstart && (t3.high_water = t3.strstart), r2 ? 4 : e3 !== gr && e3 !== Xr && 0 === t3.strm.avail_in && t3.strstart === t3.block_start ? 2 : (i3 = t3.window_size - t3.strstart, t3.strm.avail_in > i3 && t3.block_start >= t3.w_size && (t3.block_start -= t3.w_size, t3.strstart -= t3.w_size, t3.window.set(t3.window.subarray(t3.w_size, t3.w_size + t3.strstart), 0), t3.matches < 2 && t3.matches++, i3 += t3.w_size, t3.insert > t3.strstart && (t3.insert = t3.strstart)), i3 > t3.strm.avail_in && (i3 = t3.strm.avail_in), i3 && (Br(t3.strm, t3.window, t3.strstart, i3), t3.strstart += i3, t3.insert += i3 > t3.w_size - t3.insert ? t3.w_size - t3.insert : i3), t3.high_water < t3.strstart && (t3.high_water = t3.strstart), i3 = t3.bi_valid + 42 >> 3, i3 = t3.pending_buf_size - i3 > 65535 ? 65535 : t3.pending_buf_size - i3, o3 = i3 > t3.w_size ? t3.w_size : i3, n3 = t3.strstart - t3.block_start, (n3 >= o3 || (n3 || e3 === Xr) && e3 !== gr && 0 === t3.strm.avail_in && n3 <= i3) && (s3 = n3 > i3 ? i3 : n3, r2 = e3 === Xr && 0 === t3.strm.avail_in && s3 === n3 ? 1 : 0, pr(t3, t3.block_start, s3, r2), t3.block_start += s3, Qr(t3.strm)), r2 ? 3 : 1);
    };
    var ta = (t3, e3) => {
      let s3, n3;
      for (; ; ) {
        if (t3.lookahead < Hr) {
          if ($r(t3), t3.lookahead < Hr && e3 === gr) return 1;
          if (0 === t3.lookahead) break;
        }
        if (s3 = 0, t3.lookahead >= 3 && (t3.ins_h = Jr(t3, t3.ins_h, t3.window[t3.strstart + 3 - 1]), s3 = t3.prev[t3.strstart & t3.w_mask] = t3.head[t3.ins_h], t3.head[t3.ins_h] = t3.strstart), 0 !== s3 && t3.strstart - s3 <= t3.w_size - Hr && (t3.match_length = Ar(t3, s3)), t3.match_length >= 3) if (n3 = br(t3, t3.strstart - t3.match_start, t3.match_length - 3), t3.lookahead -= t3.match_length, t3.match_length <= t3.max_lazy_match && t3.lookahead >= 3) {
          t3.match_length--;
          do {
            t3.strstart++, t3.ins_h = Jr(t3, t3.ins_h, t3.window[t3.strstart + 3 - 1]), s3 = t3.prev[t3.strstart & t3.w_mask] = t3.head[t3.ins_h], t3.head[t3.ins_h] = t3.strstart;
          } while (0 != --t3.match_length);
          t3.strstart++;
        } else t3.strstart += t3.match_length, t3.match_length = 0, t3.ins_h = t3.window[t3.strstart], t3.ins_h = Jr(t3, t3.ins_h, t3.window[t3.strstart + 1]);
        else n3 = br(t3, 0, t3.window[t3.strstart]), t3.lookahead--, t3.strstart++;
        if (n3 && (Ur(t3, false), 0 === t3.strm.avail_out)) return 1;
      }
      return t3.insert = t3.strstart < 2 ? t3.strstart : 2, e3 === Xr ? (Ur(t3, true), 0 === t3.strm.avail_out ? 3 : 4) : t3.sym_next && (Ur(t3, false), 0 === t3.strm.avail_out) ? 1 : 2;
    };
    var ea = (t3, e3) => {
      let s3, n3, i3;
      for (; ; ) {
        if (t3.lookahead < Hr) {
          if ($r(t3), t3.lookahead < Hr && e3 === gr) return 1;
          if (0 === t3.lookahead) break;
        }
        if (s3 = 0, t3.lookahead >= 3 && (t3.ins_h = Jr(t3, t3.ins_h, t3.window[t3.strstart + 3 - 1]), s3 = t3.prev[t3.strstart & t3.w_mask] = t3.head[t3.ins_h], t3.head[t3.ins_h] = t3.strstart), t3.prev_length = t3.match_length, t3.prev_match = t3.match_start, t3.match_length = 2, 0 !== s3 && t3.prev_length < t3.max_lazy_match && t3.strstart - s3 <= t3.w_size - Hr && (t3.match_length = Ar(t3, s3), t3.match_length <= 5 && (t3.strategy === Cr || 3 === t3.match_length && t3.strstart - t3.match_start > 4096) && (t3.match_length = 2)), t3.prev_length >= 3 && t3.match_length <= t3.prev_length) {
          i3 = t3.strstart + t3.lookahead - 3, n3 = br(t3, t3.strstart - 1 - t3.prev_match, t3.prev_length - 3), t3.lookahead -= t3.prev_length - 1, t3.prev_length -= 2;
          do {
            ++t3.strstart <= i3 && (t3.ins_h = Jr(t3, t3.ins_h, t3.window[t3.strstart + 3 - 1]), s3 = t3.prev[t3.strstart & t3.w_mask] = t3.head[t3.ins_h], t3.head[t3.ins_h] = t3.strstart);
          } while (0 != --t3.prev_length);
          if (t3.match_available = 0, t3.match_length = 2, t3.strstart++, n3 && (Ur(t3, false), 0 === t3.strm.avail_out)) return 1;
        } else if (t3.match_available) {
          if (n3 = br(t3, 0, t3.window[t3.strstart - 1]), n3 && Ur(t3, false), t3.strstart++, t3.lookahead--, 0 === t3.strm.avail_out) return 1;
        } else t3.match_available = 1, t3.strstart++, t3.lookahead--;
      }
      return t3.match_available && (n3 = br(t3, 0, t3.window[t3.strstart - 1]), t3.match_available = 0), t3.insert = t3.strstart < 2 ? t3.strstart : 2, e3 === Xr ? (Ur(t3, true), 0 === t3.strm.avail_out ? 3 : 4) : t3.sym_next && (Ur(t3, false), 0 === t3.strm.avail_out) ? 1 : 2;
    };
    function sa(t3, e3, s3, n3, i3) {
      this.good_length = t3, this.max_lazy = e3, this.nice_length = s3, this.max_chain = n3, this.func = i3;
    }
    var na = [new sa(0, 0, 0, 0, qr), new sa(4, 4, 8, 4, ta), new sa(4, 5, 16, 8, ta), new sa(4, 6, 32, 32, ta), new sa(4, 4, 16, 16, ea), new sa(8, 16, 32, 32, ea), new sa(8, 16, 128, 128, ea), new sa(8, 32, 128, 256, ea), new sa(32, 128, 258, 1024, ea), new sa(32, 258, 258, 4096, ea)];
    function ia() {
      this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Yr, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(1146), this.dyn_dtree = new Uint16Array(122), this.bl_tree = new Uint16Array(78), Er(this.dyn_ltree), Er(this.dyn_dtree), Er(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(16), this.heap = new Uint16Array(573), Er(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(573), Er(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
    }
    var oa = (t3) => {
      if (!t3) return 1;
      const e3 = t3.state;
      return !e3 || e3.strm !== t3 || e3.status !== Kr && 57 !== e3.status && 69 !== e3.status && 73 !== e3.status && 91 !== e3.status && 103 !== e3.status && e3.status !== Nr && e3.status !== zr ? 1 : 0;
    };
    var ra = (t3) => {
      if (oa(t3)) return _r(t3, Sr);
      t3.total_in = t3.total_out = 0, t3.data_type = Vr;
      const e3 = t3.state;
      return e3.pending = 0, e3.pending_out = 0, e3.wrap < 0 && (e3.wrap = -e3.wrap), e3.status = 2 === e3.wrap ? 57 : e3.wrap ? Kr : Nr, t3.adler = 2 === e3.wrap ? 0 : 1, e3.last_flush = -2, mr(e3), Lr;
    };
    var aa = (t3) => {
      const e3 = ra(t3);
      var s3;
      return e3 === Lr && ((s3 = t3.state).window_size = 2 * s3.w_size, Er(s3.head), s3.max_lazy_match = na[s3.level].max_lazy, s3.good_match = na[s3.level].good_length, s3.nice_match = na[s3.level].nice_length, s3.max_chain_length = na[s3.level].max_chain, s3.strstart = 0, s3.block_start = 0, s3.lookahead = 0, s3.insert = 0, s3.match_length = s3.prev_length = 2, s3.match_available = 0, s3.ins_h = 0), e3;
    };
    var la = (t3, e3, s3, n3, i3, o3) => {
      if (!t3) return Sr;
      let r2 = 1;
      if (e3 === Wr && (e3 = 6), n3 < 0 ? (r2 = 0, n3 = -n3) : n3 > 15 && (r2 = 2, n3 -= 16), i3 < 1 || i3 > 9 || s3 !== Yr || n3 < 8 || n3 > 15 || e3 < 0 || e3 > 9 || o3 < 0 || o3 > Ir || 8 === n3 && 1 !== r2) return _r(t3, Sr);
      8 === n3 && (n3 = 9);
      const a3 = new ia();
      return t3.state = a3, a3.strm = t3, a3.status = Kr, a3.wrap = r2, a3.gzhead = null, a3.w_bits = n3, a3.w_size = 1 << a3.w_bits, a3.w_mask = a3.w_size - 1, a3.hash_bits = i3 + 7, a3.hash_size = 1 << a3.hash_bits, a3.hash_mask = a3.hash_size - 1, a3.hash_shift = ~~((a3.hash_bits + 3 - 1) / 3), a3.window = new Uint8Array(2 * a3.w_size), a3.head = new Uint16Array(a3.hash_size), a3.prev = new Uint16Array(a3.w_size), a3.lit_bufsize = 1 << i3 + 6, a3.pending_buf_size = 4 * a3.lit_bufsize, a3.pending_buf = new Uint8Array(a3.pending_buf_size), a3.sym_buf = a3.lit_bufsize, a3.sym_end = 3 * (a3.lit_bufsize - 1), a3.level = e3, a3.strategy = o3, a3.method = s3, aa(t3);
    };
    var ca = (t3, e3) => {
      if (oa(t3) || e3 > vr || e3 < 0) return t3 ? _r(t3, Sr) : Sr;
      const s3 = t3.state;
      if (!t3.output || 0 !== t3.avail_in && !t3.input || s3.status === zr && e3 !== Xr) return _r(t3, 0 === t3.avail_out ? Tr : Sr);
      const n3 = s3.last_flush;
      if (s3.last_flush = e3, 0 !== s3.pending) {
        if (Qr(t3), 0 === t3.avail_out) return s3.last_flush = -1, Lr;
      } else if (0 === t3.avail_in && Fr(e3) <= Fr(n3) && e3 !== Xr) return _r(t3, Tr);
      if (s3.status === zr && 0 !== t3.avail_in) return _r(t3, Tr);
      if (s3.status === Kr && 0 === s3.wrap && (s3.status = Nr), s3.status === Kr) {
        let e4 = Yr + (s3.w_bits - 8 << 4) << 8, n4 = -1;
        if (n4 = s3.strategy >= kr || s3.level < 2 ? 0 : s3.level < 6 ? 1 : 6 === s3.level ? 2 : 3, e4 |= n4 << 6, 0 !== s3.strstart && (e4 |= 32), e4 += 31 - e4 % 31, Or(s3, e4), 0 !== s3.strstart && (Or(s3, t3.adler >>> 16), Or(s3, 65535 & t3.adler)), t3.adler = 1, s3.status = Nr, Qr(t3), 0 !== s3.pending) return s3.last_flush = -1, Lr;
      }
      if (57 === s3.status) {
        if (t3.adler = 0, Dr(s3, 31), Dr(s3, 139), Dr(s3, 8), s3.gzhead) Dr(s3, (s3.gzhead.text ? 1 : 0) + (s3.gzhead.hcrc ? 2 : 0) + (s3.gzhead.extra ? 4 : 0) + (s3.gzhead.name ? 8 : 0) + (s3.gzhead.comment ? 16 : 0)), Dr(s3, 255 & s3.gzhead.time), Dr(s3, s3.gzhead.time >> 8 & 255), Dr(s3, s3.gzhead.time >> 16 & 255), Dr(s3, s3.gzhead.time >> 24 & 255), Dr(s3, 9 === s3.level ? 2 : s3.strategy >= kr || s3.level < 2 ? 4 : 0), Dr(s3, 255 & s3.gzhead.os), s3.gzhead.extra && s3.gzhead.extra.length && (Dr(s3, 255 & s3.gzhead.extra.length), Dr(s3, s3.gzhead.extra.length >> 8 & 255)), s3.gzhead.hcrc && (t3.adler = dr(t3.adler, s3.pending_buf, s3.pending, 0)), s3.gzindex = 0, s3.status = 69;
        else if (Dr(s3, 0), Dr(s3, 0), Dr(s3, 0), Dr(s3, 0), Dr(s3, 0), Dr(s3, 9 === s3.level ? 2 : s3.strategy >= kr || s3.level < 2 ? 4 : 0), Dr(s3, 3), s3.status = Nr, Qr(t3), 0 !== s3.pending) return s3.last_flush = -1, Lr;
      }
      if (69 === s3.status) {
        if (s3.gzhead.extra) {
          let e4 = s3.pending, n4 = (65535 & s3.gzhead.extra.length) - s3.gzindex;
          for (; s3.pending + n4 > s3.pending_buf_size; ) {
            let i4 = s3.pending_buf_size - s3.pending;
            if (s3.pending_buf.set(s3.gzhead.extra.subarray(s3.gzindex, s3.gzindex + i4), s3.pending), s3.pending = s3.pending_buf_size, s3.gzhead.hcrc && s3.pending > e4 && (t3.adler = dr(t3.adler, s3.pending_buf, s3.pending - e4, e4)), s3.gzindex += i4, Qr(t3), 0 !== s3.pending) return s3.last_flush = -1, Lr;
            e4 = 0, n4 -= i4;
          }
          let i3 = new Uint8Array(s3.gzhead.extra);
          s3.pending_buf.set(i3.subarray(s3.gzindex, s3.gzindex + n4), s3.pending), s3.pending += n4, s3.gzhead.hcrc && s3.pending > e4 && (t3.adler = dr(t3.adler, s3.pending_buf, s3.pending - e4, e4)), s3.gzindex = 0;
        }
        s3.status = 73;
      }
      if (73 === s3.status) {
        if (s3.gzhead.name) {
          let e4, n4 = s3.pending;
          do {
            if (s3.pending === s3.pending_buf_size) {
              if (s3.gzhead.hcrc && s3.pending > n4 && (t3.adler = dr(t3.adler, s3.pending_buf, s3.pending - n4, n4)), Qr(t3), 0 !== s3.pending) return s3.last_flush = -1, Lr;
              n4 = 0;
            }
            e4 = s3.gzindex < s3.gzhead.name.length ? 255 & s3.gzhead.name.charCodeAt(s3.gzindex++) : 0, Dr(s3, e4);
          } while (0 !== e4);
          s3.gzhead.hcrc && s3.pending > n4 && (t3.adler = dr(t3.adler, s3.pending_buf, s3.pending - n4, n4)), s3.gzindex = 0;
        }
        s3.status = 91;
      }
      if (91 === s3.status) {
        if (s3.gzhead.comment) {
          let e4, n4 = s3.pending;
          do {
            if (s3.pending === s3.pending_buf_size) {
              if (s3.gzhead.hcrc && s3.pending > n4 && (t3.adler = dr(t3.adler, s3.pending_buf, s3.pending - n4, n4)), Qr(t3), 0 !== s3.pending) return s3.last_flush = -1, Lr;
              n4 = 0;
            }
            e4 = s3.gzindex < s3.gzhead.comment.length ? 255 & s3.gzhead.comment.charCodeAt(s3.gzindex++) : 0, Dr(s3, e4);
          } while (0 !== e4);
          s3.gzhead.hcrc && s3.pending > n4 && (t3.adler = dr(t3.adler, s3.pending_buf, s3.pending - n4, n4));
        }
        s3.status = 103;
      }
      if (103 === s3.status) {
        if (s3.gzhead.hcrc) {
          if (s3.pending + 2 > s3.pending_buf_size && (Qr(t3), 0 !== s3.pending)) return s3.last_flush = -1, Lr;
          Dr(s3, 255 & t3.adler), Dr(s3, t3.adler >> 8 & 255), t3.adler = 0;
        }
        if (s3.status = Nr, Qr(t3), 0 !== s3.pending) return s3.last_flush = -1, Lr;
      }
      if (0 !== t3.avail_in || 0 !== s3.lookahead || e3 !== gr && s3.status !== zr) {
        let n4 = 0 === s3.level ? qr(s3, e3) : s3.strategy === kr ? ((t4, e4) => {
          let s4;
          for (; ; ) {
            if (0 === t4.lookahead && ($r(t4), 0 === t4.lookahead)) {
              if (e4 === gr) return 1;
              break;
            }
            if (t4.match_length = 0, s4 = br(t4, 0, t4.window[t4.strstart]), t4.lookahead--, t4.strstart++, s4 && (Ur(t4, false), 0 === t4.strm.avail_out)) return 1;
          }
          return t4.insert = 0, e4 === Xr ? (Ur(t4, true), 0 === t4.strm.avail_out ? 3 : 4) : t4.sym_next && (Ur(t4, false), 0 === t4.strm.avail_out) ? 1 : 2;
        })(s3, e3) : s3.strategy === Pr ? ((t4, e4) => {
          let s4, n5, i3, o3;
          const r2 = t4.window;
          for (; ; ) {
            if (t4.lookahead <= Mr) {
              if ($r(t4), t4.lookahead <= Mr && e4 === gr) return 1;
              if (0 === t4.lookahead) break;
            }
            if (t4.match_length = 0, t4.lookahead >= 3 && t4.strstart > 0 && (i3 = t4.strstart - 1, n5 = r2[i3], n5 === r2[++i3] && n5 === r2[++i3] && n5 === r2[++i3])) {
              o3 = t4.strstart + Mr;
              do {
              } while (n5 === r2[++i3] && n5 === r2[++i3] && n5 === r2[++i3] && n5 === r2[++i3] && n5 === r2[++i3] && n5 === r2[++i3] && n5 === r2[++i3] && n5 === r2[++i3] && i3 < o3);
              t4.match_length = Mr - (o3 - i3), t4.match_length > t4.lookahead && (t4.match_length = t4.lookahead);
            }
            if (t4.match_length >= 3 ? (s4 = br(t4, 1, t4.match_length - 3), t4.lookahead -= t4.match_length, t4.strstart += t4.match_length, t4.match_length = 0) : (s4 = br(t4, 0, t4.window[t4.strstart]), t4.lookahead--, t4.strstart++), s4 && (Ur(t4, false), 0 === t4.strm.avail_out)) return 1;
          }
          return t4.insert = 0, e4 === Xr ? (Ur(t4, true), 0 === t4.strm.avail_out ? 3 : 4) : t4.sym_next && (Ur(t4, false), 0 === t4.strm.avail_out) ? 1 : 2;
        })(s3, e3) : na[s3.level].func(s3, e3);
        if (3 !== n4 && 4 !== n4 || (s3.status = zr), 1 === n4 || 3 === n4) return 0 === t3.avail_out && (s3.last_flush = -1), Lr;
        if (2 === n4 && (e3 === wr ? yr(s3) : e3 !== vr && (pr(s3, 0, 0, false), e3 === Zr && (Er(s3.head), 0 === s3.lookahead && (s3.strstart = 0, s3.block_start = 0, s3.insert = 0))), Qr(t3), 0 === t3.avail_out)) return s3.last_flush = -1, Lr;
      }
      return e3 !== Xr ? Lr : s3.wrap <= 0 ? xr : (2 === s3.wrap ? (Dr(s3, 255 & t3.adler), Dr(s3, t3.adler >> 8 & 255), Dr(s3, t3.adler >> 16 & 255), Dr(s3, t3.adler >> 24 & 255), Dr(s3, 255 & t3.total_in), Dr(s3, t3.total_in >> 8 & 255), Dr(s3, t3.total_in >> 16 & 255), Dr(s3, t3.total_in >> 24 & 255)) : (Or(s3, t3.adler >>> 16), Or(s3, 65535 & t3.adler)), Qr(t3), s3.wrap > 0 && (s3.wrap = -s3.wrap), 0 !== s3.pending ? Lr : xr);
    };
    var da = { deflateInit: (t3, e3) => la(t3, e3, Yr, 15, 8, Rr), deflateInit2: la, deflateReset: aa, deflateResetKeep: ra, deflateSetHeader: (t3, e3) => oa(t3) || 2 !== t3.state.wrap ? Sr : (t3.state.gzhead = e3, Lr), deflate: ca, deflateEnd: (t3) => {
      if (oa(t3)) return Sr;
      const e3 = t3.state.status;
      return t3.state = null, e3 === Nr ? _r(t3, Gr) : Lr;
    }, deflateSetDictionary: (t3, e3) => {
      let s3 = e3.length;
      if (oa(t3)) return Sr;
      const n3 = t3.state, i3 = n3.wrap;
      if (2 === i3 || 1 === i3 && n3.status !== Kr || n3.lookahead) return Sr;
      if (1 === i3 && (t3.adler = lr(t3.adler, e3, s3, 0)), n3.wrap = 0, s3 >= n3.w_size) {
        0 === i3 && (Er(n3.head), n3.strstart = 0, n3.block_start = 0, n3.insert = 0);
        let t4 = new Uint8Array(n3.w_size);
        t4.set(e3.subarray(s3 - n3.w_size, s3), 0), e3 = t4, s3 = n3.w_size;
      }
      const o3 = t3.avail_in, r2 = t3.next_in, a3 = t3.input;
      for (t3.avail_in = s3, t3.next_in = 0, t3.input = e3, $r(n3); n3.lookahead >= 3; ) {
        let t4 = n3.strstart, e4 = n3.lookahead - 2;
        do {
          n3.ins_h = Jr(n3, n3.ins_h, n3.window[t4 + 3 - 1]), n3.prev[t4 & n3.w_mask] = n3.head[n3.ins_h], n3.head[n3.ins_h] = t4, t4++;
        } while (--e4);
        n3.strstart = t4, n3.lookahead = 2, $r(n3);
      }
      return n3.strstart += n3.lookahead, n3.block_start = n3.strstart, n3.insert = n3.lookahead, n3.lookahead = 0, n3.match_length = n3.prev_length = 2, n3.match_available = 0, t3.next_in = r2, t3.input = a3, t3.avail_in = o3, n3.wrap = i3, Lr;
    }, deflateInfo: "pako deflate (from Nodeca project)" };
    var ha = (t3, e3) => Object.prototype.hasOwnProperty.call(t3, e3);
    var ua = function(t3) {
      const e3 = Array.prototype.slice.call(arguments, 1);
      for (; e3.length; ) {
        const s3 = e3.shift();
        if (s3) {
          if ("object" != typeof s3) throw new TypeError(s3 + "must be non-object");
          for (const e4 in s3) ha(s3, e4) && (t3[e4] = s3[e4]);
        }
      }
      return t3;
    };
    var ma = (t3) => {
      let e3 = 0;
      for (let s4 = 0, n3 = t3.length; s4 < n3; s4++) e3 += t3[s4].length;
      const s3 = new Uint8Array(e3);
      for (let e4 = 0, n3 = 0, i3 = t3.length; e4 < i3; e4++) {
        let i4 = t3[e4];
        s3.set(i4, n3), n3 += i4.length;
      }
      return s3;
    };
    var pa = true;
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (t3) {
      pa = false;
    }
    var fa = new Uint8Array(256);
    for (let t3 = 0; t3 < 256; t3++) fa[t3] = t3 >= 252 ? 6 : t3 >= 248 ? 5 : t3 >= 240 ? 4 : t3 >= 224 ? 3 : t3 >= 192 ? 2 : 1;
    fa[254] = fa[254] = 1;
    var ba = (t3) => {
      if ("function" == typeof TextEncoder && TextEncoder.prototype.encode) return new TextEncoder().encode(t3);
      let e3, s3, n3, i3, o3, r2 = t3.length, a3 = 0;
      for (i3 = 0; i3 < r2; i3++) s3 = t3.charCodeAt(i3), 55296 == (64512 & s3) && i3 + 1 < r2 && (n3 = t3.charCodeAt(i3 + 1), 56320 == (64512 & n3) && (s3 = 65536 + (s3 - 55296 << 10) + (n3 - 56320), i3++)), a3 += s3 < 128 ? 1 : s3 < 2048 ? 2 : s3 < 65536 ? 3 : 4;
      for (e3 = new Uint8Array(a3), o3 = 0, i3 = 0; o3 < a3; i3++) s3 = t3.charCodeAt(i3), 55296 == (64512 & s3) && i3 + 1 < r2 && (n3 = t3.charCodeAt(i3 + 1), 56320 == (64512 & n3) && (s3 = 65536 + (s3 - 55296 << 10) + (n3 - 56320), i3++)), s3 < 128 ? e3[o3++] = s3 : s3 < 2048 ? (e3[o3++] = 192 | s3 >>> 6, e3[o3++] = 128 | 63 & s3) : s3 < 65536 ? (e3[o3++] = 224 | s3 >>> 12, e3[o3++] = 128 | s3 >>> 6 & 63, e3[o3++] = 128 | 63 & s3) : (e3[o3++] = 240 | s3 >>> 18, e3[o3++] = 128 | s3 >>> 12 & 63, e3[o3++] = 128 | s3 >>> 6 & 63, e3[o3++] = 128 | 63 & s3);
      return e3;
    };
    var ya = (t3, e3) => {
      const s3 = e3 || t3.length;
      if ("function" == typeof TextDecoder && TextDecoder.prototype.decode) return new TextDecoder().decode(t3.subarray(0, e3));
      let n3, i3;
      const o3 = new Array(2 * s3);
      for (i3 = 0, n3 = 0; n3 < s3; ) {
        let e4 = t3[n3++];
        if (e4 < 128) {
          o3[i3++] = e4;
          continue;
        }
        let r2 = fa[e4];
        if (r2 > 4) o3[i3++] = 65533, n3 += r2 - 1;
        else {
          for (e4 &= 2 === r2 ? 31 : 3 === r2 ? 15 : 7; r2 > 1 && n3 < s3; ) e4 = e4 << 6 | 63 & t3[n3++], r2--;
          r2 > 1 ? o3[i3++] = 65533 : e4 < 65536 ? o3[i3++] = e4 : (e4 -= 65536, o3[i3++] = 55296 | e4 >> 10 & 1023, o3[i3++] = 56320 | 1023 & e4);
        }
      }
      return ((t4, e4) => {
        if (e4 < 65534 && t4.subarray && pa) return String.fromCharCode.apply(null, t4.length === e4 ? t4 : t4.subarray(0, e4));
        let s4 = "";
        for (let n4 = 0; n4 < e4; n4++) s4 += String.fromCharCode(t4[n4]);
        return s4;
      })(o3, i3);
    };
    var ga = (t3, e3) => {
      (e3 = e3 || t3.length) > t3.length && (e3 = t3.length);
      let s3 = e3 - 1;
      for (; s3 >= 0 && 128 == (192 & t3[s3]); ) s3--;
      return s3 < 0 || 0 === s3 ? e3 : s3 + fa[t3[s3]] > e3 ? s3 : e3;
    };
    var wa = function() {
      this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
    };
    var Za = Object.prototype.toString;
    var { Z_NO_FLUSH: Xa, Z_SYNC_FLUSH: va, Z_FULL_FLUSH: La, Z_FINISH: xa, Z_OK: Sa, Z_STREAM_END: Ga, Z_DEFAULT_COMPRESSION: Ta, Z_DEFAULT_STRATEGY: Wa, Z_DEFLATED: Ca } = ur;
    function ka(t3) {
      this.options = ua({ level: Ta, method: Ca, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: Wa }, t3 || {});
      let e3 = this.options;
      e3.raw && e3.windowBits > 0 ? e3.windowBits = -e3.windowBits : e3.gzip && e3.windowBits > 0 && e3.windowBits < 16 && (e3.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new wa(), this.strm.avail_out = 0;
      let s3 = da.deflateInit2(this.strm, e3.level, e3.method, e3.windowBits, e3.memLevel, e3.strategy);
      if (s3 !== Sa) throw new Error(hr[s3]);
      if (e3.header && da.deflateSetHeader(this.strm, e3.header), e3.dictionary) {
        let t4;
        if (t4 = "string" == typeof e3.dictionary ? ba(e3.dictionary) : "[object ArrayBuffer]" === Za.call(e3.dictionary) ? new Uint8Array(e3.dictionary) : e3.dictionary, s3 = da.deflateSetDictionary(this.strm, t4), s3 !== Sa) throw new Error(hr[s3]);
        this._dict_set = true;
      }
    }
    function Pa(t3, e3) {
      const s3 = new ka(e3);
      if (s3.push(t3, true), s3.err) throw s3.msg || hr[s3.err];
      return s3.result;
    }
    ka.prototype.push = function(t3, e3) {
      const s3 = this.strm, n3 = this.options.chunkSize;
      let i3, o3;
      if (this.ended) return false;
      for (o3 = e3 === ~~e3 ? e3 : true === e3 ? xa : Xa, "string" == typeof t3 ? s3.input = ba(t3) : "[object ArrayBuffer]" === Za.call(t3) ? s3.input = new Uint8Array(t3) : s3.input = t3, s3.next_in = 0, s3.avail_in = s3.input.length; ; ) if (0 === s3.avail_out && (s3.output = new Uint8Array(n3), s3.next_out = 0, s3.avail_out = n3), (o3 === va || o3 === La) && s3.avail_out <= 6) this.onData(s3.output.subarray(0, s3.next_out)), s3.avail_out = 0;
      else {
        if (i3 = da.deflate(s3, o3), i3 === Ga) return s3.next_out > 0 && this.onData(s3.output.subarray(0, s3.next_out)), i3 = da.deflateEnd(this.strm), this.onEnd(i3), this.ended = true, i3 === Sa;
        if (0 !== s3.avail_out) {
          if (o3 > 0 && s3.next_out > 0) this.onData(s3.output.subarray(0, s3.next_out)), s3.avail_out = 0;
          else if (0 === s3.avail_in) break;
        } else this.onData(s3.output);
      }
      return true;
    }, ka.prototype.onData = function(t3) {
      this.chunks.push(t3);
    }, ka.prototype.onEnd = function(t3) {
      t3 === Sa && (this.result = ma(this.chunks)), this.chunks = [], this.err = t3, this.msg = this.strm.msg;
    };
    var Ia = { Deflate: ka, deflate: Pa, deflateRaw: function(t3, e3) {
      return (e3 = e3 || {}).raw = true, Pa(t3, e3);
    }, gzip: function(t3, e3) {
      return (e3 = e3 || {}).gzip = true, Pa(t3, e3);
    } };
    var Ra = 16209;
    var Va = function(t3, e3) {
      let s3, n3, i3, o3, r2, a3, l3, c2, d2, h2, u2, m2, p2, f2, b2, y2, g2, w2, Z2, X2, v2, L2, x2, S2;
      const G2 = t3.state;
      s3 = t3.next_in, x2 = t3.input, n3 = s3 + (t3.avail_in - 5), i3 = t3.next_out, S2 = t3.output, o3 = i3 - (e3 - t3.avail_out), r2 = i3 + (t3.avail_out - 257), a3 = G2.dmax, l3 = G2.wsize, c2 = G2.whave, d2 = G2.wnext, h2 = G2.window, u2 = G2.hold, m2 = G2.bits, p2 = G2.lencode, f2 = G2.distcode, b2 = (1 << G2.lenbits) - 1, y2 = (1 << G2.distbits) - 1;
      t: do {
        m2 < 15 && (u2 += x2[s3++] << m2, m2 += 8, u2 += x2[s3++] << m2, m2 += 8), g2 = p2[u2 & b2];
        e: for (; ; ) {
          if (w2 = g2 >>> 24, u2 >>>= w2, m2 -= w2, w2 = g2 >>> 16 & 255, 0 === w2) S2[i3++] = 65535 & g2;
          else {
            if (!(16 & w2)) {
              if (64 & w2) {
                if (32 & w2) {
                  G2.mode = 16191;
                  break t;
                }
                t3.msg = "invalid literal/length code", G2.mode = Ra;
                break t;
              }
              g2 = p2[(65535 & g2) + (u2 & (1 << w2) - 1)];
              continue e;
            }
            for (Z2 = 65535 & g2, w2 &= 15, w2 && (m2 < w2 && (u2 += x2[s3++] << m2, m2 += 8), Z2 += u2 & (1 << w2) - 1, u2 >>>= w2, m2 -= w2), m2 < 15 && (u2 += x2[s3++] << m2, m2 += 8, u2 += x2[s3++] << m2, m2 += 8), g2 = f2[u2 & y2]; ; ) {
              if (w2 = g2 >>> 24, u2 >>>= w2, m2 -= w2, w2 = g2 >>> 16 & 255, 16 & w2) {
                if (X2 = 65535 & g2, w2 &= 15, m2 < w2 && (u2 += x2[s3++] << m2, m2 += 8, m2 < w2 && (u2 += x2[s3++] << m2, m2 += 8)), X2 += u2 & (1 << w2) - 1, X2 > a3) {
                  t3.msg = "invalid distance too far back", G2.mode = Ra;
                  break t;
                }
                if (u2 >>>= w2, m2 -= w2, w2 = i3 - o3, X2 > w2) {
                  if (w2 = X2 - w2, w2 > c2 && G2.sane) {
                    t3.msg = "invalid distance too far back", G2.mode = Ra;
                    break t;
                  }
                  if (v2 = 0, L2 = h2, 0 === d2) {
                    if (v2 += l3 - w2, w2 < Z2) {
                      Z2 -= w2;
                      do {
                        S2[i3++] = h2[v2++];
                      } while (--w2);
                      v2 = i3 - X2, L2 = S2;
                    }
                  } else if (d2 < w2) {
                    if (v2 += l3 + d2 - w2, w2 -= d2, w2 < Z2) {
                      Z2 -= w2;
                      do {
                        S2[i3++] = h2[v2++];
                      } while (--w2);
                      if (v2 = 0, d2 < Z2) {
                        w2 = d2, Z2 -= w2;
                        do {
                          S2[i3++] = h2[v2++];
                        } while (--w2);
                        v2 = i3 - X2, L2 = S2;
                      }
                    }
                  } else if (v2 += d2 - w2, w2 < Z2) {
                    Z2 -= w2;
                    do {
                      S2[i3++] = h2[v2++];
                    } while (--w2);
                    v2 = i3 - X2, L2 = S2;
                  }
                  for (; Z2 > 2; ) S2[i3++] = L2[v2++], S2[i3++] = L2[v2++], S2[i3++] = L2[v2++], Z2 -= 3;
                  Z2 && (S2[i3++] = L2[v2++], Z2 > 1 && (S2[i3++] = L2[v2++]));
                } else {
                  v2 = i3 - X2;
                  do {
                    S2[i3++] = S2[v2++], S2[i3++] = S2[v2++], S2[i3++] = S2[v2++], Z2 -= 3;
                  } while (Z2 > 2);
                  Z2 && (S2[i3++] = S2[v2++], Z2 > 1 && (S2[i3++] = S2[v2++]));
                }
                break;
              }
              if (64 & w2) {
                t3.msg = "invalid distance code", G2.mode = Ra;
                break t;
              }
              g2 = f2[(65535 & g2) + (u2 & (1 << w2) - 1)];
            }
          }
          break;
        }
      } while (s3 < n3 && i3 < r2);
      Z2 = m2 >> 3, s3 -= Z2, m2 -= Z2 << 3, u2 &= (1 << m2) - 1, t3.next_in = s3, t3.next_out = i3, t3.avail_in = s3 < n3 ? n3 - s3 + 5 : 5 - (s3 - n3), t3.avail_out = i3 < r2 ? r2 - i3 + 257 : 257 - (i3 - r2), G2.hold = u2, G2.bits = m2;
    };
    var Ya = 15;
    var Ma = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]);
    var Ha = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]);
    var Ka = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]);
    var Na = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
    var za = (t3, e3, s3, n3, i3, o3, r2, a3) => {
      const l3 = a3.bits;
      let c2, d2, h2, u2, m2, p2, f2 = 0, b2 = 0, y2 = 0, g2 = 0, w2 = 0, Z2 = 0, X2 = 0, v2 = 0, L2 = 0, x2 = 0, S2 = null;
      const G2 = new Uint16Array(16), T2 = new Uint16Array(16);
      let W2, C2, k2, P2 = null;
      for (f2 = 0; f2 <= Ya; f2++) G2[f2] = 0;
      for (b2 = 0; b2 < n3; b2++) G2[e3[s3 + b2]]++;
      for (w2 = l3, g2 = Ya; g2 >= 1 && 0 === G2[g2]; g2--) ;
      if (w2 > g2 && (w2 = g2), 0 === g2) return i3[o3++] = 20971520, i3[o3++] = 20971520, a3.bits = 1, 0;
      for (y2 = 1; y2 < g2 && 0 === G2[y2]; y2++) ;
      for (w2 < y2 && (w2 = y2), v2 = 1, f2 = 1; f2 <= Ya; f2++) if (v2 <<= 1, v2 -= G2[f2], v2 < 0) return -1;
      if (v2 > 0 && (0 === t3 || 1 !== g2)) return -1;
      for (T2[1] = 0, f2 = 1; f2 < Ya; f2++) T2[f2 + 1] = T2[f2] + G2[f2];
      for (b2 = 0; b2 < n3; b2++) 0 !== e3[s3 + b2] && (r2[T2[e3[s3 + b2]]++] = b2);
      if (0 === t3 ? (S2 = P2 = r2, p2 = 20) : 1 === t3 ? (S2 = Ma, P2 = Ha, p2 = 257) : (S2 = Ka, P2 = Na, p2 = 0), x2 = 0, b2 = 0, f2 = y2, m2 = o3, Z2 = w2, X2 = 0, h2 = -1, L2 = 1 << w2, u2 = L2 - 1, 1 === t3 && L2 > 852 || 2 === t3 && L2 > 592) return 1;
      for (; ; ) {
        W2 = f2 - X2, r2[b2] + 1 < p2 ? (C2 = 0, k2 = r2[b2]) : r2[b2] >= p2 ? (C2 = P2[r2[b2] - p2], k2 = S2[r2[b2] - p2]) : (C2 = 96, k2 = 0), c2 = 1 << f2 - X2, d2 = 1 << Z2, y2 = d2;
        do {
          d2 -= c2, i3[m2 + (x2 >> X2) + d2] = W2 << 24 | C2 << 16 | k2;
        } while (0 !== d2);
        for (c2 = 1 << f2 - 1; x2 & c2; ) c2 >>= 1;
        if (0 !== c2 ? (x2 &= c2 - 1, x2 += c2) : x2 = 0, b2++, 0 == --G2[f2]) {
          if (f2 === g2) break;
          f2 = e3[s3 + r2[b2]];
        }
        if (f2 > w2 && (x2 & u2) !== h2) {
          for (0 === X2 && (X2 = w2), m2 += y2, Z2 = f2 - X2, v2 = 1 << Z2; Z2 + X2 < g2 && (v2 -= G2[Z2 + X2], !(v2 <= 0)); ) Z2++, v2 <<= 1;
          if (L2 += 1 << Z2, 1 === t3 && L2 > 852 || 2 === t3 && L2 > 592) return 1;
          h2 = x2 & u2, i3[h2] = w2 << 24 | Z2 << 16 | m2 - o3;
        }
      }
      return 0 !== x2 && (i3[m2 + x2] = f2 - X2 << 24 | 64 << 16), a3.bits = w2, 0;
    };
    var { Z_FINISH: _a, Z_BLOCK: Fa, Z_TREES: Ea, Z_OK: ja, Z_STREAM_END: Ja, Z_NEED_DICT: Qa, Z_STREAM_ERROR: Ua, Z_DATA_ERROR: Da, Z_MEM_ERROR: Oa, Z_BUF_ERROR: Ba, Z_DEFLATED: Aa } = ur;
    var $a = 16180;
    var qa = 16190;
    var tl = 16191;
    var el = 16192;
    var sl = 16194;
    var nl = 16199;
    var il = 16200;
    var ol = 16206;
    var rl = 16209;
    var al = (t3) => (t3 >>> 24 & 255) + (t3 >>> 8 & 65280) + ((65280 & t3) << 8) + ((255 & t3) << 24);
    function ll() {
      this.strm = null, this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
    }
    var cl = (t3) => {
      if (!t3) return 1;
      const e3 = t3.state;
      return !e3 || e3.strm !== t3 || e3.mode < $a || e3.mode > 16211 ? 1 : 0;
    };
    var dl = (t3) => {
      if (cl(t3)) return Ua;
      const e3 = t3.state;
      return t3.total_in = t3.total_out = e3.total = 0, t3.msg = "", e3.wrap && (t3.adler = 1 & e3.wrap), e3.mode = $a, e3.last = 0, e3.havedict = 0, e3.flags = -1, e3.dmax = 32768, e3.head = null, e3.hold = 0, e3.bits = 0, e3.lencode = e3.lendyn = new Int32Array(852), e3.distcode = e3.distdyn = new Int32Array(592), e3.sane = 1, e3.back = -1, ja;
    };
    var hl = (t3) => {
      if (cl(t3)) return Ua;
      const e3 = t3.state;
      return e3.wsize = 0, e3.whave = 0, e3.wnext = 0, dl(t3);
    };
    var ul = (t3, e3) => {
      let s3;
      if (cl(t3)) return Ua;
      const n3 = t3.state;
      return e3 < 0 ? (s3 = 0, e3 = -e3) : (s3 = 5 + (e3 >> 4), e3 < 48 && (e3 &= 15)), e3 && (e3 < 8 || e3 > 15) ? Ua : (null !== n3.window && n3.wbits !== e3 && (n3.window = null), n3.wrap = s3, n3.wbits = e3, hl(t3));
    };
    var ml = (t3, e3) => {
      if (!t3) return Ua;
      const s3 = new ll();
      t3.state = s3, s3.strm = t3, s3.window = null, s3.mode = $a;
      const n3 = ul(t3, e3);
      return n3 !== ja && (t3.state = null), n3;
    };
    var pl;
    var fl;
    var bl = true;
    var yl = (t3) => {
      if (bl) {
        pl = new Int32Array(512), fl = new Int32Array(32);
        let e3 = 0;
        for (; e3 < 144; ) t3.lens[e3++] = 8;
        for (; e3 < 256; ) t3.lens[e3++] = 9;
        for (; e3 < 280; ) t3.lens[e3++] = 7;
        for (; e3 < 288; ) t3.lens[e3++] = 8;
        for (za(1, t3.lens, 0, 288, pl, 0, t3.work, { bits: 9 }), e3 = 0; e3 < 32; ) t3.lens[e3++] = 5;
        za(2, t3.lens, 0, 32, fl, 0, t3.work, { bits: 5 }), bl = false;
      }
      t3.lencode = pl, t3.lenbits = 9, t3.distcode = fl, t3.distbits = 5;
    };
    var gl = (t3, e3, s3, n3) => {
      let i3;
      const o3 = t3.state;
      return null === o3.window && (o3.wsize = 1 << o3.wbits, o3.wnext = 0, o3.whave = 0, o3.window = new Uint8Array(o3.wsize)), n3 >= o3.wsize ? (o3.window.set(e3.subarray(s3 - o3.wsize, s3), 0), o3.wnext = 0, o3.whave = o3.wsize) : (i3 = o3.wsize - o3.wnext, i3 > n3 && (i3 = n3), o3.window.set(e3.subarray(s3 - n3, s3 - n3 + i3), o3.wnext), (n3 -= i3) ? (o3.window.set(e3.subarray(s3 - n3, s3), 0), o3.wnext = n3, o3.whave = o3.wsize) : (o3.wnext += i3, o3.wnext === o3.wsize && (o3.wnext = 0), o3.whave < o3.wsize && (o3.whave += i3))), 0;
    };
    var wl = (t3, e3) => {
      let s3, n3, i3, o3, r2, a3, l3, c2, d2, h2, u2, m2, p2, f2, b2, y2, g2, w2, Z2, X2, v2, L2, x2 = 0;
      const S2 = new Uint8Array(4);
      let G2, T2;
      const W2 = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
      if (cl(t3) || !t3.output || !t3.input && 0 !== t3.avail_in) return Ua;
      s3 = t3.state, s3.mode === tl && (s3.mode = el), r2 = t3.next_out, i3 = t3.output, l3 = t3.avail_out, o3 = t3.next_in, n3 = t3.input, a3 = t3.avail_in, c2 = s3.hold, d2 = s3.bits, h2 = a3, u2 = l3, L2 = ja;
      t: for (; ; ) switch (s3.mode) {
        case $a:
          if (0 === s3.wrap) {
            s3.mode = el;
            break;
          }
          for (; d2 < 16; ) {
            if (0 === a3) break t;
            a3--, c2 += n3[o3++] << d2, d2 += 8;
          }
          if (2 & s3.wrap && 35615 === c2) {
            0 === s3.wbits && (s3.wbits = 15), s3.check = 0, S2[0] = 255 & c2, S2[1] = c2 >>> 8 & 255, s3.check = dr(s3.check, S2, 2, 0), c2 = 0, d2 = 0, s3.mode = 16181;
            break;
          }
          if (s3.head && (s3.head.done = false), !(1 & s3.wrap) || (((255 & c2) << 8) + (c2 >> 8)) % 31) {
            t3.msg = "incorrect header check", s3.mode = rl;
            break;
          }
          if ((15 & c2) !== Aa) {
            t3.msg = "unknown compression method", s3.mode = rl;
            break;
          }
          if (c2 >>>= 4, d2 -= 4, v2 = 8 + (15 & c2), 0 === s3.wbits && (s3.wbits = v2), v2 > 15 || v2 > s3.wbits) {
            t3.msg = "invalid window size", s3.mode = rl;
            break;
          }
          s3.dmax = 1 << s3.wbits, s3.flags = 0, t3.adler = s3.check = 1, s3.mode = 512 & c2 ? 16189 : tl, c2 = 0, d2 = 0;
          break;
        case 16181:
          for (; d2 < 16; ) {
            if (0 === a3) break t;
            a3--, c2 += n3[o3++] << d2, d2 += 8;
          }
          if (s3.flags = c2, (255 & s3.flags) !== Aa) {
            t3.msg = "unknown compression method", s3.mode = rl;
            break;
          }
          if (57344 & s3.flags) {
            t3.msg = "unknown header flags set", s3.mode = rl;
            break;
          }
          s3.head && (s3.head.text = c2 >> 8 & 1), 512 & s3.flags && 4 & s3.wrap && (S2[0] = 255 & c2, S2[1] = c2 >>> 8 & 255, s3.check = dr(s3.check, S2, 2, 0)), c2 = 0, d2 = 0, s3.mode = 16182;
        case 16182:
          for (; d2 < 32; ) {
            if (0 === a3) break t;
            a3--, c2 += n3[o3++] << d2, d2 += 8;
          }
          s3.head && (s3.head.time = c2), 512 & s3.flags && 4 & s3.wrap && (S2[0] = 255 & c2, S2[1] = c2 >>> 8 & 255, S2[2] = c2 >>> 16 & 255, S2[3] = c2 >>> 24 & 255, s3.check = dr(s3.check, S2, 4, 0)), c2 = 0, d2 = 0, s3.mode = 16183;
        case 16183:
          for (; d2 < 16; ) {
            if (0 === a3) break t;
            a3--, c2 += n3[o3++] << d2, d2 += 8;
          }
          s3.head && (s3.head.xflags = 255 & c2, s3.head.os = c2 >> 8), 512 & s3.flags && 4 & s3.wrap && (S2[0] = 255 & c2, S2[1] = c2 >>> 8 & 255, s3.check = dr(s3.check, S2, 2, 0)), c2 = 0, d2 = 0, s3.mode = 16184;
        case 16184:
          if (1024 & s3.flags) {
            for (; d2 < 16; ) {
              if (0 === a3) break t;
              a3--, c2 += n3[o3++] << d2, d2 += 8;
            }
            s3.length = c2, s3.head && (s3.head.extra_len = c2), 512 & s3.flags && 4 & s3.wrap && (S2[0] = 255 & c2, S2[1] = c2 >>> 8 & 255, s3.check = dr(s3.check, S2, 2, 0)), c2 = 0, d2 = 0;
          } else s3.head && (s3.head.extra = null);
          s3.mode = 16185;
        case 16185:
          if (1024 & s3.flags && (m2 = s3.length, m2 > a3 && (m2 = a3), m2 && (s3.head && (v2 = s3.head.extra_len - s3.length, s3.head.extra || (s3.head.extra = new Uint8Array(s3.head.extra_len)), s3.head.extra.set(n3.subarray(o3, o3 + m2), v2)), 512 & s3.flags && 4 & s3.wrap && (s3.check = dr(s3.check, n3, m2, o3)), a3 -= m2, o3 += m2, s3.length -= m2), s3.length)) break t;
          s3.length = 0, s3.mode = 16186;
        case 16186:
          if (2048 & s3.flags) {
            if (0 === a3) break t;
            m2 = 0;
            do {
              v2 = n3[o3 + m2++], s3.head && v2 && s3.length < 65536 && (s3.head.name += String.fromCharCode(v2));
            } while (v2 && m2 < a3);
            if (512 & s3.flags && 4 & s3.wrap && (s3.check = dr(s3.check, n3, m2, o3)), a3 -= m2, o3 += m2, v2) break t;
          } else s3.head && (s3.head.name = null);
          s3.length = 0, s3.mode = 16187;
        case 16187:
          if (4096 & s3.flags) {
            if (0 === a3) break t;
            m2 = 0;
            do {
              v2 = n3[o3 + m2++], s3.head && v2 && s3.length < 65536 && (s3.head.comment += String.fromCharCode(v2));
            } while (v2 && m2 < a3);
            if (512 & s3.flags && 4 & s3.wrap && (s3.check = dr(s3.check, n3, m2, o3)), a3 -= m2, o3 += m2, v2) break t;
          } else s3.head && (s3.head.comment = null);
          s3.mode = 16188;
        case 16188:
          if (512 & s3.flags) {
            for (; d2 < 16; ) {
              if (0 === a3) break t;
              a3--, c2 += n3[o3++] << d2, d2 += 8;
            }
            if (4 & s3.wrap && c2 !== (65535 & s3.check)) {
              t3.msg = "header crc mismatch", s3.mode = rl;
              break;
            }
            c2 = 0, d2 = 0;
          }
          s3.head && (s3.head.hcrc = s3.flags >> 9 & 1, s3.head.done = true), t3.adler = s3.check = 0, s3.mode = tl;
          break;
        case 16189:
          for (; d2 < 32; ) {
            if (0 === a3) break t;
            a3--, c2 += n3[o3++] << d2, d2 += 8;
          }
          t3.adler = s3.check = al(c2), c2 = 0, d2 = 0, s3.mode = qa;
        case qa:
          if (0 === s3.havedict) return t3.next_out = r2, t3.avail_out = l3, t3.next_in = o3, t3.avail_in = a3, s3.hold = c2, s3.bits = d2, Qa;
          t3.adler = s3.check = 1, s3.mode = tl;
        case tl:
          if (e3 === Fa || e3 === Ea) break t;
        case el:
          if (s3.last) {
            c2 >>>= 7 & d2, d2 -= 7 & d2, s3.mode = ol;
            break;
          }
          for (; d2 < 3; ) {
            if (0 === a3) break t;
            a3--, c2 += n3[o3++] << d2, d2 += 8;
          }
          switch (s3.last = 1 & c2, c2 >>>= 1, d2 -= 1, 3 & c2) {
            case 0:
              s3.mode = 16193;
              break;
            case 1:
              if (yl(s3), s3.mode = nl, e3 === Ea) {
                c2 >>>= 2, d2 -= 2;
                break t;
              }
              break;
            case 2:
              s3.mode = 16196;
              break;
            case 3:
              t3.msg = "invalid block type", s3.mode = rl;
          }
          c2 >>>= 2, d2 -= 2;
          break;
        case 16193:
          for (c2 >>>= 7 & d2, d2 -= 7 & d2; d2 < 32; ) {
            if (0 === a3) break t;
            a3--, c2 += n3[o3++] << d2, d2 += 8;
          }
          if ((65535 & c2) != (c2 >>> 16 ^ 65535)) {
            t3.msg = "invalid stored block lengths", s3.mode = rl;
            break;
          }
          if (s3.length = 65535 & c2, c2 = 0, d2 = 0, s3.mode = sl, e3 === Ea) break t;
        case sl:
          s3.mode = 16195;
        case 16195:
          if (m2 = s3.length, m2) {
            if (m2 > a3 && (m2 = a3), m2 > l3 && (m2 = l3), 0 === m2) break t;
            i3.set(n3.subarray(o3, o3 + m2), r2), a3 -= m2, o3 += m2, l3 -= m2, r2 += m2, s3.length -= m2;
            break;
          }
          s3.mode = tl;
          break;
        case 16196:
          for (; d2 < 14; ) {
            if (0 === a3) break t;
            a3--, c2 += n3[o3++] << d2, d2 += 8;
          }
          if (s3.nlen = 257 + (31 & c2), c2 >>>= 5, d2 -= 5, s3.ndist = 1 + (31 & c2), c2 >>>= 5, d2 -= 5, s3.ncode = 4 + (15 & c2), c2 >>>= 4, d2 -= 4, s3.nlen > 286 || s3.ndist > 30) {
            t3.msg = "too many length or distance symbols", s3.mode = rl;
            break;
          }
          s3.have = 0, s3.mode = 16197;
        case 16197:
          for (; s3.have < s3.ncode; ) {
            for (; d2 < 3; ) {
              if (0 === a3) break t;
              a3--, c2 += n3[o3++] << d2, d2 += 8;
            }
            s3.lens[W2[s3.have++]] = 7 & c2, c2 >>>= 3, d2 -= 3;
          }
          for (; s3.have < 19; ) s3.lens[W2[s3.have++]] = 0;
          if (s3.lencode = s3.lendyn, s3.lenbits = 7, G2 = { bits: s3.lenbits }, L2 = za(0, s3.lens, 0, 19, s3.lencode, 0, s3.work, G2), s3.lenbits = G2.bits, L2) {
            t3.msg = "invalid code lengths set", s3.mode = rl;
            break;
          }
          s3.have = 0, s3.mode = 16198;
        case 16198:
          for (; s3.have < s3.nlen + s3.ndist; ) {
            for (; x2 = s3.lencode[c2 & (1 << s3.lenbits) - 1], b2 = x2 >>> 24, y2 = x2 >>> 16 & 255, g2 = 65535 & x2, !(b2 <= d2); ) {
              if (0 === a3) break t;
              a3--, c2 += n3[o3++] << d2, d2 += 8;
            }
            if (g2 < 16) c2 >>>= b2, d2 -= b2, s3.lens[s3.have++] = g2;
            else {
              if (16 === g2) {
                for (T2 = b2 + 2; d2 < T2; ) {
                  if (0 === a3) break t;
                  a3--, c2 += n3[o3++] << d2, d2 += 8;
                }
                if (c2 >>>= b2, d2 -= b2, 0 === s3.have) {
                  t3.msg = "invalid bit length repeat", s3.mode = rl;
                  break;
                }
                v2 = s3.lens[s3.have - 1], m2 = 3 + (3 & c2), c2 >>>= 2, d2 -= 2;
              } else if (17 === g2) {
                for (T2 = b2 + 3; d2 < T2; ) {
                  if (0 === a3) break t;
                  a3--, c2 += n3[o3++] << d2, d2 += 8;
                }
                c2 >>>= b2, d2 -= b2, v2 = 0, m2 = 3 + (7 & c2), c2 >>>= 3, d2 -= 3;
              } else {
                for (T2 = b2 + 7; d2 < T2; ) {
                  if (0 === a3) break t;
                  a3--, c2 += n3[o3++] << d2, d2 += 8;
                }
                c2 >>>= b2, d2 -= b2, v2 = 0, m2 = 11 + (127 & c2), c2 >>>= 7, d2 -= 7;
              }
              if (s3.have + m2 > s3.nlen + s3.ndist) {
                t3.msg = "invalid bit length repeat", s3.mode = rl;
                break;
              }
              for (; m2--; ) s3.lens[s3.have++] = v2;
            }
          }
          if (s3.mode === rl) break;
          if (0 === s3.lens[256]) {
            t3.msg = "invalid code -- missing end-of-block", s3.mode = rl;
            break;
          }
          if (s3.lenbits = 9, G2 = { bits: s3.lenbits }, L2 = za(1, s3.lens, 0, s3.nlen, s3.lencode, 0, s3.work, G2), s3.lenbits = G2.bits, L2) {
            t3.msg = "invalid literal/lengths set", s3.mode = rl;
            break;
          }
          if (s3.distbits = 6, s3.distcode = s3.distdyn, G2 = { bits: s3.distbits }, L2 = za(2, s3.lens, s3.nlen, s3.ndist, s3.distcode, 0, s3.work, G2), s3.distbits = G2.bits, L2) {
            t3.msg = "invalid distances set", s3.mode = rl;
            break;
          }
          if (s3.mode = nl, e3 === Ea) break t;
        case nl:
          s3.mode = il;
        case il:
          if (a3 >= 6 && l3 >= 258) {
            t3.next_out = r2, t3.avail_out = l3, t3.next_in = o3, t3.avail_in = a3, s3.hold = c2, s3.bits = d2, Va(t3, u2), r2 = t3.next_out, i3 = t3.output, l3 = t3.avail_out, o3 = t3.next_in, n3 = t3.input, a3 = t3.avail_in, c2 = s3.hold, d2 = s3.bits, s3.mode === tl && (s3.back = -1);
            break;
          }
          for (s3.back = 0; x2 = s3.lencode[c2 & (1 << s3.lenbits) - 1], b2 = x2 >>> 24, y2 = x2 >>> 16 & 255, g2 = 65535 & x2, !(b2 <= d2); ) {
            if (0 === a3) break t;
            a3--, c2 += n3[o3++] << d2, d2 += 8;
          }
          if (y2 && !(240 & y2)) {
            for (w2 = b2, Z2 = y2, X2 = g2; x2 = s3.lencode[X2 + ((c2 & (1 << w2 + Z2) - 1) >> w2)], b2 = x2 >>> 24, y2 = x2 >>> 16 & 255, g2 = 65535 & x2, !(w2 + b2 <= d2); ) {
              if (0 === a3) break t;
              a3--, c2 += n3[o3++] << d2, d2 += 8;
            }
            c2 >>>= w2, d2 -= w2, s3.back += w2;
          }
          if (c2 >>>= b2, d2 -= b2, s3.back += b2, s3.length = g2, 0 === y2) {
            s3.mode = 16205;
            break;
          }
          if (32 & y2) {
            s3.back = -1, s3.mode = tl;
            break;
          }
          if (64 & y2) {
            t3.msg = "invalid literal/length code", s3.mode = rl;
            break;
          }
          s3.extra = 15 & y2, s3.mode = 16201;
        case 16201:
          if (s3.extra) {
            for (T2 = s3.extra; d2 < T2; ) {
              if (0 === a3) break t;
              a3--, c2 += n3[o3++] << d2, d2 += 8;
            }
            s3.length += c2 & (1 << s3.extra) - 1, c2 >>>= s3.extra, d2 -= s3.extra, s3.back += s3.extra;
          }
          s3.was = s3.length, s3.mode = 16202;
        case 16202:
          for (; x2 = s3.distcode[c2 & (1 << s3.distbits) - 1], b2 = x2 >>> 24, y2 = x2 >>> 16 & 255, g2 = 65535 & x2, !(b2 <= d2); ) {
            if (0 === a3) break t;
            a3--, c2 += n3[o3++] << d2, d2 += 8;
          }
          if (!(240 & y2)) {
            for (w2 = b2, Z2 = y2, X2 = g2; x2 = s3.distcode[X2 + ((c2 & (1 << w2 + Z2) - 1) >> w2)], b2 = x2 >>> 24, y2 = x2 >>> 16 & 255, g2 = 65535 & x2, !(w2 + b2 <= d2); ) {
              if (0 === a3) break t;
              a3--, c2 += n3[o3++] << d2, d2 += 8;
            }
            c2 >>>= w2, d2 -= w2, s3.back += w2;
          }
          if (c2 >>>= b2, d2 -= b2, s3.back += b2, 64 & y2) {
            t3.msg = "invalid distance code", s3.mode = rl;
            break;
          }
          s3.offset = g2, s3.extra = 15 & y2, s3.mode = 16203;
        case 16203:
          if (s3.extra) {
            for (T2 = s3.extra; d2 < T2; ) {
              if (0 === a3) break t;
              a3--, c2 += n3[o3++] << d2, d2 += 8;
            }
            s3.offset += c2 & (1 << s3.extra) - 1, c2 >>>= s3.extra, d2 -= s3.extra, s3.back += s3.extra;
          }
          if (s3.offset > s3.dmax) {
            t3.msg = "invalid distance too far back", s3.mode = rl;
            break;
          }
          s3.mode = 16204;
        case 16204:
          if (0 === l3) break t;
          if (m2 = u2 - l3, s3.offset > m2) {
            if (m2 = s3.offset - m2, m2 > s3.whave && s3.sane) {
              t3.msg = "invalid distance too far back", s3.mode = rl;
              break;
            }
            m2 > s3.wnext ? (m2 -= s3.wnext, p2 = s3.wsize - m2) : p2 = s3.wnext - m2, m2 > s3.length && (m2 = s3.length), f2 = s3.window;
          } else f2 = i3, p2 = r2 - s3.offset, m2 = s3.length;
          m2 > l3 && (m2 = l3), l3 -= m2, s3.length -= m2;
          do {
            i3[r2++] = f2[p2++];
          } while (--m2);
          0 === s3.length && (s3.mode = il);
          break;
        case 16205:
          if (0 === l3) break t;
          i3[r2++] = s3.length, l3--, s3.mode = il;
          break;
        case ol:
          if (s3.wrap) {
            for (; d2 < 32; ) {
              if (0 === a3) break t;
              a3--, c2 |= n3[o3++] << d2, d2 += 8;
            }
            if (u2 -= l3, t3.total_out += u2, s3.total += u2, 4 & s3.wrap && u2 && (t3.adler = s3.check = s3.flags ? dr(s3.check, i3, u2, r2 - u2) : lr(s3.check, i3, u2, r2 - u2)), u2 = l3, 4 & s3.wrap && (s3.flags ? c2 : al(c2)) !== s3.check) {
              t3.msg = "incorrect data check", s3.mode = rl;
              break;
            }
            c2 = 0, d2 = 0;
          }
          s3.mode = 16207;
        case 16207:
          if (s3.wrap && s3.flags) {
            for (; d2 < 32; ) {
              if (0 === a3) break t;
              a3--, c2 += n3[o3++] << d2, d2 += 8;
            }
            if (4 & s3.wrap && c2 !== (4294967295 & s3.total)) {
              t3.msg = "incorrect length check", s3.mode = rl;
              break;
            }
            c2 = 0, d2 = 0;
          }
          s3.mode = 16208;
        case 16208:
          L2 = Ja;
          break t;
        case rl:
          L2 = Da;
          break t;
        case 16210:
          return Oa;
        default:
          return Ua;
      }
      return t3.next_out = r2, t3.avail_out = l3, t3.next_in = o3, t3.avail_in = a3, s3.hold = c2, s3.bits = d2, (s3.wsize || u2 !== t3.avail_out && s3.mode < rl && (s3.mode < ol || e3 !== _a)) && gl(t3, t3.output, t3.next_out, u2 - t3.avail_out), h2 -= t3.avail_in, u2 -= t3.avail_out, t3.total_in += h2, t3.total_out += u2, s3.total += u2, 4 & s3.wrap && u2 && (t3.adler = s3.check = s3.flags ? dr(s3.check, i3, u2, t3.next_out - u2) : lr(s3.check, i3, u2, t3.next_out - u2)), t3.data_type = s3.bits + (s3.last ? 64 : 0) + (s3.mode === tl ? 128 : 0) + (s3.mode === nl || s3.mode === sl ? 256 : 0), (0 === h2 && 0 === u2 || e3 === _a) && L2 === ja && (L2 = Ba), L2;
    };
    var Zl = { inflateReset: hl, inflateReset2: ul, inflateResetKeep: dl, inflateInit: (t3) => ml(t3, 15), inflateInit2: ml, inflate: wl, inflateEnd: (t3) => {
      if (cl(t3)) return Ua;
      let e3 = t3.state;
      return e3.window && (e3.window = null), t3.state = null, ja;
    }, inflateGetHeader: (t3, e3) => {
      if (cl(t3)) return Ua;
      const s3 = t3.state;
      return 2 & s3.wrap ? (s3.head = e3, e3.done = false, ja) : Ua;
    }, inflateSetDictionary: (t3, e3) => {
      const s3 = e3.length;
      let n3, i3, o3;
      return cl(t3) ? Ua : (n3 = t3.state, 0 !== n3.wrap && n3.mode !== qa ? Ua : n3.mode === qa && (i3 = 1, i3 = lr(i3, e3, s3, 0), i3 !== n3.check) ? Da : (o3 = gl(t3, e3, s3, s3), o3 ? (n3.mode = 16210, Oa) : (n3.havedict = 1, ja)));
    }, inflateInfo: "pako inflate (from Nodeca project)" };
    var Xl = function() {
      this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
    };
    var vl = Object.prototype.toString;
    var { Z_NO_FLUSH: Ll, Z_FINISH: xl, Z_OK: Sl, Z_STREAM_END: Gl, Z_NEED_DICT: Tl, Z_STREAM_ERROR: Wl, Z_DATA_ERROR: Cl, Z_MEM_ERROR: kl } = ur;
    function Pl(t3) {
      this.options = ua({ chunkSize: 65536, windowBits: 15, to: "" }, t3 || {});
      const e3 = this.options;
      e3.raw && e3.windowBits >= 0 && e3.windowBits < 16 && (e3.windowBits = -e3.windowBits, 0 === e3.windowBits && (e3.windowBits = -15)), !(e3.windowBits >= 0 && e3.windowBits < 16) || t3 && t3.windowBits || (e3.windowBits += 32), e3.windowBits > 15 && e3.windowBits < 48 && (15 & e3.windowBits || (e3.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new wa(), this.strm.avail_out = 0;
      let s3 = Zl.inflateInit2(this.strm, e3.windowBits);
      if (s3 !== Sl) throw new Error(hr[s3]);
      if (this.header = new Xl(), Zl.inflateGetHeader(this.strm, this.header), e3.dictionary && ("string" == typeof e3.dictionary ? e3.dictionary = ba(e3.dictionary) : "[object ArrayBuffer]" === vl.call(e3.dictionary) && (e3.dictionary = new Uint8Array(e3.dictionary)), e3.raw && (s3 = Zl.inflateSetDictionary(this.strm, e3.dictionary), s3 !== Sl))) throw new Error(hr[s3]);
    }
    function Il(t3, e3) {
      const s3 = new Pl(e3);
      if (s3.push(t3), s3.err) throw s3.msg || hr[s3.err];
      return s3.result;
    }
    Pl.prototype.push = function(t3, e3) {
      const s3 = this.strm, n3 = this.options.chunkSize, i3 = this.options.dictionary;
      let o3, r2, a3;
      if (this.ended) return false;
      for (r2 = e3 === ~~e3 ? e3 : true === e3 ? xl : Ll, "[object ArrayBuffer]" === vl.call(t3) ? s3.input = new Uint8Array(t3) : s3.input = t3, s3.next_in = 0, s3.avail_in = s3.input.length; ; ) {
        for (0 === s3.avail_out && (s3.output = new Uint8Array(n3), s3.next_out = 0, s3.avail_out = n3), o3 = Zl.inflate(s3, r2), o3 === Tl && i3 && (o3 = Zl.inflateSetDictionary(s3, i3), o3 === Sl ? o3 = Zl.inflate(s3, r2) : o3 === Cl && (o3 = Tl)); s3.avail_in > 0 && o3 === Gl && s3.state.wrap > 0 && 0 !== t3[s3.next_in]; ) Zl.inflateReset(s3), o3 = Zl.inflate(s3, r2);
        switch (o3) {
          case Wl:
          case Cl:
          case Tl:
          case kl:
            return this.onEnd(o3), this.ended = true, false;
        }
        if (a3 = s3.avail_out, s3.next_out && (0 === s3.avail_out || o3 === Gl)) if ("string" === this.options.to) {
          let t4 = ga(s3.output, s3.next_out), e4 = s3.next_out - t4, i4 = ya(s3.output, t4);
          s3.next_out = e4, s3.avail_out = n3 - e4, e4 && s3.output.set(s3.output.subarray(t4, t4 + e4), 0), this.onData(i4);
        } else this.onData(s3.output.length === s3.next_out ? s3.output : s3.output.subarray(0, s3.next_out));
        if (o3 !== Sl || 0 !== a3) {
          if (o3 === Gl) return o3 = Zl.inflateEnd(this.strm), this.onEnd(o3), this.ended = true, true;
          if (0 === s3.avail_in) break;
        }
      }
      return true;
    }, Pl.prototype.onData = function(t3) {
      this.chunks.push(t3);
    }, Pl.prototype.onEnd = function(t3) {
      t3 === Sl && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = ma(this.chunks)), this.chunks = [], this.err = t3, this.msg = this.strm.msg;
    };
    var Rl = { Inflate: Pl, inflate: Il, inflateRaw: function(t3, e3) {
      return (e3 = e3 || {}).raw = true, Il(t3, e3);
    }, ungzip: Il };
    var { Deflate: Vl, deflate: Yl, deflateRaw: Ml, gzip: Hl } = Ia;
    var { Inflate: Kl, inflate: Nl, inflateRaw: zl, ungzip: _l } = Rl;
    var Fl = { Deflate: Vl, deflate: Yl, deflateRaw: Ml, gzip: Hl, Inflate: Kl, inflate: Nl, inflateRaw: zl, ungzip: _l, constants: ur };
    var El = class {
      constructor() {
        this.url = "(offline)", this.readyState = WebSocket.CONNECTING, this.bufferedAmount = 0, setTimeout(() => {
          this.readyState = WebSocket.OPEN, this.onopen && this.onopen();
        }, 50), this.start = Date.now();
      }
      send(t3) {
        const { id: e3, action: s3, args: n3 } = JSON.parse(t3);
        switch (s3) {
          case "JOIN":
            return this.id = e3, this.ticks = n3.ticks.tick, this.seq = -16 >>> 0, this.reply("SYNC", { messages: [], time: this.time, seq: this.seq, tove: n3.tove, reflector: "offline" }), this.reply("RECV", [this.time, ++this.seq, { what: "users", joined: [n3.user], active: 1, total: 1 }]), void this.tick();
          case "SEND": {
            const t4 = [...n3];
            return t4[0] = this.time, t4[1] = ++this.seq, void this.reply("RECV", t4);
          }
          case "PULSE":
            return;
          default:
            throw Error("Offline unhandled " + s3);
        }
      }
      close(t3, e3) {
        this.readyState = WebSocket.CLOSING, setTimeout(() => {
          this.readyState = WebSocket.CLOSED, this.onclose && this.onclose({ code: t3, reason: e3 });
        }, 50);
      }
      get time() {
        return Date.now() - this.start;
      }
      tick() {
        clearInterval(this.ticker), this.ticker = setInterval(() => {
          this.reply("TICK", { time: this.time });
        }, this.ticks);
      }
      reply(t3, e3) {
        setTimeout(() => {
          this.onmessage && this.onmessage({ data: JSON.stringify({ id: this.id, action: t3, args: e3 }) });
        }, 50);
      }
    };
    var _a2;
    var jl = !!((_a2 = globalThis.navigator) == null ? void 0 : _a2.userAgent.toLowerCase().includes("firefox"));
    var Jl = { get connection() {
      return Jl = { connection: m.has("debug", "connection", false) }, Jl.connection;
    } };
    var Ql = class {
      static get name() {
        return `${Qt.libName}WebRTCConnection`;
      }
      constructor(t3) {
        var e3;
        this.clientId = (e3 = 4, Math.random().toString(36).substring(2, 2 + e3)), Jl.connection && console.log(`${this.clientId} WebRTCConnection created`), this.pc = null, this.dataChannel = null, this.signaling = null, this.connectionTypes = {}, this.onopen = null, this.onmessage = null, this.onerror = null, this.onclose = null, this.onconnected = null, this.twoStageConnection = true, this.url = "synchronizer", this.bufferedAmount = 0, this.openConnection(t3);
      }
      isConnecting() {
        var _a3;
        return ((_a3 = this.signaling) == null ? void 0 : _a3.readyState) === WebSocket.OPEN;
      }
      async openConnection(t3) {
        var _a3;
        try {
          await this.openSignalingChannel(t3), Jl.connection && console.log(`${this.clientId} signaling ready`), this.onopen && this.onopen(), await this.createPeerConnection(), Jl.connection && console.log(`${this.clientId} peer connection created`), this.dataChannel = this.pc.createDataChannel(`client-${this.clientId}`), Jl.connection && console.log(`${this.clientId} data channel created`), this.dataChannel.onopen = (t4) => this.onDataChannelOpen(t4), this.dataChannel.onmessage = (t4) => this.onDataChannelMessage(t4), this.dataChannel.onclosing = (t4) => this.onDataChannelClosing(t4), this.dataChannel.onclose = (t4) => this.onDataChannelClose(t4), this.dataChannel.onerror = (t4) => this.onDataChannelError(t4);
          const e3 = await this.pc.createOffer();
          if (((_a3 = this.signaling) == null ? void 0 : _a3.readyState) !== WebSocket.OPEN) return;
          if (this.negotiationTimeout = setTimeout(() => {
            delete this.negotiationTimeout, this.dataChannelFlowing ? this.signalingCloseScheduled || (Jl.connection && console.log(`${this.clientId} ICE negotiation timed out but appears to have succeeded`), this.scheduleSignalingClose()) : this.synchronizerDisconnected(4003, "ICE negotiation timed out");
          }, 15e3), this.signalToSessionRunner({ type: "offer", sdp: e3.sdp }), await this.pc.setLocalDescription(e3), !this.pc.sctp) return;
          const s3 = this.pc.sctp.transport.iceTransport;
          s3.onselectedcandidatepairchange = (t4) => {
            Jl.connection && console.log(`${this.clientId} ICE candidate pair changed`);
            const e4 = s3.getSelectedCandidatePair();
            this.connectionTypes.local = e4.local.type, this.connectionTypes.remote = e4.remote.type, this.logConnectionState();
          };
        } catch (t4) {
          this.synchronizerDisconnected(t4.code || 4003, t4.message);
        }
      }
      openSignalingChannel(t3) {
        return this.signaling ? (console.warn(`${this.clientId} signaling channel already open`), Promise.resolve()) : (this.synchronizerGatheringComplete = false, this.localGatheringComplete = false, this.dataChannelFlowing = false, this.signalingCloseScheduled = false, this.signalingKey = Math.random(), new Promise((e3) => {
          this.signaling = new WebSocket(t3), this.signaling.onopen = () => {
            Jl.connection && console.log(`${this.clientId} signaling socket opened`);
          }, this.signaling.onmessage = (t4) => {
            const s3 = JSON.parse(t4.data);
            if ("READY" === s3.what) return this.clientId += `_${s3.id}`, this.iceServers = s3.iceServers, void e3();
            if ("ERROR" !== s3.what) if (s3.type) switch (Jl.connection && console.log(`${this.clientId} received signal of type "${s3.type}"`), s3.type) {
              case "answer":
                this.handleAnswer(s3);
                break;
              case "candidate":
                this.handleCandidate(s3);
                break;
              case "gathering-complete":
                this.synchronizerGatheringComplete = true;
                break;
              default:
                Jl.connection && console.log(`${this.clientId} unhandled: ${s3.type}`);
            }
            else console.error(`${this.clientId} unexpected message: ${t4.data}`);
            else console.error(`${this.clientId} registry error: ${s3.reason}`);
          }, this.signaling.onclose = (t4) => {
            Jl.connection && console.log(`${this.clientId} signaling socket closed unexpectedly (${t4.code})`), this.synchronizerDisconnected(t4.code, t4.reason);
          }, this.signaling.onerror = (t4) => {
            Jl.connection && console.log(`${this.clientId} signaling socket error`, t4), this.synchronizerError();
          };
        }));
      }
      clearNegotiationTimeout() {
        this.negotiationTimeout && (clearTimeout(this.negotiationTimeout), delete this.negotiationTimeout);
      }
      signalToSessionRunner(t3) {
        const e3 = JSON.stringify(t3);
        try {
          this.signaling.send(e3);
        } catch (t4) {
          console.error(`${this.clientId} WebRTC signaling send error`, t4);
        }
      }
      async logConnectionState() {
        var _a3;
        if (jl && this.pc) try {
          const t4 = await this.pc.getStats();
          if (t4) {
            let e4 = null;
            for (const s4 of t4.values()) if ("transport" === s4.type) {
              e4 = s4.selectedCandidatePairId;
              break;
            }
            let s3 = t4.get(e4);
            if (!s3) {
              for (const e5 of t4.values()) if ("candidate-pair" === e5.type && e5.selected) {
                s3 = e5;
                break;
              }
            }
            s3 && (this.connectionTypes.local = t4.get(s3.localCandidateId).candidateType, this.connectionTypes.remote = t4.get(s3.remoteCandidateId).candidateType);
          }
        } catch (t4) {
        }
        const t3 = this.connectionTypes.local || "", e3 = this.connectionTypes.remote || "";
        if (Jl.connection && console.log(`${this.clientId} RTCDataChannel connection state: "${this.dataChannel.readyState}" (client connection="${t3}"; synchronizer connection="${e3}")`), ((_a3 = this.signaling) == null ? void 0 : _a3.readyState) === WebSocket.OPEN) {
          const s3 = { type: "selectedCandidatePair", clientType: t3, syncType: e3 };
          this.signalToSessionRunner(s3);
        }
      }
      close(t3, e3) {
        this.cleanUpConnection();
      }
      synchronizerDisconnected() {
        let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1006, e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "connection to synchronizer lost";
        this.synchronizerCloseReason && (t3 = this.synchronizerCloseReason[0], e3 = this.synchronizerCloseReason[1]), this.cleanUpConnection(), this.onclose && this.onclose({ code: t3, reason: e3 });
      }
      synchronizerError(t3) {
        this.onerror && this.onerror(), this.synchronizerDisconnected(void 0, t3);
      }
      cleanUpConnection() {
        this.closeSignalingChannel();
        const { pc: t3 } = this;
        t3 && (this.pc = null, t3.close(), clearInterval(this.peerConnectionStatsInterval)), this.dataChannel = null;
      }
      closeSignalingChannel() {
        this.clearNegotiationTimeout(), this.signaling && (this.signaling.onclose = null, this.signaling.onerror = null, this.signaling.close(), this.signaling = null);
      }
      async createPeerConnection() {
        const { iceServers: t3 } = this, e3 = /* @__PURE__ */ new Set(), s3 = this.pc = new globalThis.RTCPeerConnection({ iceServers: t3 });
        s3.onnegotiationneeded = (t4) => {
          s3 === this.pc && Jl.connection && console.log(`${this.clientId} negotiationneeded event fired`);
        }, s3.onsignalingstatechange = (t4) => {
          s3 === this.pc && Jl.connection && console.log(`${this.clientId} signaling state: "${s3.signalingState}"`);
        }, s3.onconnectionstatechange = (t4) => {
          if (s3 !== this.pc) return;
          const { connectionState: e4, iceConnectionState: n3 } = s3;
          Jl.connection && console.log(`${this.clientId} connection state: "${e4}" (cf. ICE connection state: "${n3}")`), "disconnected" !== e4 && "failed" !== e4 || this.synchronizerDisconnected();
        }, s3.oniceconnectionstatechange = (t4) => {
          if (s3 !== this.pc) return;
          const e4 = s3.iceConnectionState, n3 = this.dataChannel.readyState;
          Jl.connection && console.log(`${this.clientId} ICE connection state: "${e4}"; data channel: "${n3}"`), "failed" === e4 && this.synchronizerDisconnected(4003, "ICE negotiation failed");
        }, s3.onicegatheringstatechange = (t4) => {
          if (s3 !== this.pc) return;
          const e4 = s3.iceGatheringState;
          Jl.connection && console.log(`${this.clientId} ICE gathering state: "${e4}"`), "complete" === e4 && (this.localGatheringComplete = true);
        }, s3.onicecandidate = (t4) => {
          var _a3;
          if (s3 === this.pc) if (t4.candidate) {
            if (((_a3 = this.signaling) == null ? void 0 : _a3.readyState) === WebSocket.OPEN) {
              const e4 = { type: "candidate", candidate: t4.candidate.candidate, sdpMid: t4.candidate.sdpMid, sdpMLineIndex: t4.candidate.sdpMLineIndex };
              this.signalToSessionRunner(e4);
            }
          } else this.localGatheringComplete = true;
        }, s3.onicecandidateerror = (t4) => {
          if (s3 === this.pc && Jl.connection) {
            const s4 = `${t4.errorCode}|${t4.url}`;
            e3.has(s4) || (701 === t4.errorCode ? console.log(`${this.clientId} ICE 701 warning on ${t4.url}`) : console.log(`${this.clientId} ICE error from ${t4.url}: ${t4.errorCode} ${t4.errorText}`), e3.add(s4));
          }
        };
      }
      async handleAnswer(t3) {
        this.pc ? await this.pc.setRemoteDescription(t3) : console.error("no peerconnection");
      }
      async handleCandidate(t3) {
        this.pc ? t3.candidate ? await this.pc.addIceCandidate(t3) : await this.pc.addIceCandidate(null) : console.error("no peerconnection");
      }
      send(t3) {
        this.dataChannel ? this.dataChannel.send(t3) : console.warn(`${this.clientId} no data channel to send: ${t3}`);
      }
      onDataChannelOpen(t3) {
        Jl.connection && console.log(`${this.clientId} RTCDataChannel open`), this.onconnected && this.onconnected(), this.logConnectionState();
      }
      onDataChannelMessage(t3) {
        if (!this.onmessage) return;
        this.dataChannelFlowing = true, !this.signalingCloseScheduled && this.synchronizerGatheringComplete && this.localGatheringComplete && (this.clearNegotiationTimeout(), this.scheduleSignalingClose());
        const e3 = t3.data;
        if (e3.startsWith("!ping")) this.send(e3.replace("ping", "pong"));
        else if (e3.startsWith("!close")) {
          const t4 = e3.split("|");
          this.synchronizerCloseReason = [Number(t4[1]), t4[2]];
        } else this.onmessage(t3);
      }
      onDataChannelError(t3) {
        console.error(`${this.clientId} RTCDataChannel error`, t3), this.synchronizerError(t3.errorDetail);
      }
      onDataChannelClosing(t3) {
        this.pc && (Jl.connection && console.log(`${this.clientId} data channel closing`), this.synchronizerDisconnected());
      }
      onDataChannelClose(t3) {
        this.pc && (Jl.connection && console.log(`${this.clientId} data channel closed`), this.synchronizerDisconnected());
      }
      scheduleSignalingClose() {
        this.signalingCloseScheduled = true, Jl.connection && console.log(`${this.clientId} signaling channel closure scheduled`);
        const { signalingKey: t3 } = this;
        setTimeout(() => {
          t3 === this.signalingKey && (Jl.connection && console.log(`${this.clientId} closing signaling channel`), this.closeSignalingChannel());
        }, 1e3);
      }
      async defunct_readConnectionType() {
        const t3 = await this.pc.getStats();
        if (t3) {
          let e3 = null;
          for (const [s4, n3] of t3) if ("transport" === n3.type) {
            e3 = n3.selectedCandidatePairId;
            break;
          }
          let s3 = t3.get(e3);
          if (!s3) {
            for (const [e4, n3] of t3) if ("candidate-pair" === n3.type && n3.selected) {
              s3 = n3;
              break;
            }
          }
          if (s3) {
            for (const [e4, n3] of t3) if (e4 === s3.remoteCandidateId) return n3.candidateType;
          }
        }
        return "";
      }
    };
    function Ul(t3, e3, s3) {
      var n3 = function(t4) {
        return atob(t4);
      }(t3), i3 = n3.indexOf("\n", 10) + 1, o3 = n3.substring(i3) + "", r2 = new Blob([o3], { type: "application/javascript" });
      return URL.createObjectURL(r2);
    }
    function Dl(t3, e3, s3) {
      var n3;
      return function(e4) {
        return n3 = n3 || Ul(t3), new Worker(n3, e4);
      };
    }
    var Ol = Dl("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwovKioKICogQ29weXJpZ2h0IENyb3F1ZXQgTGFicyAyMDI1CiAqIEJ1bmRsZSBvZiBAY3JvcXVldC9jcm9xdWV0CiAqIERhdGU6IDIwMjUtMDYtMDkKICogVmVyc2lvbjogMi4wLjQKICovCgohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7dmFyIHQ9InVuZGVmaW5lZCIhPXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6InVuZGVmaW5lZCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OiJ1bmRlZmluZWQiIT10eXBlb2YgZ2xvYmFsP2dsb2JhbDoidW5kZWZpbmVkIiE9dHlwZW9mIHNlbGY/c2VsZjp7fTtmdW5jdGlvbiBlKHQpe3JldHVybiB0JiZ0Ll9fZXNNb2R1bGUmJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LCJkZWZhdWx0Iik/dC5kZWZhdWx0OnR9ZnVuY3Rpb24gcih0KXtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCwiX19lc01vZHVsZSIpKXJldHVybiB0O3ZhciBlPXQuZGVmYXVsdDtpZigiZnVuY3Rpb24iPT10eXBlb2YgZSl7dmFyIHI9ZnVuY3Rpb24gdCgpe3JldHVybiB0aGlzIGluc3RhbmNlb2YgdD9SZWZsZWN0LmNvbnN0cnVjdChlLGFyZ3VtZW50cyx0aGlzLmNvbnN0cnVjdG9yKTplLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07ci5wcm90b3R5cGU9ZS5wcm90b3R5cGV9ZWxzZSByPXt9O3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkociwiX19lc01vZHVsZSIse3ZhbHVlOiEwfSksT2JqZWN0LmtleXModCkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LGUpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLGUsbi5nZXQ/bjp7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdFtlXX19KX0pKSxyfXZhciBuLGk9e2V4cG9ydHM6e319O258fChuPTEsZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24odCl7dmFyIGUscj1PYmplY3QucHJvdG90eXBlLG49ci5oYXNPd25Qcm9wZXJ0eSxpPU9iamVjdC5kZWZpbmVQcm9wZXJ0eXx8ZnVuY3Rpb24odCxlLHIpe3RbZV09ci52YWx1ZX0sYT0iZnVuY3Rpb24iPT10eXBlb2YgU3ltYm9sP1N5bWJvbDp7fSxzPWEuaXRlcmF0b3J8fCJAQGl0ZXJhdG9yIixvPWEuYXN5bmNJdGVyYXRvcnx8IkBAYXN5bmNJdGVyYXRvciIsbD1hLnRvU3RyaW5nVGFnfHwiQEB0b1N0cmluZ1RhZyI7ZnVuY3Rpb24gaCh0LGUscil7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse3ZhbHVlOnIsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KSx0W2VdfXRyeXtoKHt9LCIiKX1jYXRjaCh0KXtoPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdFtlXT1yfX1mdW5jdGlvbiBjKHQsZSxyLG4pe3ZhciBhPWUmJmUucHJvdG90eXBlIGluc3RhbmNlb2YgeT9lOnkscz1PYmplY3QuY3JlYXRlKGEucHJvdG90eXBlKSxvPW5ldyBMKG58fFtdKTtyZXR1cm4gaShzLCJfaW52b2tlIix7dmFsdWU6RSh0LHIsbyl9KSxzfWZ1bmN0aW9uIHUodCxlLHIpe3RyeXtyZXR1cm57dHlwZToibm9ybWFsIixhcmc6dC5jYWxsKGUscil9fWNhdGNoKHQpe3JldHVybnt0eXBlOiJ0aHJvdyIsYXJnOnR9fX10LndyYXA9Yzt2YXIgXz0ic3VzcGVuZGVkU3RhcnQiLGQ9InN1c3BlbmRlZFlpZWxkIixmPSJleGVjdXRpbmciLHA9ImNvbXBsZXRlZCIsZz17fTtmdW5jdGlvbiB5KCl7fWZ1bmN0aW9uIHcoKXt9ZnVuY3Rpb24gdigpe312YXIgbT17fTtoKG0scywoZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pKTt2YXIgYj1PYmplY3QuZ2V0UHJvdG90eXBlT2YseD1iJiZiKGIoUihbXSkpKTt4JiZ4IT09ciYmbi5jYWxsKHgscykmJihtPXgpO3ZhciBrPXYucHJvdG90eXBlPXkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUobSk7ZnVuY3Rpb24geih0KXtbIm5leHQiLCJ0aHJvdyIsInJldHVybiJdLmZvckVhY2goKGZ1bmN0aW9uKGUpe2godCxlLChmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5faW52b2tlKGUsdCl9KSl9KSl9ZnVuY3Rpb24gQSh0LGUpe2Z1bmN0aW9uIHIoaSxhLHMsbyl7dmFyIGw9dSh0W2ldLHQsYSk7aWYoInRocm93IiE9PWwudHlwZSl7dmFyIGg9bC5hcmcsYz1oLnZhbHVlO3JldHVybiBjJiYib2JqZWN0Ij09dHlwZW9mIGMmJm4uY2FsbChjLCJfX2F3YWl0Iik/ZS5yZXNvbHZlKGMuX19hd2FpdCkudGhlbigoZnVuY3Rpb24odCl7cigibmV4dCIsdCxzLG8pfSksKGZ1bmN0aW9uKHQpe3IoInRocm93Iix0LHMsbyl9KSk6ZS5yZXNvbHZlKGMpLnRoZW4oKGZ1bmN0aW9uKHQpe2gudmFsdWU9dCxzKGgpfSksKGZ1bmN0aW9uKHQpe3JldHVybiByKCJ0aHJvdyIsdCxzLG8pfSkpfW8obC5hcmcpfXZhciBhO2kodGhpcywiX2ludm9rZSIse3ZhbHVlOmZ1bmN0aW9uKHQsbil7ZnVuY3Rpb24gaSgpe3JldHVybiBuZXcgZSgoZnVuY3Rpb24oZSxpKXtyKHQsbixlLGkpfSkpfXJldHVybiBhPWE/YS50aGVuKGksaSk6aSgpfX0pfWZ1bmN0aW9uIEUodCxyLG4pe3ZhciBpPV87cmV0dXJuIGZ1bmN0aW9uKGEscyl7aWYoaT09PWYpdGhyb3cgbmV3IEVycm9yKCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nIik7aWYoaT09PXApe2lmKCJ0aHJvdyI9PT1hKXRocm93IHM7cmV0dXJue3ZhbHVlOmUsZG9uZTohMH19Zm9yKG4ubWV0aG9kPWEsbi5hcmc9czs7KXt2YXIgbz1uLmRlbGVnYXRlO2lmKG8pe3ZhciBsPVMobyxuKTtpZihsKXtpZihsPT09Zyljb250aW51ZTtyZXR1cm4gbH19aWYoIm5leHQiPT09bi5tZXRob2Qpbi5zZW50PW4uX3NlbnQ9bi5hcmc7ZWxzZSBpZigidGhyb3ciPT09bi5tZXRob2Qpe2lmKGk9PT1fKXRocm93IGk9cCxuLmFyZztuLmRpc3BhdGNoRXhjZXB0aW9uKG4uYXJnKX1lbHNlInJldHVybiI9PT1uLm1ldGhvZCYmbi5hYnJ1cHQoInJldHVybiIsbi5hcmcpO2k9Zjt2YXIgaD11KHQscixuKTtpZigibm9ybWFsIj09PWgudHlwZSl7aWYoaT1uLmRvbmU/cDpkLGguYXJnPT09Zyljb250aW51ZTtyZXR1cm57dmFsdWU6aC5hcmcsZG9uZTpuLmRvbmV9fSJ0aHJvdyI9PT1oLnR5cGUmJihpPXAsbi5tZXRob2Q9InRocm93IixuLmFyZz1oLmFyZyl9fX1mdW5jdGlvbiBTKHQscil7dmFyIG49ci5tZXRob2QsaT10Lml0ZXJhdG9yW25dO2lmKGk9PT1lKXJldHVybiByLmRlbGVnYXRlPW51bGwsInRocm93Ij09PW4mJnQuaXRlcmF0b3IucmV0dXJuJiYoci5tZXRob2Q9InJldHVybiIsci5hcmc9ZSxTKHQsciksInRocm93Ij09PXIubWV0aG9kKXx8InJldHVybiIhPT1uJiYoci5tZXRob2Q9InRocm93IixyLmFyZz1uZXcgVHlwZUVycm9yKCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICciK24rIicgbWV0aG9kIikpLGc7dmFyIGE9dShpLHQuaXRlcmF0b3Isci5hcmcpO2lmKCJ0aHJvdyI9PT1hLnR5cGUpcmV0dXJuIHIubWV0aG9kPSJ0aHJvdyIsci5hcmc9YS5hcmcsci5kZWxlZ2F0ZT1udWxsLGc7dmFyIHM9YS5hcmc7cmV0dXJuIHM/cy5kb25lPyhyW3QucmVzdWx0TmFtZV09cy52YWx1ZSxyLm5leHQ9dC5uZXh0TG9jLCJyZXR1cm4iIT09ci5tZXRob2QmJihyLm1ldGhvZD0ibmV4dCIsci5hcmc9ZSksci5kZWxlZ2F0ZT1udWxsLGcpOnM6KHIubWV0aG9kPSJ0aHJvdyIsci5hcmc9bmV3IFR5cGVFcnJvcigiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3QiKSxyLmRlbGVnYXRlPW51bGwsZyl9ZnVuY3Rpb24gQih0KXt2YXIgZT17dHJ5TG9jOnRbMF19OzEgaW4gdCYmKGUuY2F0Y2hMb2M9dFsxXSksMiBpbiB0JiYoZS5maW5hbGx5TG9jPXRbMl0sZS5hZnRlckxvYz10WzNdKSx0aGlzLnRyeUVudHJpZXMucHVzaChlKX1mdW5jdGlvbiBPKHQpe3ZhciBlPXQuY29tcGxldGlvbnx8e307ZS50eXBlPSJub3JtYWwiLGRlbGV0ZSBlLmFyZyx0LmNvbXBsZXRpb249ZX1mdW5jdGlvbiBMKHQpe3RoaXMudHJ5RW50cmllcz1be3RyeUxvYzoicm9vdCJ9XSx0LmZvckVhY2goQix0aGlzKSx0aGlzLnJlc2V0KCEwKX1mdW5jdGlvbiBSKHQpe2lmKG51bGwhPXQpe3ZhciByPXRbc107aWYocilyZXR1cm4gci5jYWxsKHQpO2lmKCJmdW5jdGlvbiI9PXR5cGVvZiB0Lm5leHQpcmV0dXJuIHQ7aWYoIWlzTmFOKHQubGVuZ3RoKSl7dmFyIGk9LTEsYT1mdW5jdGlvbiByKCl7Zm9yKDsrK2k8dC5sZW5ndGg7KWlmKG4uY2FsbCh0LGkpKXJldHVybiByLnZhbHVlPXRbaV0sci5kb25lPSExLHI7cmV0dXJuIHIudmFsdWU9ZSxyLmRvbmU9ITAscn07cmV0dXJuIGEubmV4dD1hfX10aHJvdyBuZXcgVHlwZUVycm9yKHR5cGVvZiB0KyIgaXMgbm90IGl0ZXJhYmxlIil9cmV0dXJuIHcucHJvdG90eXBlPXYsaShrLCJjb25zdHJ1Y3RvciIse3ZhbHVlOnYsY29uZmlndXJhYmxlOiEwfSksaSh2LCJjb25zdHJ1Y3RvciIse3ZhbHVlOncsY29uZmlndXJhYmxlOiEwfSksdy5kaXNwbGF5TmFtZT1oKHYsbCwiR2VuZXJhdG9yRnVuY3Rpb24iKSx0LmlzR2VuZXJhdG9yRnVuY3Rpb249ZnVuY3Rpb24odCl7dmFyIGU9ImZ1bmN0aW9uIj09dHlwZW9mIHQmJnQuY29uc3RydWN0b3I7cmV0dXJuISFlJiYoZT09PXd8fCJHZW5lcmF0b3JGdW5jdGlvbiI9PT0oZS5kaXNwbGF5TmFtZXx8ZS5uYW1lKSl9LHQubWFyaz1mdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZih0LHYpOih0Ll9fcHJvdG9fXz12LGgodCxsLCJHZW5lcmF0b3JGdW5jdGlvbiIpKSx0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGspLHR9LHQuYXdyYXA9ZnVuY3Rpb24odCl7cmV0dXJue19fYXdhaXQ6dH19LHooQS5wcm90b3R5cGUpLGgoQS5wcm90b3R5cGUsbywoZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pKSx0LkFzeW5jSXRlcmF0b3I9QSx0LmFzeW5jPWZ1bmN0aW9uKGUscixuLGksYSl7dm9pZCAwPT09YSYmKGE9UHJvbWlzZSk7dmFyIHM9bmV3IEEoYyhlLHIsbixpKSxhKTtyZXR1cm4gdC5pc0dlbmVyYXRvckZ1bmN0aW9uKHIpP3M6cy5uZXh0KCkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIHQuZG9uZT90LnZhbHVlOnMubmV4dCgpfSkpfSx6KGspLGgoayxsLCJHZW5lcmF0b3IiKSxoKGsscywoZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pKSxoKGssInRvU3RyaW5nIiwoZnVuY3Rpb24oKXtyZXR1cm4iW29iamVjdCBHZW5lcmF0b3JdIn0pKSx0LmtleXM9ZnVuY3Rpb24odCl7dmFyIGU9T2JqZWN0KHQpLHI9W107Zm9yKHZhciBuIGluIGUpci5wdXNoKG4pO3JldHVybiByLnJldmVyc2UoKSxmdW5jdGlvbiB0KCl7Zm9yKDtyLmxlbmd0aDspe3ZhciBuPXIucG9wKCk7aWYobiBpbiBlKXJldHVybiB0LnZhbHVlPW4sdC5kb25lPSExLHR9cmV0dXJuIHQuZG9uZT0hMCx0fX0sdC52YWx1ZXM9UixMLnByb3RvdHlwZT17Y29uc3RydWN0b3I6TCxyZXNldDpmdW5jdGlvbih0KXtpZih0aGlzLnByZXY9MCx0aGlzLm5leHQ9MCx0aGlzLnNlbnQ9dGhpcy5fc2VudD1lLHRoaXMuZG9uZT0hMSx0aGlzLmRlbGVnYXRlPW51bGwsdGhpcy5tZXRob2Q9Im5leHQiLHRoaXMuYXJnPWUsdGhpcy50cnlFbnRyaWVzLmZvckVhY2goTyksIXQpZm9yKHZhciByIGluIHRoaXMpInQiPT09ci5jaGFyQXQoMCkmJm4uY2FsbCh0aGlzLHIpJiYhaXNOYU4oK3Iuc2xpY2UoMSkpJiYodGhpc1tyXT1lKX0sc3RvcDpmdW5jdGlvbigpe3RoaXMuZG9uZT0hMDt2YXIgdD10aGlzLnRyeUVudHJpZXNbMF0uY29tcGxldGlvbjtpZigidGhyb3ciPT09dC50eXBlKXRocm93IHQuYXJnO3JldHVybiB0aGlzLnJ2YWx9LGRpc3BhdGNoRXhjZXB0aW9uOmZ1bmN0aW9uKHQpe2lmKHRoaXMuZG9uZSl0aHJvdyB0O3ZhciByPXRoaXM7ZnVuY3Rpb24gaShuLGkpe3JldHVybiBvLnR5cGU9InRocm93IixvLmFyZz10LHIubmV4dD1uLGkmJihyLm1ldGhvZD0ibmV4dCIsci5hcmc9ZSksISFpfWZvcih2YXIgYT10aGlzLnRyeUVudHJpZXMubGVuZ3RoLTE7YT49MDstLWEpe3ZhciBzPXRoaXMudHJ5RW50cmllc1thXSxvPXMuY29tcGxldGlvbjtpZigicm9vdCI9PT1zLnRyeUxvYylyZXR1cm4gaSgiZW5kIik7aWYocy50cnlMb2M8PXRoaXMucHJldil7dmFyIGw9bi5jYWxsKHMsImNhdGNoTG9jIiksaD1uLmNhbGwocywiZmluYWxseUxvYyIpO2lmKGwmJmgpe2lmKHRoaXMucHJldjxzLmNhdGNoTG9jKXJldHVybiBpKHMuY2F0Y2hMb2MsITApO2lmKHRoaXMucHJldjxzLmZpbmFsbHlMb2MpcmV0dXJuIGkocy5maW5hbGx5TG9jKX1lbHNlIGlmKGwpe2lmKHRoaXMucHJldjxzLmNhdGNoTG9jKXJldHVybiBpKHMuY2F0Y2hMb2MsITApfWVsc2V7aWYoIWgpdGhyb3cgbmV3IEVycm9yKCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseSIpO2lmKHRoaXMucHJldjxzLmZpbmFsbHlMb2MpcmV0dXJuIGkocy5maW5hbGx5TG9jKX19fX0sYWJydXB0OmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByPXRoaXMudHJ5RW50cmllcy5sZW5ndGgtMTtyPj0wOy0tcil7dmFyIGk9dGhpcy50cnlFbnRyaWVzW3JdO2lmKGkudHJ5TG9jPD10aGlzLnByZXYmJm4uY2FsbChpLCJmaW5hbGx5TG9jIikmJnRoaXMucHJldjxpLmZpbmFsbHlMb2Mpe3ZhciBhPWk7YnJlYWt9fWEmJigiYnJlYWsiPT09dHx8ImNvbnRpbnVlIj09PXQpJiZhLnRyeUxvYzw9ZSYmZTw9YS5maW5hbGx5TG9jJiYoYT1udWxsKTt2YXIgcz1hP2EuY29tcGxldGlvbjp7fTtyZXR1cm4gcy50eXBlPXQscy5hcmc9ZSxhPyh0aGlzLm1ldGhvZD0ibmV4dCIsdGhpcy5uZXh0PWEuZmluYWxseUxvYyxnKTp0aGlzLmNvbXBsZXRlKHMpfSxjb21wbGV0ZTpmdW5jdGlvbih0LGUpe2lmKCJ0aHJvdyI9PT10LnR5cGUpdGhyb3cgdC5hcmc7cmV0dXJuImJyZWFrIj09PXQudHlwZXx8ImNvbnRpbnVlIj09PXQudHlwZT90aGlzLm5leHQ9dC5hcmc6InJldHVybiI9PT10LnR5cGU/KHRoaXMucnZhbD10aGlzLmFyZz10LmFyZyx0aGlzLm1ldGhvZD0icmV0dXJuIix0aGlzLm5leHQ9ImVuZCIpOiJub3JtYWwiPT09dC50eXBlJiZlJiYodGhpcy5uZXh0PWUpLGd9LGZpbmlzaDpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy50cnlFbnRyaWVzLmxlbmd0aC0xO2U+PTA7LS1lKXt2YXIgcj10aGlzLnRyeUVudHJpZXNbZV07aWYoci5maW5hbGx5TG9jPT09dClyZXR1cm4gdGhpcy5jb21wbGV0ZShyLmNvbXBsZXRpb24sci5hZnRlckxvYyksTyhyKSxnfX0sY2F0Y2g6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMudHJ5RW50cmllcy5sZW5ndGgtMTtlPj0wOy0tZSl7dmFyIHI9dGhpcy50cnlFbnRyaWVzW2VdO2lmKHIudHJ5TG9jPT09dCl7dmFyIG49ci5jb21wbGV0aW9uO2lmKCJ0aHJvdyI9PT1uLnR5cGUpe3ZhciBpPW4uYXJnO08ocil9cmV0dXJuIGl9fXRocm93IG5ldyBFcnJvcigiaWxsZWdhbCBjYXRjaCBhdHRlbXB0Iil9LGRlbGVnYXRlWWllbGQ6ZnVuY3Rpb24odCxyLG4pe3JldHVybiB0aGlzLmRlbGVnYXRlPXtpdGVyYXRvcjpSKHQpLHJlc3VsdE5hbWU6cixuZXh0TG9jOm59LCJuZXh0Ij09PXRoaXMubWV0aG9kJiYodGhpcy5hcmc9ZSksZ319LHR9KHQuZXhwb3J0cyk7dHJ5e2dsb2JhbFRoaXMucmVnZW5lcmF0b3JSdW50aW1lPWV9Y2F0Y2godCl7Im9iamVjdCI9PXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXMucmVnZW5lcmF0b3JSdW50aW1lPWU6RnVuY3Rpb24oInIiLCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByIikoZSl9fShpKSk7dmFyIGEscz17ZXhwb3J0czp7fX07dmFyIG89KGF8fChhPTEsZnVuY3Rpb24odCl7Y29uc3QgZT00LHI9MCxuPTEsaT0yO2Z1bmN0aW9uIGEodCl7bGV0IGU9dC5sZW5ndGg7Zm9yKDstLWU+PTA7KXRbZV09MH1jb25zdCBzPTAsbz0xLGw9MixoPTMsYz0yNTgsdT0yOSxfPTI1NixkPV8rMSt1LGY9MzAscD0xOSxnPTIqZCsxLHk9MTUsdz0xNix2PTcsbT0yNTYsYj0xNix4PTE3LGs9MTgsej1uZXcgVWludDhBcnJheShbMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwXSksQT1uZXcgVWludDhBcnJheShbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxM10pLEU9bmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwzLDddKSxTPW5ldyBVaW50OEFycmF5KFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XSksQj01MTIsTz1uZXcgQXJyYXkoMiooZCsyKSk7YShPKTtjb25zdCBMPW5ldyBBcnJheSgyKmYpO2EoTCk7Y29uc3QgUj1uZXcgQXJyYXkoQik7YShSKTtjb25zdCBEPW5ldyBBcnJheShjLWgrMSk7YShEKTtjb25zdCBVPW5ldyBBcnJheSh1KTthKFUpO2NvbnN0IEM9bmV3IEFycmF5KGYpO2Z1bmN0aW9uIFQodCxlLHIsbixpKXt0aGlzLnN0YXRpY190cmVlPXQsdGhpcy5leHRyYV9iaXRzPWUsdGhpcy5leHRyYV9iYXNlPXIsdGhpcy5lbGVtcz1uLHRoaXMubWF4X2xlbmd0aD1pLHRoaXMuaGFzX3N0cmVlPXQmJnQubGVuZ3RofWxldCBGLEgsWjtmdW5jdGlvbiBNKHQsZSl7dGhpcy5keW5fdHJlZT10LHRoaXMubWF4X2NvZGU9MCx0aGlzLnN0YXRfZGVzYz1lfWEoQyk7Y29uc3QgTj10PT50PDI1Nj9SW3RdOlJbMjU2Kyh0Pj4+NyldLEk9KHQsZSk9Pnt0LnBlbmRpbmdfYnVmW3QucGVuZGluZysrXT0yNTUmZSx0LnBlbmRpbmdfYnVmW3QucGVuZGluZysrXT1lPj4+OCYyNTV9LGo9KHQsZSxyKT0+e3QuYmlfdmFsaWQ+dy1yPyh0LmJpX2J1Znw9ZTw8dC5iaV92YWxpZCY2NTUzNSxJKHQsdC5iaV9idWYpLHQuYmlfYnVmPWU+PnctdC5iaV92YWxpZCx0LmJpX3ZhbGlkKz1yLXcpOih0LmJpX2J1Znw9ZTw8dC5iaV92YWxpZCY2NTUzNSx0LmJpX3ZhbGlkKz1yKX0sUD0odCxlLHIpPT57aih0LHJbMiplXSxyWzIqZSsxXSl9LCQ9KHQsZSk9PntsZXQgcj0wO2Rve3J8PTEmdCx0Pj4+PTEscjw8PTF9d2hpbGUoLS1lPjApO3JldHVybiByPj4+MX0sSz10PT57MTY9PT10LmJpX3ZhbGlkPyhJKHQsdC5iaV9idWYpLHQuYmlfYnVmPTAsdC5iaV92YWxpZD0wKTp0LmJpX3ZhbGlkPj04JiYodC5wZW5kaW5nX2J1Zlt0LnBlbmRpbmcrK109MjU1JnQuYmlfYnVmLHQuYmlfYnVmPj49OCx0LmJpX3ZhbGlkLT04KX0sWD0odCxlKT0+e2NvbnN0IHI9ZS5keW5fdHJlZSxuPWUubWF4X2NvZGUsaT1lLnN0YXRfZGVzYy5zdGF0aWNfdHJlZSxhPWUuc3RhdF9kZXNjLmhhc19zdHJlZSxzPWUuc3RhdF9kZXNjLmV4dHJhX2JpdHMsbz1lLnN0YXRfZGVzYy5leHRyYV9iYXNlLGw9ZS5zdGF0X2Rlc2MubWF4X2xlbmd0aDtsZXQgaCxjLHUsXyxkLGYscD0wO2ZvcihfPTA7Xzw9eTtfKyspdC5ibF9jb3VudFtfXT0wO2ZvcihyWzIqdC5oZWFwW3QuaGVhcF9tYXhdKzFdPTAsaD10LmhlYXBfbWF4KzE7aDxnO2grKyljPXQuaGVhcFtoXSxfPXJbMipyWzIqYysxXSsxXSsxLF8+bCYmKF89bCxwKyspLHJbMipjKzFdPV8sYz5ufHwodC5ibF9jb3VudFtfXSsrLGQ9MCxjPj1vJiYoZD1zW2Mtb10pLGY9clsyKmNdLHQub3B0X2xlbis9ZiooXytkKSxhJiYodC5zdGF0aWNfbGVuKz1mKihpWzIqYysxXStkKSkpO2lmKDAhPT1wKXtkb3tmb3IoXz1sLTE7MD09PXQuYmxfY291bnRbX107KV8tLTt0LmJsX2NvdW50W19dLS0sdC5ibF9jb3VudFtfKzFdKz0yLHQuYmxfY291bnRbbF0tLSxwLT0yfXdoaWxlKHA+MCk7Zm9yKF89bDswIT09XztfLS0pZm9yKGM9dC5ibF9jb3VudFtfXTswIT09YzspdT10LmhlYXBbLS1oXSx1Pm58fChyWzIqdSsxXSE9PV8mJih0Lm9wdF9sZW4rPShfLXJbMip1KzFdKSpyWzIqdV0sclsyKnUrMV09XyksYy0tKX19LEc9KHQsZSxyKT0+e2NvbnN0IG49bmV3IEFycmF5KHkrMSk7bGV0IGksYSxzPTA7Zm9yKGk9MTtpPD15O2krKylzPXMrcltpLTFdPDwxLG5baV09cztmb3IoYT0wO2E8PWU7YSsrKXtsZXQgZT10WzIqYSsxXTswIT09ZSYmKHRbMiphXT0kKG5bZV0rKyxlKSl9fSxXPSgpPT57bGV0IHQsZSxyLG4saTtjb25zdCBhPW5ldyBBcnJheSh5KzEpO2ZvcihyPTAsbj0wO248dS0xO24rKylmb3IoVVtuXT1yLHQ9MDt0PDE8PHpbbl07dCsrKURbcisrXT1uO2ZvcihEW3ItMV09bixpPTAsbj0wO248MTY7bisrKWZvcihDW25dPWksdD0wO3Q8MTw8QVtuXTt0KyspUltpKytdPW47Zm9yKGk+Pj03O248ZjtuKyspZm9yKENbbl09aTw8Nyx0PTA7dDwxPDxBW25dLTc7dCsrKVJbMjU2K2krK109bjtmb3IoZT0wO2U8PXk7ZSsrKWFbZV09MDtmb3IodD0wO3Q8PTE0MzspT1syKnQrMV09OCx0KyssYVs4XSsrO2Zvcig7dDw9MjU1OylPWzIqdCsxXT05LHQrKyxhWzldKys7Zm9yKDt0PD0yNzk7KU9bMip0KzFdPTcsdCsrLGFbN10rKztmb3IoO3Q8PTI4NzspT1syKnQrMV09OCx0KyssYVs4XSsrO2ZvcihHKE8sZCsxLGEpLHQ9MDt0PGY7dCsrKUxbMip0KzFdPTUsTFsyKnRdPSQodCw1KTtGPW5ldyBUKE8seixfKzEsZCx5KSxIPW5ldyBUKEwsQSwwLGYseSksWj1uZXcgVChuZXcgQXJyYXkoMCksRSwwLHAsdil9LFk9dD0+e2xldCBlO2ZvcihlPTA7ZTxkO2UrKyl0LmR5bl9sdHJlZVsyKmVdPTA7Zm9yKGU9MDtlPGY7ZSsrKXQuZHluX2R0cmVlWzIqZV09MDtmb3IoZT0wO2U8cDtlKyspdC5ibF90cmVlWzIqZV09MDt0LmR5bl9sdHJlZVsyKm1dPTEsdC5vcHRfbGVuPXQuc3RhdGljX2xlbj0wLHQuc3ltX25leHQ9dC5tYXRjaGVzPTB9LHE9dD0+e3QuYmlfdmFsaWQ+OD9JKHQsdC5iaV9idWYpOnQuYmlfdmFsaWQ+MCYmKHQucGVuZGluZ19idWZbdC5wZW5kaW5nKytdPXQuYmlfYnVmKSx0LmJpX2J1Zj0wLHQuYmlfdmFsaWQ9MH0sVj0odCxlLHIsbik9Pntjb25zdCBpPTIqZSxhPTIqcjtyZXR1cm4gdFtpXTx0W2FdfHx0W2ldPT09dFthXSYmbltlXTw9bltyXX0sUT0odCxlLHIpPT57Y29uc3Qgbj10LmhlYXBbcl07bGV0IGk9cjw8MTtmb3IoO2k8PXQuaGVhcF9sZW4mJihpPHQuaGVhcF9sZW4mJlYoZSx0LmhlYXBbaSsxXSx0LmhlYXBbaV0sdC5kZXB0aCkmJmkrKywhVihlLG4sdC5oZWFwW2ldLHQuZGVwdGgpKTspdC5oZWFwW3JdPXQuaGVhcFtpXSxyPWksaTw8PTE7dC5oZWFwW3JdPW59LEo9KHQsZSxyKT0+e2xldCBuLGksYSxzLG89MDtpZigwIT09dC5zeW1fbmV4dClkb3tuPTI1NSZ0LnBlbmRpbmdfYnVmW3Quc3ltX2J1ZitvKytdLG4rPSgyNTUmdC5wZW5kaW5nX2J1Zlt0LnN5bV9idWYrbysrXSk8PDgsaT10LnBlbmRpbmdfYnVmW3Quc3ltX2J1ZitvKytdLDA9PT1uP1AodCxpLGUpOihhPURbaV0sUCh0LGErXysxLGUpLHM9elthXSwwIT09cyYmKGktPVVbYV0saih0LGkscykpLG4tLSxhPU4obiksUCh0LGEscikscz1BW2FdLDAhPT1zJiYobi09Q1thXSxqKHQsbixzKSkpfXdoaWxlKG88dC5zeW1fbmV4dCk7UCh0LG0sZSl9LHR0PSh0LGUpPT57Y29uc3Qgcj1lLmR5bl90cmVlLG49ZS5zdGF0X2Rlc2Muc3RhdGljX3RyZWUsaT1lLnN0YXRfZGVzYy5oYXNfc3RyZWUsYT1lLnN0YXRfZGVzYy5lbGVtcztsZXQgcyxvLGwsaD0tMTtmb3IodC5oZWFwX2xlbj0wLHQuaGVhcF9tYXg9ZyxzPTA7czxhO3MrKykwIT09clsyKnNdPyh0LmhlYXBbKyt0LmhlYXBfbGVuXT1oPXMsdC5kZXB0aFtzXT0wKTpyWzIqcysxXT0wO2Zvcig7dC5oZWFwX2xlbjwyOylsPXQuaGVhcFsrK3QuaGVhcF9sZW5dPWg8Mj8rK2g6MCxyWzIqbF09MSx0LmRlcHRoW2xdPTAsdC5vcHRfbGVuLS0saSYmKHQuc3RhdGljX2xlbi09blsyKmwrMV0pO2ZvcihlLm1heF9jb2RlPWgscz10LmhlYXBfbGVuPj4xO3M+PTE7cy0tKVEodCxyLHMpO2w9YTtkb3tzPXQuaGVhcFsxXSx0LmhlYXBbMV09dC5oZWFwW3QuaGVhcF9sZW4tLV0sUSh0LHIsMSksbz10LmhlYXBbMV0sdC5oZWFwWy0tdC5oZWFwX21heF09cyx0LmhlYXBbLS10LmhlYXBfbWF4XT1vLHJbMipsXT1yWzIqc10rclsyKm9dLHQuZGVwdGhbbF09KHQuZGVwdGhbc10+PXQuZGVwdGhbb10/dC5kZXB0aFtzXTp0LmRlcHRoW29dKSsxLHJbMipzKzFdPXJbMipvKzFdPWwsdC5oZWFwWzFdPWwrKyxRKHQsciwxKX13aGlsZSh0LmhlYXBfbGVuPj0yKTt0LmhlYXBbLS10LmhlYXBfbWF4XT10LmhlYXBbMV0sWCh0LGUpLEcocixoLHQuYmxfY291bnQpfSxldD0odCxlLHIpPT57bGV0IG4saSxhPS0xLHM9ZVsxXSxvPTAsbD03LGg9NDtmb3IoMD09PXMmJihsPTEzOCxoPTMpLGVbMioocisxKSsxXT02NTUzNSxuPTA7bjw9cjtuKyspaT1zLHM9ZVsyKihuKzEpKzFdLCsrbzxsJiZpPT09c3x8KG88aD90LmJsX3RyZWVbMippXSs9bzowIT09aT8oaSE9PWEmJnQuYmxfdHJlZVsyKmldKyssdC5ibF90cmVlWzIqYl0rKyk6bzw9MTA/dC5ibF90cmVlWzIqeF0rKzp0LmJsX3RyZWVbMiprXSsrLG89MCxhPWksMD09PXM/KGw9MTM4LGg9Myk6aT09PXM/KGw9NixoPTMpOihsPTcsaD00KSl9LHJ0PSh0LGUscik9PntsZXQgbixpLGE9LTEscz1lWzFdLG89MCxsPTcsaD00O2ZvcigwPT09cyYmKGw9MTM4LGg9Myksbj0wO248PXI7bisrKWlmKGk9cyxzPWVbMioobisxKSsxXSwhKCsrbzxsJiZpPT09cykpe2lmKG88aClkb3tQKHQsaSx0LmJsX3RyZWUpfXdoaWxlKDAhPS0tbyk7ZWxzZSAwIT09aT8oaSE9PWEmJihQKHQsaSx0LmJsX3RyZWUpLG8tLSksUCh0LGIsdC5ibF90cmVlKSxqKHQsby0zLDIpKTpvPD0xMD8oUCh0LHgsdC5ibF90cmVlKSxqKHQsby0zLDMpKTooUCh0LGssdC5ibF90cmVlKSxqKHQsby0xMSw3KSk7bz0wLGE9aSwwPT09cz8obD0xMzgsaD0zKTppPT09cz8obD02LGg9Myk6KGw9NyxoPTQpfX0sbnQ9dD0+e2xldCBlO2ZvcihldCh0LHQuZHluX2x0cmVlLHQubF9kZXNjLm1heF9jb2RlKSxldCh0LHQuZHluX2R0cmVlLHQuZF9kZXNjLm1heF9jb2RlKSx0dCh0LHQuYmxfZGVzYyksZT1wLTE7ZT49MyYmMD09PXQuYmxfdHJlZVsyKlNbZV0rMV07ZS0tKTtyZXR1cm4gdC5vcHRfbGVuKz0zKihlKzEpKzUrNSs0LGV9LGl0PSh0LGUscixuKT0+e2xldCBpO2ZvcihqKHQsZS0yNTcsNSksaih0LHItMSw1KSxqKHQsbi00LDQpLGk9MDtpPG47aSsrKWoodCx0LmJsX3RyZWVbMipTW2ldKzFdLDMpO3J0KHQsdC5keW5fbHRyZWUsZS0xKSxydCh0LHQuZHluX2R0cmVlLHItMSl9LGF0PXQ9PntsZXQgZSxpPTQwOTM2MjQ0NDc7Zm9yKGU9MDtlPD0zMTtlKyssaT4+Pj0xKWlmKDEmaSYmMCE9PXQuZHluX2x0cmVlWzIqZV0pcmV0dXJuIHI7aWYoMCE9PXQuZHluX2x0cmVlWzE4XXx8MCE9PXQuZHluX2x0cmVlWzIwXXx8MCE9PXQuZHluX2x0cmVlWzI2XSlyZXR1cm4gbjtmb3IoZT0zMjtlPF87ZSsrKWlmKDAhPT10LmR5bl9sdHJlZVsyKmVdKXJldHVybiBuO3JldHVybiByfTtsZXQgc3Q9ITE7Y29uc3Qgb3Q9KHQsZSxyLG4pPT57aih0LChzPDwxKSsobj8xOjApLDMpLHEodCksSSh0LHIpLEkodCx+ciksciYmdC5wZW5kaW5nX2J1Zi5zZXQodC53aW5kb3cuc3ViYXJyYXkoZSxlK3IpLHQucGVuZGluZyksdC5wZW5kaW5nKz1yfSxsdD0odCxyLG4sYSk9PntsZXQgcyxoLGM9MDt0LmxldmVsPjA/KHQuc3RybS5kYXRhX3R5cGU9PT1pJiYodC5zdHJtLmRhdGFfdHlwZT1hdCh0KSksdHQodCx0LmxfZGVzYyksdHQodCx0LmRfZGVzYyksYz1udCh0KSxzPXQub3B0X2xlbiszKzc+Pj4zLGg9dC5zdGF0aWNfbGVuKzMrNz4+PjMsaDw9cyYmKHM9aCkpOnM9aD1uKzUsbis0PD1zJiYtMSE9PXI/b3QodCxyLG4sYSk6dC5zdHJhdGVneT09PWV8fGg9PT1zPyhqKHQsKG88PDEpKyhhPzE6MCksMyksSih0LE8sTCkpOihqKHQsKGw8PDEpKyhhPzE6MCksMyksaXQodCx0LmxfZGVzYy5tYXhfY29kZSsxLHQuZF9kZXNjLm1heF9jb2RlKzEsYysxKSxKKHQsdC5keW5fbHRyZWUsdC5keW5fZHRyZWUpKSxZKHQpLGEmJnEodCl9O3ZhciBodD17X3RyX2luaXQ6dD0+e3N0fHwoVygpLHN0PSEwKSx0LmxfZGVzYz1uZXcgTSh0LmR5bl9sdHJlZSxGKSx0LmRfZGVzYz1uZXcgTSh0LmR5bl9kdHJlZSxIKSx0LmJsX2Rlc2M9bmV3IE0odC5ibF90cmVlLFopLHQuYmlfYnVmPTAsdC5iaV92YWxpZD0wLFkodCl9LF90cl9zdG9yZWRfYmxvY2s6b3QsX3RyX2ZsdXNoX2Jsb2NrOmx0LF90cl90YWxseToodCxlLHIpPT4odC5wZW5kaW5nX2J1Zlt0LnN5bV9idWYrdC5zeW1fbmV4dCsrXT1lLHQucGVuZGluZ19idWZbdC5zeW1fYnVmK3Quc3ltX25leHQrK109ZT4+OCx0LnBlbmRpbmdfYnVmW3Quc3ltX2J1Zit0LnN5bV9uZXh0KytdPXIsMD09PWU/dC5keW5fbHRyZWVbMipyXSsrOih0Lm1hdGNoZXMrKyxlLS0sdC5keW5fbHRyZWVbMiooRFtyXStfKzEpXSsrLHQuZHluX2R0cmVlWzIqTihlKV0rKyksdC5zeW1fbmV4dD09PXQuc3ltX2VuZCksX3RyX2FsaWduOnQ9PntqKHQsbzw8MSwzKSxQKHQsbSxPKSxLKHQpfX0sY3Q9KHQsZSxyLG4pPT57bGV0IGk9NjU1MzUmdCxhPXQ+Pj4xNiY2NTUzNSxzPTA7Zm9yKDswIT09cjspe3M9cj4yZTM/MmUzOnIsci09cztkb3tpPWkrZVtuKytdfDAsYT1hK2l8MH13aGlsZSgtLXMpO2klPTY1NTIxLGElPTY1NTIxfXJldHVybiBpfGE8PDE2fTtjb25zdCB1dD1uZXcgVWludDMyQXJyYXkoKCgpPT57bGV0IHQsZT1bXTtmb3IodmFyIHI9MDtyPDI1NjtyKyspe3Q9cjtmb3IodmFyIG49MDtuPDg7bisrKXQ9MSZ0PzM5ODgyOTIzODRedD4+PjE6dD4+PjE7ZVtyXT10fXJldHVybiBlfSkoKSk7dmFyIF90PSh0LGUscixuKT0+e2NvbnN0IGk9dXQsYT1uK3I7dF49LTE7Zm9yKGxldCByPW47cjxhO3IrKyl0PXQ+Pj44XmlbMjU1Jih0XmVbcl0pXTtyZXR1cm5+dH0sZHQ9ezI6Im5lZWQgZGljdGlvbmFyeSIsMToic3RyZWFtIGVuZCIsMDoiIiwiLTEiOiJmaWxlIGVycm9yIiwiLTIiOiJzdHJlYW0gZXJyb3IiLCItMyI6ImRhdGEgZXJyb3IiLCItNCI6Imluc3VmZmljaWVudCBtZW1vcnkiLCItNSI6ImJ1ZmZlciBlcnJvciIsIi02IjoiaW5jb21wYXRpYmxlIHZlcnNpb24ifSxmdD17Wl9OT19GTFVTSDowLFpfUEFSVElBTF9GTFVTSDoxLFpfU1lOQ19GTFVTSDoyLFpfRlVMTF9GTFVTSDozLFpfRklOSVNIOjQsWl9CTE9DSzo1LFpfVFJFRVM6NixaX09LOjAsWl9TVFJFQU1fRU5EOjEsWl9ORUVEX0RJQ1Q6MixaX0VSUk5POi0xLFpfU1RSRUFNX0VSUk9SOi0yLFpfREFUQV9FUlJPUjotMyxaX01FTV9FUlJPUjotNCxaX0JVRl9FUlJPUjotNSxaX05PX0NPTVBSRVNTSU9OOjAsWl9CRVNUX1NQRUVEOjEsWl9CRVNUX0NPTVBSRVNTSU9OOjksWl9ERUZBVUxUX0NPTVBSRVNTSU9OOi0xLFpfRklMVEVSRUQ6MSxaX0hVRkZNQU5fT05MWToyLFpfUkxFOjMsWl9GSVhFRDo0LFpfREVGQVVMVF9TVFJBVEVHWTowLFpfQklOQVJZOjAsWl9URVhUOjEsWl9VTktOT1dOOjIsWl9ERUZMQVRFRDo4fTtjb25zdHtfdHJfaW5pdDpwdCxfdHJfc3RvcmVkX2Jsb2NrOmd0LF90cl9mbHVzaF9ibG9jazp5dCxfdHJfdGFsbHk6d3QsX3RyX2FsaWduOnZ0fT1odCx7Wl9OT19GTFVTSDptdCxaX1BBUlRJQUxfRkxVU0g6YnQsWl9GVUxMX0ZMVVNIOnh0LFpfRklOSVNIOmt0LFpfQkxPQ0s6enQsWl9PSzpBdCxaX1NUUkVBTV9FTkQ6RXQsWl9TVFJFQU1fRVJST1I6U3QsWl9EQVRBX0VSUk9SOkJ0LFpfQlVGX0VSUk9SOk90LFpfREVGQVVMVF9DT01QUkVTU0lPTjpMdCxaX0ZJTFRFUkVEOlJ0LFpfSFVGRk1BTl9PTkxZOkR0LFpfUkxFOlV0LFpfRklYRUQ6Q3QsWl9ERUZBVUxUX1NUUkFURUdZOlR0LFpfVU5LTk9XTjpGdCxaX0RFRkxBVEVEOkh0fT1mdCxadD05LE10PTE1LE50PTgsSXQ9Mjg2LGp0PTMwLFB0PTE5LCR0PTIqSXQrMSxLdD0xNSxYdD0zLEd0PTI1OCxXdD1HdCtYdCsxLFl0PTMyLHF0PTQyLFZ0PTU3LFF0PTY5LEp0PTczLHRlPTkxLGVlPTEwMyxyZT0xMTMsbmU9NjY2LGllPTEsYWU9MixzZT0zLG9lPTQsbGU9MyxoZT0odCxlKT0+KHQubXNnPWR0W2VdLGUpLGNlPXQ9PjIqdC0odD40Pzk6MCksdWU9dD0+e2xldCBlPXQubGVuZ3RoO2Zvcig7LS1lPj0wOyl0W2VdPTB9LF9lPXQ9PntsZXQgZSxyLG4saT10Lndfc2l6ZTtlPXQuaGFzaF9zaXplLG49ZTtkb3tyPXQuaGVhZFstLW5dLHQuaGVhZFtuXT1yPj1pP3ItaTowfXdoaWxlKC0tZSk7ZT1pLG49ZTtkb3tyPXQucHJldlstLW5dLHQucHJldltuXT1yPj1pP3ItaTowfXdoaWxlKC0tZSl9O2xldCBkZT0odCxlLHIpPT4oZTw8dC5oYXNoX3NoaWZ0XnIpJnQuaGFzaF9tYXNrO2NvbnN0IGZlPXQ9Pntjb25zdCBlPXQuc3RhdGU7bGV0IHI9ZS5wZW5kaW5nO3I+dC5hdmFpbF9vdXQmJihyPXQuYXZhaWxfb3V0KSwwIT09ciYmKHQub3V0cHV0LnNldChlLnBlbmRpbmdfYnVmLnN1YmFycmF5KGUucGVuZGluZ19vdXQsZS5wZW5kaW5nX291dCtyKSx0Lm5leHRfb3V0KSx0Lm5leHRfb3V0Kz1yLGUucGVuZGluZ19vdXQrPXIsdC50b3RhbF9vdXQrPXIsdC5hdmFpbF9vdXQtPXIsZS5wZW5kaW5nLT1yLDA9PT1lLnBlbmRpbmcmJihlLnBlbmRpbmdfb3V0PTApKX0scGU9KHQsZSk9Pnt5dCh0LHQuYmxvY2tfc3RhcnQ+PTA/dC5ibG9ja19zdGFydDotMSx0LnN0cnN0YXJ0LXQuYmxvY2tfc3RhcnQsZSksdC5ibG9ja19zdGFydD10LnN0cnN0YXJ0LGZlKHQuc3RybSl9LGdlPSh0LGUpPT57dC5wZW5kaW5nX2J1Zlt0LnBlbmRpbmcrK109ZX0seWU9KHQsZSk9Pnt0LnBlbmRpbmdfYnVmW3QucGVuZGluZysrXT1lPj4+OCYyNTUsdC5wZW5kaW5nX2J1Zlt0LnBlbmRpbmcrK109MjU1JmV9LHdlPSh0LGUscixuKT0+e2xldCBpPXQuYXZhaWxfaW47cmV0dXJuIGk+biYmKGk9biksMD09PWk/MDoodC5hdmFpbF9pbi09aSxlLnNldCh0LmlucHV0LnN1YmFycmF5KHQubmV4dF9pbix0Lm5leHRfaW4raSksciksMT09PXQuc3RhdGUud3JhcD90LmFkbGVyPWN0KHQuYWRsZXIsZSxpLHIpOjI9PT10LnN0YXRlLndyYXAmJih0LmFkbGVyPV90KHQuYWRsZXIsZSxpLHIpKSx0Lm5leHRfaW4rPWksdC50b3RhbF9pbis9aSxpKX0sdmU9KHQsZSk9PntsZXQgcixuLGk9dC5tYXhfY2hhaW5fbGVuZ3RoLGE9dC5zdHJzdGFydCxzPXQucHJldl9sZW5ndGgsbz10Lm5pY2VfbWF0Y2g7Y29uc3QgbD10LnN0cnN0YXJ0PnQud19zaXplLVd0P3Quc3Ryc3RhcnQtKHQud19zaXplLVd0KTowLGg9dC53aW5kb3csYz10LndfbWFzayx1PXQucHJldixfPXQuc3Ryc3RhcnQrR3Q7bGV0IGQ9aFthK3MtMV0sZj1oW2Erc107dC5wcmV2X2xlbmd0aD49dC5nb29kX21hdGNoJiYoaT4+PTIpLG8+dC5sb29rYWhlYWQmJihvPXQubG9va2FoZWFkKTtkb3tpZihyPWUsaFtyK3NdPT09ZiYmaFtyK3MtMV09PT1kJiZoW3JdPT09aFthXSYmaFsrK3JdPT09aFthKzFdKXthKz0yLHIrKztkb3t9d2hpbGUoaFsrK2FdPT09aFsrK3JdJiZoWysrYV09PT1oWysrcl0mJmhbKythXT09PWhbKytyXSYmaFsrK2FdPT09aFsrK3JdJiZoWysrYV09PT1oWysrcl0mJmhbKythXT09PWhbKytyXSYmaFsrK2FdPT09aFsrK3JdJiZoWysrYV09PT1oWysrcl0mJmE8Xyk7aWYobj1HdC0oXy1hKSxhPV8tR3Qsbj5zKXtpZih0Lm1hdGNoX3N0YXJ0PWUscz1uLG4+PW8pYnJlYWs7ZD1oW2Ercy0xXSxmPWhbYStzXX19fXdoaWxlKChlPXVbZSZjXSk+bCYmMCE9LS1pKTtyZXR1cm4gczw9dC5sb29rYWhlYWQ/czp0Lmxvb2thaGVhZH0sbWU9dD0+e2NvbnN0IGU9dC53X3NpemU7bGV0IHIsbixpO2Rve2lmKG49dC53aW5kb3dfc2l6ZS10Lmxvb2thaGVhZC10LnN0cnN0YXJ0LHQuc3Ryc3RhcnQ+PWUrKGUtV3QpJiYodC53aW5kb3cuc2V0KHQud2luZG93LnN1YmFycmF5KGUsZStlLW4pLDApLHQubWF0Y2hfc3RhcnQtPWUsdC5zdHJzdGFydC09ZSx0LmJsb2NrX3N0YXJ0LT1lLHQuaW5zZXJ0PnQuc3Ryc3RhcnQmJih0Lmluc2VydD10LnN0cnN0YXJ0KSxfZSh0KSxuKz1lKSwwPT09dC5zdHJtLmF2YWlsX2luKWJyZWFrO2lmKHI9d2UodC5zdHJtLHQud2luZG93LHQuc3Ryc3RhcnQrdC5sb29rYWhlYWQsbiksdC5sb29rYWhlYWQrPXIsdC5sb29rYWhlYWQrdC5pbnNlcnQ+PVh0KWZvcihpPXQuc3Ryc3RhcnQtdC5pbnNlcnQsdC5pbnNfaD10LndpbmRvd1tpXSx0Lmluc19oPWRlKHQsdC5pbnNfaCx0LndpbmRvd1tpKzFdKTt0Lmluc2VydCYmKHQuaW5zX2g9ZGUodCx0Lmluc19oLHQud2luZG93W2krWHQtMV0pLHQucHJldltpJnQud19tYXNrXT10LmhlYWRbdC5pbnNfaF0sdC5oZWFkW3QuaW5zX2hdPWksaSsrLHQuaW5zZXJ0LS0sISh0Lmxvb2thaGVhZCt0Lmluc2VydDxYdCkpOyk7fXdoaWxlKHQubG9va2FoZWFkPFd0JiYwIT09dC5zdHJtLmF2YWlsX2luKX0sYmU9KHQsZSk9PntsZXQgcixuLGksYT10LnBlbmRpbmdfYnVmX3NpemUtNT50Lndfc2l6ZT90Lndfc2l6ZTp0LnBlbmRpbmdfYnVmX3NpemUtNSxzPTAsbz10LnN0cm0uYXZhaWxfaW47ZG97aWYocj02NTUzNSxpPXQuYmlfdmFsaWQrNDI+PjMsdC5zdHJtLmF2YWlsX291dDxpKWJyZWFrO2lmKGk9dC5zdHJtLmF2YWlsX291dC1pLG49dC5zdHJzdGFydC10LmJsb2NrX3N0YXJ0LHI+bit0LnN0cm0uYXZhaWxfaW4mJihyPW4rdC5zdHJtLmF2YWlsX2luKSxyPmkmJihyPWkpLHI8YSYmKDA9PT1yJiZlIT09a3R8fGU9PT1tdHx8ciE9PW4rdC5zdHJtLmF2YWlsX2luKSlicmVhaztzPWU9PT1rdCYmcj09PW4rdC5zdHJtLmF2YWlsX2luPzE6MCxndCh0LDAsMCxzKSx0LnBlbmRpbmdfYnVmW3QucGVuZGluZy00XT1yLHQucGVuZGluZ19idWZbdC5wZW5kaW5nLTNdPXI+PjgsdC5wZW5kaW5nX2J1Zlt0LnBlbmRpbmctMl09fnIsdC5wZW5kaW5nX2J1Zlt0LnBlbmRpbmctMV09fnI+PjgsZmUodC5zdHJtKSxuJiYobj5yJiYobj1yKSx0LnN0cm0ub3V0cHV0LnNldCh0LndpbmRvdy5zdWJhcnJheSh0LmJsb2NrX3N0YXJ0LHQuYmxvY2tfc3RhcnQrbiksdC5zdHJtLm5leHRfb3V0KSx0LnN0cm0ubmV4dF9vdXQrPW4sdC5zdHJtLmF2YWlsX291dC09bix0LnN0cm0udG90YWxfb3V0Kz1uLHQuYmxvY2tfc3RhcnQrPW4sci09biksciYmKHdlKHQuc3RybSx0LnN0cm0ub3V0cHV0LHQuc3RybS5uZXh0X291dCxyKSx0LnN0cm0ubmV4dF9vdXQrPXIsdC5zdHJtLmF2YWlsX291dC09cix0LnN0cm0udG90YWxfb3V0Kz1yKX13aGlsZSgwPT09cyk7cmV0dXJuIG8tPXQuc3RybS5hdmFpbF9pbixvJiYobz49dC53X3NpemU/KHQubWF0Y2hlcz0yLHQud2luZG93LnNldCh0LnN0cm0uaW5wdXQuc3ViYXJyYXkodC5zdHJtLm5leHRfaW4tdC53X3NpemUsdC5zdHJtLm5leHRfaW4pLDApLHQuc3Ryc3RhcnQ9dC53X3NpemUsdC5pbnNlcnQ9dC5zdHJzdGFydCk6KHQud2luZG93X3NpemUtdC5zdHJzdGFydDw9byYmKHQuc3Ryc3RhcnQtPXQud19zaXplLHQud2luZG93LnNldCh0LndpbmRvdy5zdWJhcnJheSh0Lndfc2l6ZSx0Lndfc2l6ZSt0LnN0cnN0YXJ0KSwwKSx0Lm1hdGNoZXM8MiYmdC5tYXRjaGVzKyssdC5pbnNlcnQ+dC5zdHJzdGFydCYmKHQuaW5zZXJ0PXQuc3Ryc3RhcnQpKSx0LndpbmRvdy5zZXQodC5zdHJtLmlucHV0LnN1YmFycmF5KHQuc3RybS5uZXh0X2luLW8sdC5zdHJtLm5leHRfaW4pLHQuc3Ryc3RhcnQpLHQuc3Ryc3RhcnQrPW8sdC5pbnNlcnQrPW8+dC53X3NpemUtdC5pbnNlcnQ/dC53X3NpemUtdC5pbnNlcnQ6byksdC5ibG9ja19zdGFydD10LnN0cnN0YXJ0KSx0LmhpZ2hfd2F0ZXI8dC5zdHJzdGFydCYmKHQuaGlnaF93YXRlcj10LnN0cnN0YXJ0KSxzP29lOmUhPT1tdCYmZSE9PWt0JiYwPT09dC5zdHJtLmF2YWlsX2luJiZ0LnN0cnN0YXJ0PT09dC5ibG9ja19zdGFydD9hZTooaT10LndpbmRvd19zaXplLXQuc3Ryc3RhcnQsdC5zdHJtLmF2YWlsX2luPmkmJnQuYmxvY2tfc3RhcnQ+PXQud19zaXplJiYodC5ibG9ja19zdGFydC09dC53X3NpemUsdC5zdHJzdGFydC09dC53X3NpemUsdC53aW5kb3cuc2V0KHQud2luZG93LnN1YmFycmF5KHQud19zaXplLHQud19zaXplK3Quc3Ryc3RhcnQpLDApLHQubWF0Y2hlczwyJiZ0Lm1hdGNoZXMrKyxpKz10Lndfc2l6ZSx0Lmluc2VydD50LnN0cnN0YXJ0JiYodC5pbnNlcnQ9dC5zdHJzdGFydCkpLGk+dC5zdHJtLmF2YWlsX2luJiYoaT10LnN0cm0uYXZhaWxfaW4pLGkmJih3ZSh0LnN0cm0sdC53aW5kb3csdC5zdHJzdGFydCxpKSx0LnN0cnN0YXJ0Kz1pLHQuaW5zZXJ0Kz1pPnQud19zaXplLXQuaW5zZXJ0P3Qud19zaXplLXQuaW5zZXJ0OmkpLHQuaGlnaF93YXRlcjx0LnN0cnN0YXJ0JiYodC5oaWdoX3dhdGVyPXQuc3Ryc3RhcnQpLGk9dC5iaV92YWxpZCs0Mj4+MyxpPXQucGVuZGluZ19idWZfc2l6ZS1pPjY1NTM1PzY1NTM1OnQucGVuZGluZ19idWZfc2l6ZS1pLGE9aT50Lndfc2l6ZT90Lndfc2l6ZTppLG49dC5zdHJzdGFydC10LmJsb2NrX3N0YXJ0LChuPj1hfHwobnx8ZT09PWt0KSYmZSE9PW10JiYwPT09dC5zdHJtLmF2YWlsX2luJiZuPD1pKSYmKHI9bj5pP2k6bixzPWU9PT1rdCYmMD09PXQuc3RybS5hdmFpbF9pbiYmcj09PW4/MTowLGd0KHQsdC5ibG9ja19zdGFydCxyLHMpLHQuYmxvY2tfc3RhcnQrPXIsZmUodC5zdHJtKSkscz9zZTppZSl9LHhlPSh0LGUpPT57bGV0IHIsbjtmb3IoOzspe2lmKHQubG9va2FoZWFkPFd0KXtpZihtZSh0KSx0Lmxvb2thaGVhZDxXdCYmZT09PW10KXJldHVybiBpZTtpZigwPT09dC5sb29rYWhlYWQpYnJlYWt9aWYocj0wLHQubG9va2FoZWFkPj1YdCYmKHQuaW5zX2g9ZGUodCx0Lmluc19oLHQud2luZG93W3Quc3Ryc3RhcnQrWHQtMV0pLHI9dC5wcmV2W3Quc3Ryc3RhcnQmdC53X21hc2tdPXQuaGVhZFt0Lmluc19oXSx0LmhlYWRbdC5pbnNfaF09dC5zdHJzdGFydCksMCE9PXImJnQuc3Ryc3RhcnQtcjw9dC53X3NpemUtV3QmJih0Lm1hdGNoX2xlbmd0aD12ZSh0LHIpKSx0Lm1hdGNoX2xlbmd0aD49WHQpaWYobj13dCh0LHQuc3Ryc3RhcnQtdC5tYXRjaF9zdGFydCx0Lm1hdGNoX2xlbmd0aC1YdCksdC5sb29rYWhlYWQtPXQubWF0Y2hfbGVuZ3RoLHQubWF0Y2hfbGVuZ3RoPD10Lm1heF9sYXp5X21hdGNoJiZ0Lmxvb2thaGVhZD49WHQpe3QubWF0Y2hfbGVuZ3RoLS07ZG97dC5zdHJzdGFydCsrLHQuaW5zX2g9ZGUodCx0Lmluc19oLHQud2luZG93W3Quc3Ryc3RhcnQrWHQtMV0pLHI9dC5wcmV2W3Quc3Ryc3RhcnQmdC53X21hc2tdPXQuaGVhZFt0Lmluc19oXSx0LmhlYWRbdC5pbnNfaF09dC5zdHJzdGFydH13aGlsZSgwIT0tLXQubWF0Y2hfbGVuZ3RoKTt0LnN0cnN0YXJ0Kyt9ZWxzZSB0LnN0cnN0YXJ0Kz10Lm1hdGNoX2xlbmd0aCx0Lm1hdGNoX2xlbmd0aD0wLHQuaW5zX2g9dC53aW5kb3dbdC5zdHJzdGFydF0sdC5pbnNfaD1kZSh0LHQuaW5zX2gsdC53aW5kb3dbdC5zdHJzdGFydCsxXSk7ZWxzZSBuPXd0KHQsMCx0LndpbmRvd1t0LnN0cnN0YXJ0XSksdC5sb29rYWhlYWQtLSx0LnN0cnN0YXJ0Kys7aWYobiYmKHBlKHQsITEpLDA9PT10LnN0cm0uYXZhaWxfb3V0KSlyZXR1cm4gaWV9cmV0dXJuIHQuaW5zZXJ0PXQuc3Ryc3RhcnQ8WHQtMT90LnN0cnN0YXJ0Olh0LTEsZT09PWt0PyhwZSh0LCEwKSwwPT09dC5zdHJtLmF2YWlsX291dD9zZTpvZSk6dC5zeW1fbmV4dCYmKHBlKHQsITEpLDA9PT10LnN0cm0uYXZhaWxfb3V0KT9pZTphZX0sa2U9KHQsZSk9PntsZXQgcixuLGk7Zm9yKDs7KXtpZih0Lmxvb2thaGVhZDxXdCl7aWYobWUodCksdC5sb29rYWhlYWQ8V3QmJmU9PT1tdClyZXR1cm4gaWU7aWYoMD09PXQubG9va2FoZWFkKWJyZWFrfWlmKHI9MCx0Lmxvb2thaGVhZD49WHQmJih0Lmluc19oPWRlKHQsdC5pbnNfaCx0LndpbmRvd1t0LnN0cnN0YXJ0K1h0LTFdKSxyPXQucHJldlt0LnN0cnN0YXJ0JnQud19tYXNrXT10LmhlYWRbdC5pbnNfaF0sdC5oZWFkW3QuaW5zX2hdPXQuc3Ryc3RhcnQpLHQucHJldl9sZW5ndGg9dC5tYXRjaF9sZW5ndGgsdC5wcmV2X21hdGNoPXQubWF0Y2hfc3RhcnQsdC5tYXRjaF9sZW5ndGg9WHQtMSwwIT09ciYmdC5wcmV2X2xlbmd0aDx0Lm1heF9sYXp5X21hdGNoJiZ0LnN0cnN0YXJ0LXI8PXQud19zaXplLVd0JiYodC5tYXRjaF9sZW5ndGg9dmUodCxyKSx0Lm1hdGNoX2xlbmd0aDw9NSYmKHQuc3RyYXRlZ3k9PT1SdHx8dC5tYXRjaF9sZW5ndGg9PT1YdCYmdC5zdHJzdGFydC10Lm1hdGNoX3N0YXJ0PjQwOTYpJiYodC5tYXRjaF9sZW5ndGg9WHQtMSkpLHQucHJldl9sZW5ndGg+PVh0JiZ0Lm1hdGNoX2xlbmd0aDw9dC5wcmV2X2xlbmd0aCl7aT10LnN0cnN0YXJ0K3QubG9va2FoZWFkLVh0LG49d3QodCx0LnN0cnN0YXJ0LTEtdC5wcmV2X21hdGNoLHQucHJldl9sZW5ndGgtWHQpLHQubG9va2FoZWFkLT10LnByZXZfbGVuZ3RoLTEsdC5wcmV2X2xlbmd0aC09Mjtkb3srK3Quc3Ryc3RhcnQ8PWkmJih0Lmluc19oPWRlKHQsdC5pbnNfaCx0LndpbmRvd1t0LnN0cnN0YXJ0K1h0LTFdKSxyPXQucHJldlt0LnN0cnN0YXJ0JnQud19tYXNrXT10LmhlYWRbdC5pbnNfaF0sdC5oZWFkW3QuaW5zX2hdPXQuc3Ryc3RhcnQpfXdoaWxlKDAhPS0tdC5wcmV2X2xlbmd0aCk7aWYodC5tYXRjaF9hdmFpbGFibGU9MCx0Lm1hdGNoX2xlbmd0aD1YdC0xLHQuc3Ryc3RhcnQrKyxuJiYocGUodCwhMSksMD09PXQuc3RybS5hdmFpbF9vdXQpKXJldHVybiBpZX1lbHNlIGlmKHQubWF0Y2hfYXZhaWxhYmxlKXtpZihuPXd0KHQsMCx0LndpbmRvd1t0LnN0cnN0YXJ0LTFdKSxuJiZwZSh0LCExKSx0LnN0cnN0YXJ0KyssdC5sb29rYWhlYWQtLSwwPT09dC5zdHJtLmF2YWlsX291dClyZXR1cm4gaWV9ZWxzZSB0Lm1hdGNoX2F2YWlsYWJsZT0xLHQuc3Ryc3RhcnQrKyx0Lmxvb2thaGVhZC0tfXJldHVybiB0Lm1hdGNoX2F2YWlsYWJsZSYmKG49d3QodCwwLHQud2luZG93W3Quc3Ryc3RhcnQtMV0pLHQubWF0Y2hfYXZhaWxhYmxlPTApLHQuaW5zZXJ0PXQuc3Ryc3RhcnQ8WHQtMT90LnN0cnN0YXJ0Olh0LTEsZT09PWt0PyhwZSh0LCEwKSwwPT09dC5zdHJtLmF2YWlsX291dD9zZTpvZSk6dC5zeW1fbmV4dCYmKHBlKHQsITEpLDA9PT10LnN0cm0uYXZhaWxfb3V0KT9pZTphZX0semU9KHQsZSk9PntsZXQgcixuLGksYTtjb25zdCBzPXQud2luZG93O2Zvcig7Oyl7aWYodC5sb29rYWhlYWQ8PUd0KXtpZihtZSh0KSx0Lmxvb2thaGVhZDw9R3QmJmU9PT1tdClyZXR1cm4gaWU7aWYoMD09PXQubG9va2FoZWFkKWJyZWFrfWlmKHQubWF0Y2hfbGVuZ3RoPTAsdC5sb29rYWhlYWQ+PVh0JiZ0LnN0cnN0YXJ0PjAmJihpPXQuc3Ryc3RhcnQtMSxuPXNbaV0sbj09PXNbKytpXSYmbj09PXNbKytpXSYmbj09PXNbKytpXSkpe2E9dC5zdHJzdGFydCtHdDtkb3t9d2hpbGUobj09PXNbKytpXSYmbj09PXNbKytpXSYmbj09PXNbKytpXSYmbj09PXNbKytpXSYmbj09PXNbKytpXSYmbj09PXNbKytpXSYmbj09PXNbKytpXSYmbj09PXNbKytpXSYmaTxhKTt0Lm1hdGNoX2xlbmd0aD1HdC0oYS1pKSx0Lm1hdGNoX2xlbmd0aD50Lmxvb2thaGVhZCYmKHQubWF0Y2hfbGVuZ3RoPXQubG9va2FoZWFkKX1pZih0Lm1hdGNoX2xlbmd0aD49WHQ/KHI9d3QodCwxLHQubWF0Y2hfbGVuZ3RoLVh0KSx0Lmxvb2thaGVhZC09dC5tYXRjaF9sZW5ndGgsdC5zdHJzdGFydCs9dC5tYXRjaF9sZW5ndGgsdC5tYXRjaF9sZW5ndGg9MCk6KHI9d3QodCwwLHQud2luZG93W3Quc3Ryc3RhcnRdKSx0Lmxvb2thaGVhZC0tLHQuc3Ryc3RhcnQrKyksciYmKHBlKHQsITEpLDA9PT10LnN0cm0uYXZhaWxfb3V0KSlyZXR1cm4gaWV9cmV0dXJuIHQuaW5zZXJ0PTAsZT09PWt0PyhwZSh0LCEwKSwwPT09dC5zdHJtLmF2YWlsX291dD9zZTpvZSk6dC5zeW1fbmV4dCYmKHBlKHQsITEpLDA9PT10LnN0cm0uYXZhaWxfb3V0KT9pZTphZX0sQWU9KHQsZSk9PntsZXQgcjtmb3IoOzspe2lmKDA9PT10Lmxvb2thaGVhZCYmKG1lKHQpLDA9PT10Lmxvb2thaGVhZCkpe2lmKGU9PT1tdClyZXR1cm4gaWU7YnJlYWt9aWYodC5tYXRjaF9sZW5ndGg9MCxyPXd0KHQsMCx0LndpbmRvd1t0LnN0cnN0YXJ0XSksdC5sb29rYWhlYWQtLSx0LnN0cnN0YXJ0KyssciYmKHBlKHQsITEpLDA9PT10LnN0cm0uYXZhaWxfb3V0KSlyZXR1cm4gaWV9cmV0dXJuIHQuaW5zZXJ0PTAsZT09PWt0PyhwZSh0LCEwKSwwPT09dC5zdHJtLmF2YWlsX291dD9zZTpvZSk6dC5zeW1fbmV4dCYmKHBlKHQsITEpLDA9PT10LnN0cm0uYXZhaWxfb3V0KT9pZTphZX07ZnVuY3Rpb24gRWUodCxlLHIsbixpKXt0aGlzLmdvb2RfbGVuZ3RoPXQsdGhpcy5tYXhfbGF6eT1lLHRoaXMubmljZV9sZW5ndGg9cix0aGlzLm1heF9jaGFpbj1uLHRoaXMuZnVuYz1pfWNvbnN0IFNlPVtuZXcgRWUoMCwwLDAsMCxiZSksbmV3IEVlKDQsNCw4LDQseGUpLG5ldyBFZSg0LDUsMTYsOCx4ZSksbmV3IEVlKDQsNiwzMiwzMix4ZSksbmV3IEVlKDQsNCwxNiwxNixrZSksbmV3IEVlKDgsMTYsMzIsMzIsa2UpLG5ldyBFZSg4LDE2LDEyOCwxMjgsa2UpLG5ldyBFZSg4LDMyLDEyOCwyNTYsa2UpLG5ldyBFZSgzMiwxMjgsMjU4LDEwMjQsa2UpLG5ldyBFZSgzMiwyNTgsMjU4LDQwOTYsa2UpXSxCZT10PT57dC53aW5kb3dfc2l6ZT0yKnQud19zaXplLHVlKHQuaGVhZCksdC5tYXhfbGF6eV9tYXRjaD1TZVt0LmxldmVsXS5tYXhfbGF6eSx0Lmdvb2RfbWF0Y2g9U2VbdC5sZXZlbF0uZ29vZF9sZW5ndGgsdC5uaWNlX21hdGNoPVNlW3QubGV2ZWxdLm5pY2VfbGVuZ3RoLHQubWF4X2NoYWluX2xlbmd0aD1TZVt0LmxldmVsXS5tYXhfY2hhaW4sdC5zdHJzdGFydD0wLHQuYmxvY2tfc3RhcnQ9MCx0Lmxvb2thaGVhZD0wLHQuaW5zZXJ0PTAsdC5tYXRjaF9sZW5ndGg9dC5wcmV2X2xlbmd0aD1YdC0xLHQubWF0Y2hfYXZhaWxhYmxlPTAsdC5pbnNfaD0wfTtmdW5jdGlvbiBPZSgpe3RoaXMuc3RybT1udWxsLHRoaXMuc3RhdHVzPTAsdGhpcy5wZW5kaW5nX2J1Zj1udWxsLHRoaXMucGVuZGluZ19idWZfc2l6ZT0wLHRoaXMucGVuZGluZ19vdXQ9MCx0aGlzLnBlbmRpbmc9MCx0aGlzLndyYXA9MCx0aGlzLmd6aGVhZD1udWxsLHRoaXMuZ3ppbmRleD0wLHRoaXMubWV0aG9kPUh0LHRoaXMubGFzdF9mbHVzaD0tMSx0aGlzLndfc2l6ZT0wLHRoaXMud19iaXRzPTAsdGhpcy53X21hc2s9MCx0aGlzLndpbmRvdz1udWxsLHRoaXMud2luZG93X3NpemU9MCx0aGlzLnByZXY9bnVsbCx0aGlzLmhlYWQ9bnVsbCx0aGlzLmluc19oPTAsdGhpcy5oYXNoX3NpemU9MCx0aGlzLmhhc2hfYml0cz0wLHRoaXMuaGFzaF9tYXNrPTAsdGhpcy5oYXNoX3NoaWZ0PTAsdGhpcy5ibG9ja19zdGFydD0wLHRoaXMubWF0Y2hfbGVuZ3RoPTAsdGhpcy5wcmV2X21hdGNoPTAsdGhpcy5tYXRjaF9hdmFpbGFibGU9MCx0aGlzLnN0cnN0YXJ0PTAsdGhpcy5tYXRjaF9zdGFydD0wLHRoaXMubG9va2FoZWFkPTAsdGhpcy5wcmV2X2xlbmd0aD0wLHRoaXMubWF4X2NoYWluX2xlbmd0aD0wLHRoaXMubWF4X2xhenlfbWF0Y2g9MCx0aGlzLmxldmVsPTAsdGhpcy5zdHJhdGVneT0wLHRoaXMuZ29vZF9tYXRjaD0wLHRoaXMubmljZV9tYXRjaD0wLHRoaXMuZHluX2x0cmVlPW5ldyBVaW50MTZBcnJheSgyKiR0KSx0aGlzLmR5bl9kdHJlZT1uZXcgVWludDE2QXJyYXkoMiooMipqdCsxKSksdGhpcy5ibF90cmVlPW5ldyBVaW50MTZBcnJheSgyKigyKlB0KzEpKSx1ZSh0aGlzLmR5bl9sdHJlZSksdWUodGhpcy5keW5fZHRyZWUpLHVlKHRoaXMuYmxfdHJlZSksdGhpcy5sX2Rlc2M9bnVsbCx0aGlzLmRfZGVzYz1udWxsLHRoaXMuYmxfZGVzYz1udWxsLHRoaXMuYmxfY291bnQ9bmV3IFVpbnQxNkFycmF5KEt0KzEpLHRoaXMuaGVhcD1uZXcgVWludDE2QXJyYXkoMipJdCsxKSx1ZSh0aGlzLmhlYXApLHRoaXMuaGVhcF9sZW49MCx0aGlzLmhlYXBfbWF4PTAsdGhpcy5kZXB0aD1uZXcgVWludDE2QXJyYXkoMipJdCsxKSx1ZSh0aGlzLmRlcHRoKSx0aGlzLnN5bV9idWY9MCx0aGlzLmxpdF9idWZzaXplPTAsdGhpcy5zeW1fbmV4dD0wLHRoaXMuc3ltX2VuZD0wLHRoaXMub3B0X2xlbj0wLHRoaXMuc3RhdGljX2xlbj0wLHRoaXMubWF0Y2hlcz0wLHRoaXMuaW5zZXJ0PTAsdGhpcy5iaV9idWY9MCx0aGlzLmJpX3ZhbGlkPTB9Y29uc3QgTGU9dD0+e2lmKCF0KXJldHVybiAxO2NvbnN0IGU9dC5zdGF0ZTtyZXR1cm4hZXx8ZS5zdHJtIT09dHx8ZS5zdGF0dXMhPT1xdCYmZS5zdGF0dXMhPT1WdCYmZS5zdGF0dXMhPT1RdCYmZS5zdGF0dXMhPT1KdCYmZS5zdGF0dXMhPT10ZSYmZS5zdGF0dXMhPT1lZSYmZS5zdGF0dXMhPT1yZSYmZS5zdGF0dXMhPT1uZT8xOjB9LFJlPXQ9PntpZihMZSh0KSlyZXR1cm4gaGUodCxTdCk7dC50b3RhbF9pbj10LnRvdGFsX291dD0wLHQuZGF0YV90eXBlPUZ0O2NvbnN0IGU9dC5zdGF0ZTtyZXR1cm4gZS5wZW5kaW5nPTAsZS5wZW5kaW5nX291dD0wLGUud3JhcDwwJiYoZS53cmFwPS1lLndyYXApLGUuc3RhdHVzPTI9PT1lLndyYXA/VnQ6ZS53cmFwP3F0OnJlLHQuYWRsZXI9Mj09PWUud3JhcD8wOjEsZS5sYXN0X2ZsdXNoPS0yLHB0KGUpLEF0fSxEZT10PT57Y29uc3QgZT1SZSh0KTtyZXR1cm4gZT09PUF0JiZCZSh0LnN0YXRlKSxlfSxVZT0odCxlLHIsbixpLGEpPT57aWYoIXQpcmV0dXJuIFN0O2xldCBzPTE7aWYoZT09PUx0JiYoZT02KSxuPDA/KHM9MCxuPS1uKTpuPjE1JiYocz0yLG4tPTE2KSxpPDF8fGk+WnR8fHIhPT1IdHx8bjw4fHxuPjE1fHxlPDB8fGU+OXx8YTwwfHxhPkN0fHw4PT09biYmMSE9PXMpcmV0dXJuIGhlKHQsU3QpOzg9PT1uJiYobj05KTtjb25zdCBvPW5ldyBPZTtyZXR1cm4gdC5zdGF0ZT1vLG8uc3RybT10LG8uc3RhdHVzPXF0LG8ud3JhcD1zLG8uZ3poZWFkPW51bGwsby53X2JpdHM9bixvLndfc2l6ZT0xPDxvLndfYml0cyxvLndfbWFzaz1vLndfc2l6ZS0xLG8uaGFzaF9iaXRzPWkrNyxvLmhhc2hfc2l6ZT0xPDxvLmhhc2hfYml0cyxvLmhhc2hfbWFzaz1vLmhhc2hfc2l6ZS0xLG8uaGFzaF9zaGlmdD1+figoby5oYXNoX2JpdHMrWHQtMSkvWHQpLG8ud2luZG93PW5ldyBVaW50OEFycmF5KDIqby53X3NpemUpLG8uaGVhZD1uZXcgVWludDE2QXJyYXkoby5oYXNoX3NpemUpLG8ucHJldj1uZXcgVWludDE2QXJyYXkoby53X3NpemUpLG8ubGl0X2J1ZnNpemU9MTw8aSs2LG8ucGVuZGluZ19idWZfc2l6ZT00Km8ubGl0X2J1ZnNpemUsby5wZW5kaW5nX2J1Zj1uZXcgVWludDhBcnJheShvLnBlbmRpbmdfYnVmX3NpemUpLG8uc3ltX2J1Zj1vLmxpdF9idWZzaXplLG8uc3ltX2VuZD0zKihvLmxpdF9idWZzaXplLTEpLG8ubGV2ZWw9ZSxvLnN0cmF0ZWd5PWEsby5tZXRob2Q9cixEZSh0KX07dmFyIENlPXtkZWZsYXRlSW5pdDoodCxlKT0+VWUodCxlLEh0LE10LE50LFR0KSxkZWZsYXRlSW5pdDI6VWUsZGVmbGF0ZVJlc2V0OkRlLGRlZmxhdGVSZXNldEtlZXA6UmUsZGVmbGF0ZVNldEhlYWRlcjoodCxlKT0+TGUodCl8fDIhPT10LnN0YXRlLndyYXA/U3Q6KHQuc3RhdGUuZ3poZWFkPWUsQXQpLGRlZmxhdGU6KHQsZSk9PntpZihMZSh0KXx8ZT56dHx8ZTwwKXJldHVybiB0P2hlKHQsU3QpOlN0O2NvbnN0IHI9dC5zdGF0ZTtpZighdC5vdXRwdXR8fDAhPT10LmF2YWlsX2luJiYhdC5pbnB1dHx8ci5zdGF0dXM9PT1uZSYmZSE9PWt0KXJldHVybiBoZSh0LDA9PT10LmF2YWlsX291dD9PdDpTdCk7Y29uc3Qgbj1yLmxhc3RfZmx1c2g7aWYoci5sYXN0X2ZsdXNoPWUsMCE9PXIucGVuZGluZyl7aWYoZmUodCksMD09PXQuYXZhaWxfb3V0KXJldHVybiByLmxhc3RfZmx1c2g9LTEsQXR9ZWxzZSBpZigwPT09dC5hdmFpbF9pbiYmY2UoZSk8PWNlKG4pJiZlIT09a3QpcmV0dXJuIGhlKHQsT3QpO2lmKHIuc3RhdHVzPT09bmUmJjAhPT10LmF2YWlsX2luKXJldHVybiBoZSh0LE90KTtpZihyLnN0YXR1cz09PXF0JiYwPT09ci53cmFwJiYoci5zdGF0dXM9cmUpLHIuc3RhdHVzPT09cXQpe2xldCBlPUh0KyhyLndfYml0cy04PDw0KTw8OCxuPS0xO2lmKG49ci5zdHJhdGVneT49RHR8fHIubGV2ZWw8Mj8wOnIubGV2ZWw8Nj8xOjY9PT1yLmxldmVsPzI6MyxlfD1uPDw2LDAhPT1yLnN0cnN0YXJ0JiYoZXw9WXQpLGUrPTMxLWUlMzEseWUocixlKSwwIT09ci5zdHJzdGFydCYmKHllKHIsdC5hZGxlcj4+PjE2KSx5ZShyLDY1NTM1JnQuYWRsZXIpKSx0LmFkbGVyPTEsci5zdGF0dXM9cmUsZmUodCksMCE9PXIucGVuZGluZylyZXR1cm4gci5sYXN0X2ZsdXNoPS0xLEF0fWlmKHIuc3RhdHVzPT09VnQpaWYodC5hZGxlcj0wLGdlKHIsMzEpLGdlKHIsMTM5KSxnZShyLDgpLHIuZ3poZWFkKWdlKHIsKHIuZ3poZWFkLnRleHQ/MTowKSsoci5nemhlYWQuaGNyYz8yOjApKyhyLmd6aGVhZC5leHRyYT80OjApKyhyLmd6aGVhZC5uYW1lPzg6MCkrKHIuZ3poZWFkLmNvbW1lbnQ/MTY6MCkpLGdlKHIsMjU1JnIuZ3poZWFkLnRpbWUpLGdlKHIsci5nemhlYWQudGltZT4+OCYyNTUpLGdlKHIsci5nemhlYWQudGltZT4+MTYmMjU1KSxnZShyLHIuZ3poZWFkLnRpbWU+PjI0JjI1NSksZ2Uociw5PT09ci5sZXZlbD8yOnIuc3RyYXRlZ3k+PUR0fHxyLmxldmVsPDI/NDowKSxnZShyLDI1NSZyLmd6aGVhZC5vcyksci5nemhlYWQuZXh0cmEmJnIuZ3poZWFkLmV4dHJhLmxlbmd0aCYmKGdlKHIsMjU1JnIuZ3poZWFkLmV4dHJhLmxlbmd0aCksZ2UocixyLmd6aGVhZC5leHRyYS5sZW5ndGg+PjgmMjU1KSksci5nemhlYWQuaGNyYyYmKHQuYWRsZXI9X3QodC5hZGxlcixyLnBlbmRpbmdfYnVmLHIucGVuZGluZywwKSksci5nemluZGV4PTAsci5zdGF0dXM9UXQ7ZWxzZSBpZihnZShyLDApLGdlKHIsMCksZ2UociwwKSxnZShyLDApLGdlKHIsMCksZ2Uociw5PT09ci5sZXZlbD8yOnIuc3RyYXRlZ3k+PUR0fHxyLmxldmVsPDI/NDowKSxnZShyLGxlKSxyLnN0YXR1cz1yZSxmZSh0KSwwIT09ci5wZW5kaW5nKXJldHVybiByLmxhc3RfZmx1c2g9LTEsQXQ7aWYoci5zdGF0dXM9PT1RdCl7aWYoci5nemhlYWQuZXh0cmEpe2xldCBlPXIucGVuZGluZyxuPSg2NTUzNSZyLmd6aGVhZC5leHRyYS5sZW5ndGgpLXIuZ3ppbmRleDtmb3IoO3IucGVuZGluZytuPnIucGVuZGluZ19idWZfc2l6ZTspe2xldCBpPXIucGVuZGluZ19idWZfc2l6ZS1yLnBlbmRpbmc7aWYoci5wZW5kaW5nX2J1Zi5zZXQoci5nemhlYWQuZXh0cmEuc3ViYXJyYXkoci5nemluZGV4LHIuZ3ppbmRleCtpKSxyLnBlbmRpbmcpLHIucGVuZGluZz1yLnBlbmRpbmdfYnVmX3NpemUsci5nemhlYWQuaGNyYyYmci5wZW5kaW5nPmUmJih0LmFkbGVyPV90KHQuYWRsZXIsci5wZW5kaW5nX2J1ZixyLnBlbmRpbmctZSxlKSksci5nemluZGV4Kz1pLGZlKHQpLDAhPT1yLnBlbmRpbmcpcmV0dXJuIHIubGFzdF9mbHVzaD0tMSxBdDtlPTAsbi09aX1sZXQgaT1uZXcgVWludDhBcnJheShyLmd6aGVhZC5leHRyYSk7ci5wZW5kaW5nX2J1Zi5zZXQoaS5zdWJhcnJheShyLmd6aW5kZXgsci5nemluZGV4K24pLHIucGVuZGluZyksci5wZW5kaW5nKz1uLHIuZ3poZWFkLmhjcmMmJnIucGVuZGluZz5lJiYodC5hZGxlcj1fdCh0LmFkbGVyLHIucGVuZGluZ19idWYsci5wZW5kaW5nLWUsZSkpLHIuZ3ppbmRleD0wfXIuc3RhdHVzPUp0fWlmKHIuc3RhdHVzPT09SnQpe2lmKHIuZ3poZWFkLm5hbWUpe2xldCBlLG49ci5wZW5kaW5nO2Rve2lmKHIucGVuZGluZz09PXIucGVuZGluZ19idWZfc2l6ZSl7aWYoci5nemhlYWQuaGNyYyYmci5wZW5kaW5nPm4mJih0LmFkbGVyPV90KHQuYWRsZXIsci5wZW5kaW5nX2J1ZixyLnBlbmRpbmctbixuKSksZmUodCksMCE9PXIucGVuZGluZylyZXR1cm4gci5sYXN0X2ZsdXNoPS0xLEF0O249MH1lPXIuZ3ppbmRleDxyLmd6aGVhZC5uYW1lLmxlbmd0aD8yNTUmci5nemhlYWQubmFtZS5jaGFyQ29kZUF0KHIuZ3ppbmRleCsrKTowLGdlKHIsZSl9d2hpbGUoMCE9PWUpO3IuZ3poZWFkLmhjcmMmJnIucGVuZGluZz5uJiYodC5hZGxlcj1fdCh0LmFkbGVyLHIucGVuZGluZ19idWYsci5wZW5kaW5nLW4sbikpLHIuZ3ppbmRleD0wfXIuc3RhdHVzPXRlfWlmKHIuc3RhdHVzPT09dGUpe2lmKHIuZ3poZWFkLmNvbW1lbnQpe2xldCBlLG49ci5wZW5kaW5nO2Rve2lmKHIucGVuZGluZz09PXIucGVuZGluZ19idWZfc2l6ZSl7aWYoci5nemhlYWQuaGNyYyYmci5wZW5kaW5nPm4mJih0LmFkbGVyPV90KHQuYWRsZXIsci5wZW5kaW5nX2J1ZixyLnBlbmRpbmctbixuKSksZmUodCksMCE9PXIucGVuZGluZylyZXR1cm4gci5sYXN0X2ZsdXNoPS0xLEF0O249MH1lPXIuZ3ppbmRleDxyLmd6aGVhZC5jb21tZW50Lmxlbmd0aD8yNTUmci5nemhlYWQuY29tbWVudC5jaGFyQ29kZUF0KHIuZ3ppbmRleCsrKTowLGdlKHIsZSl9d2hpbGUoMCE9PWUpO3IuZ3poZWFkLmhjcmMmJnIucGVuZGluZz5uJiYodC5hZGxlcj1fdCh0LmFkbGVyLHIucGVuZGluZ19idWYsci5wZW5kaW5nLW4sbikpfXIuc3RhdHVzPWVlfWlmKHIuc3RhdHVzPT09ZWUpe2lmKHIuZ3poZWFkLmhjcmMpe2lmKHIucGVuZGluZysyPnIucGVuZGluZ19idWZfc2l6ZSYmKGZlKHQpLDAhPT1yLnBlbmRpbmcpKXJldHVybiByLmxhc3RfZmx1c2g9LTEsQXQ7Z2UociwyNTUmdC5hZGxlciksZ2Uocix0LmFkbGVyPj44JjI1NSksdC5hZGxlcj0wfWlmKHIuc3RhdHVzPXJlLGZlKHQpLDAhPT1yLnBlbmRpbmcpcmV0dXJuIHIubGFzdF9mbHVzaD0tMSxBdH1pZigwIT09dC5hdmFpbF9pbnx8MCE9PXIubG9va2FoZWFkfHxlIT09bXQmJnIuc3RhdHVzIT09bmUpe2xldCBuPTA9PT1yLmxldmVsP2JlKHIsZSk6ci5zdHJhdGVneT09PUR0P0FlKHIsZSk6ci5zdHJhdGVneT09PVV0P3plKHIsZSk6U2Vbci5sZXZlbF0uZnVuYyhyLGUpO2lmKG4hPT1zZSYmbiE9PW9lfHwoci5zdGF0dXM9bmUpLG49PT1pZXx8bj09PXNlKXJldHVybiAwPT09dC5hdmFpbF9vdXQmJihyLmxhc3RfZmx1c2g9LTEpLEF0O2lmKG49PT1hZSYmKGU9PT1idD92dChyKTplIT09enQmJihndChyLDAsMCwhMSksZT09PXh0JiYodWUoci5oZWFkKSwwPT09ci5sb29rYWhlYWQmJihyLnN0cnN0YXJ0PTAsci5ibG9ja19zdGFydD0wLHIuaW5zZXJ0PTApKSksZmUodCksMD09PXQuYXZhaWxfb3V0KSlyZXR1cm4gci5sYXN0X2ZsdXNoPS0xLEF0fXJldHVybiBlIT09a3Q/QXQ6ci53cmFwPD0wP0V0OigyPT09ci53cmFwPyhnZShyLDI1NSZ0LmFkbGVyKSxnZShyLHQuYWRsZXI+PjgmMjU1KSxnZShyLHQuYWRsZXI+PjE2JjI1NSksZ2Uocix0LmFkbGVyPj4yNCYyNTUpLGdlKHIsMjU1JnQudG90YWxfaW4pLGdlKHIsdC50b3RhbF9pbj4+OCYyNTUpLGdlKHIsdC50b3RhbF9pbj4+MTYmMjU1KSxnZShyLHQudG90YWxfaW4+PjI0JjI1NSkpOih5ZShyLHQuYWRsZXI+Pj4xNikseWUociw2NTUzNSZ0LmFkbGVyKSksZmUodCksci53cmFwPjAmJihyLndyYXA9LXIud3JhcCksMCE9PXIucGVuZGluZz9BdDpFdCl9LGRlZmxhdGVFbmQ6dD0+e2lmKExlKHQpKXJldHVybiBTdDtjb25zdCBlPXQuc3RhdGUuc3RhdHVzO3JldHVybiB0LnN0YXRlPW51bGwsZT09PXJlP2hlKHQsQnQpOkF0fSxkZWZsYXRlU2V0RGljdGlvbmFyeToodCxlKT0+e2xldCByPWUubGVuZ3RoO2lmKExlKHQpKXJldHVybiBTdDtjb25zdCBuPXQuc3RhdGUsaT1uLndyYXA7aWYoMj09PWl8fDE9PT1pJiZuLnN0YXR1cyE9PXF0fHxuLmxvb2thaGVhZClyZXR1cm4gU3Q7aWYoMT09PWkmJih0LmFkbGVyPWN0KHQuYWRsZXIsZSxyLDApKSxuLndyYXA9MCxyPj1uLndfc2l6ZSl7MD09PWkmJih1ZShuLmhlYWQpLG4uc3Ryc3RhcnQ9MCxuLmJsb2NrX3N0YXJ0PTAsbi5pbnNlcnQ9MCk7bGV0IHQ9bmV3IFVpbnQ4QXJyYXkobi53X3NpemUpO3Quc2V0KGUuc3ViYXJyYXkoci1uLndfc2l6ZSxyKSwwKSxlPXQscj1uLndfc2l6ZX1jb25zdCBhPXQuYXZhaWxfaW4scz10Lm5leHRfaW4sbz10LmlucHV0O2Zvcih0LmF2YWlsX2luPXIsdC5uZXh0X2luPTAsdC5pbnB1dD1lLG1lKG4pO24ubG9va2FoZWFkPj1YdDspe2xldCB0PW4uc3Ryc3RhcnQsZT1uLmxvb2thaGVhZC0oWHQtMSk7ZG97bi5pbnNfaD1kZShuLG4uaW5zX2gsbi53aW5kb3dbdCtYdC0xXSksbi5wcmV2W3Qmbi53X21hc2tdPW4uaGVhZFtuLmluc19oXSxuLmhlYWRbbi5pbnNfaF09dCx0Kyt9d2hpbGUoLS1lKTtuLnN0cnN0YXJ0PXQsbi5sb29rYWhlYWQ9WHQtMSxtZShuKX1yZXR1cm4gbi5zdHJzdGFydCs9bi5sb29rYWhlYWQsbi5ibG9ja19zdGFydD1uLnN0cnN0YXJ0LG4uaW5zZXJ0PW4ubG9va2FoZWFkLG4ubG9va2FoZWFkPTAsbi5tYXRjaF9sZW5ndGg9bi5wcmV2X2xlbmd0aD1YdC0xLG4ubWF0Y2hfYXZhaWxhYmxlPTAsdC5uZXh0X2luPXMsdC5pbnB1dD1vLHQuYXZhaWxfaW49YSxuLndyYXA9aSxBdH0sZGVmbGF0ZUluZm86InBha28gZGVmbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCkifTtjb25zdCBUZT0odCxlKT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSk7dmFyIEZlPWZ1bmN0aW9uKHQpe2NvbnN0IGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO2Zvcig7ZS5sZW5ndGg7KXtjb25zdCByPWUuc2hpZnQoKTtpZihyKXtpZigib2JqZWN0IiE9dHlwZW9mIHIpdGhyb3cgbmV3IFR5cGVFcnJvcihyKyJtdXN0IGJlIG5vbi1vYmplY3QiKTtmb3IoY29uc3QgZSBpbiByKVRlKHIsZSkmJih0W2VdPXJbZV0pfX1yZXR1cm4gdH0sSGU9e2Fzc2lnbjpGZSxmbGF0dGVuQ2h1bmtzOnQ9PntsZXQgZT0wO2ZvcihsZXQgcj0wLG49dC5sZW5ndGg7cjxuO3IrKyllKz10W3JdLmxlbmd0aDtjb25zdCByPW5ldyBVaW50OEFycmF5KGUpO2ZvcihsZXQgZT0wLG49MCxpPXQubGVuZ3RoO2U8aTtlKyspe2xldCBpPXRbZV07ci5zZXQoaSxuKSxuKz1pLmxlbmd0aH1yZXR1cm4gcn19O2xldCBaZT0hMDt0cnl7U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLG5ldyBVaW50OEFycmF5KDEpKX1jYXRjaCh0KXtaZT0hMX1jb25zdCBNZT1uZXcgVWludDhBcnJheSgyNTYpO2ZvcihsZXQgdD0wO3Q8MjU2O3QrKylNZVt0XT10Pj0yNTI/Njp0Pj0yNDg/NTp0Pj0yNDA/NDp0Pj0yMjQ/Mzp0Pj0xOTI/MjoxO01lWzI1NF09TWVbMjU0XT0xO2NvbnN0IE5lPSh0LGUpPT57aWYoZTw2NTUzNCYmdC5zdWJhcnJheSYmWmUpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCx0Lmxlbmd0aD09PWU/dDp0LnN1YmFycmF5KDAsZSkpO2xldCByPSIiO2ZvcihsZXQgbj0wO248ZTtuKyspcis9U3RyaW5nLmZyb21DaGFyQ29kZSh0W25dKTtyZXR1cm4gcn07dmFyIEllPXtzdHJpbmcyYnVmOnQ9PntpZigiZnVuY3Rpb24iPT10eXBlb2YgVGV4dEVuY29kZXImJlRleHRFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUpcmV0dXJuKG5ldyBUZXh0RW5jb2RlcikuZW5jb2RlKHQpO2xldCBlLHIsbixpLGEscz10Lmxlbmd0aCxvPTA7Zm9yKGk9MDtpPHM7aSsrKXI9dC5jaGFyQ29kZUF0KGkpLDU1Mjk2PT0oNjQ1MTImcikmJmkrMTxzJiYobj10LmNoYXJDb2RlQXQoaSsxKSw1NjMyMD09KDY0NTEyJm4pJiYocj02NTUzNisoci01NTI5Njw8MTApKyhuLTU2MzIwKSxpKyspKSxvKz1yPDEyOD8xOnI8MjA0OD8yOnI8NjU1MzY/Mzo0O2ZvcihlPW5ldyBVaW50OEFycmF5KG8pLGE9MCxpPTA7YTxvO2krKylyPXQuY2hhckNvZGVBdChpKSw1NTI5Nj09KDY0NTEyJnIpJiZpKzE8cyYmKG49dC5jaGFyQ29kZUF0KGkrMSksNTYzMjA9PSg2NDUxMiZuKSYmKHI9NjU1MzYrKHItNTUyOTY8PDEwKSsobi01NjMyMCksaSsrKSkscjwxMjg/ZVthKytdPXI6cjwyMDQ4PyhlW2ErK109MTkyfHI+Pj42LGVbYSsrXT0xMjh8NjMmcik6cjw2NTUzNj8oZVthKytdPTIyNHxyPj4+MTIsZVthKytdPTEyOHxyPj4+NiY2MyxlW2ErK109MTI4fDYzJnIpOihlW2ErK109MjQwfHI+Pj4xOCxlW2ErK109MTI4fHI+Pj4xMiY2MyxlW2ErK109MTI4fHI+Pj42JjYzLGVbYSsrXT0xMjh8NjMmcik7cmV0dXJuIGV9LGJ1ZjJzdHJpbmc6KHQsZSk9Pntjb25zdCByPWV8fHQubGVuZ3RoO2lmKCJmdW5jdGlvbiI9PXR5cGVvZiBUZXh0RGVjb2RlciYmVGV4dERlY29kZXIucHJvdG90eXBlLmRlY29kZSlyZXR1cm4obmV3IFRleHREZWNvZGVyKS5kZWNvZGUodC5zdWJhcnJheSgwLGUpKTtsZXQgbixpO2NvbnN0IGE9bmV3IEFycmF5KDIqcik7Zm9yKGk9MCxuPTA7bjxyOyl7bGV0IGU9dFtuKytdO2lmKGU8MTI4KXthW2krK109ZTtjb250aW51ZX1sZXQgcz1NZVtlXTtpZihzPjQpYVtpKytdPTY1NTMzLG4rPXMtMTtlbHNle2ZvcihlJj0yPT09cz8zMTozPT09cz8xNTo3O3M+MSYmbjxyOyllPWU8PDZ8NjMmdFtuKytdLHMtLTtzPjE/YVtpKytdPTY1NTMzOmU8NjU1MzY/YVtpKytdPWU6KGUtPTY1NTM2LGFbaSsrXT01NTI5NnxlPj4xMCYxMDIzLGFbaSsrXT01NjMyMHwxMDIzJmUpfX1yZXR1cm4gTmUoYSxpKX0sdXRmOGJvcmRlcjoodCxlKT0+eyhlPWV8fHQubGVuZ3RoKT50Lmxlbmd0aCYmKGU9dC5sZW5ndGgpO2xldCByPWUtMTtmb3IoO3I+PTAmJjEyOD09KDE5MiZ0W3JdKTspci0tO3JldHVybiByPDB8fDA9PT1yP2U6citNZVt0W3JdXT5lP3I6ZX19O2Z1bmN0aW9uIGplKCl7dGhpcy5pbnB1dD1udWxsLHRoaXMubmV4dF9pbj0wLHRoaXMuYXZhaWxfaW49MCx0aGlzLnRvdGFsX2luPTAsdGhpcy5vdXRwdXQ9bnVsbCx0aGlzLm5leHRfb3V0PTAsdGhpcy5hdmFpbF9vdXQ9MCx0aGlzLnRvdGFsX291dD0wLHRoaXMubXNnPSIiLHRoaXMuc3RhdGU9bnVsbCx0aGlzLmRhdGFfdHlwZT0yLHRoaXMuYWRsZXI9MH12YXIgUGU9amU7Y29uc3QgJGU9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyx7Wl9OT19GTFVTSDpLZSxaX1NZTkNfRkxVU0g6WGUsWl9GVUxMX0ZMVVNIOkdlLFpfRklOSVNIOldlLFpfT0s6WWUsWl9TVFJFQU1fRU5EOnFlLFpfREVGQVVMVF9DT01QUkVTU0lPTjpWZSxaX0RFRkFVTFRfU1RSQVRFR1k6UWUsWl9ERUZMQVRFRDpKZX09ZnQ7ZnVuY3Rpb24gdHIodCl7dGhpcy5vcHRpb25zPUhlLmFzc2lnbih7bGV2ZWw6VmUsbWV0aG9kOkplLGNodW5rU2l6ZToxNjM4NCx3aW5kb3dCaXRzOjE1LG1lbUxldmVsOjgsc3RyYXRlZ3k6UWV9LHR8fHt9KTtsZXQgZT10aGlzLm9wdGlvbnM7ZS5yYXcmJmUud2luZG93Qml0cz4wP2Uud2luZG93Qml0cz0tZS53aW5kb3dCaXRzOmUuZ3ppcCYmZS53aW5kb3dCaXRzPjAmJmUud2luZG93Qml0czwxNiYmKGUud2luZG93Qml0cys9MTYpLHRoaXMuZXJyPTAsdGhpcy5tc2c9IiIsdGhpcy5lbmRlZD0hMSx0aGlzLmNodW5rcz1bXSx0aGlzLnN0cm09bmV3IFBlLHRoaXMuc3RybS5hdmFpbF9vdXQ9MDtsZXQgcj1DZS5kZWZsYXRlSW5pdDIodGhpcy5zdHJtLGUubGV2ZWwsZS5tZXRob2QsZS53aW5kb3dCaXRzLGUubWVtTGV2ZWwsZS5zdHJhdGVneSk7aWYociE9PVllKXRocm93IG5ldyBFcnJvcihkdFtyXSk7aWYoZS5oZWFkZXImJkNlLmRlZmxhdGVTZXRIZWFkZXIodGhpcy5zdHJtLGUuaGVhZGVyKSxlLmRpY3Rpb25hcnkpe2xldCB0O2lmKHQ9InN0cmluZyI9PXR5cGVvZiBlLmRpY3Rpb25hcnk/SWUuc3RyaW5nMmJ1ZihlLmRpY3Rpb25hcnkpOiJbb2JqZWN0IEFycmF5QnVmZmVyXSI9PT0kZS5jYWxsKGUuZGljdGlvbmFyeSk/bmV3IFVpbnQ4QXJyYXkoZS5kaWN0aW9uYXJ5KTplLmRpY3Rpb25hcnkscj1DZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sdCksciE9PVllKXRocm93IG5ldyBFcnJvcihkdFtyXSk7dGhpcy5fZGljdF9zZXQ9ITB9fWZ1bmN0aW9uIGVyKHQsZSl7Y29uc3Qgcj1uZXcgdHIoZSk7aWYoci5wdXNoKHQsITApLHIuZXJyKXRocm93IHIubXNnfHxkdFtyLmVycl07cmV0dXJuIHIucmVzdWx0fWZ1bmN0aW9uIHJyKHQsZSl7cmV0dXJuKGU9ZXx8e30pLnJhdz0hMCxlcih0LGUpfWZ1bmN0aW9uIG5yKHQsZSl7cmV0dXJuKGU9ZXx8e30pLmd6aXA9ITAsZXIodCxlKX10ci5wcm90b3R5cGUucHVzaD1mdW5jdGlvbih0LGUpe2NvbnN0IHI9dGhpcy5zdHJtLG49dGhpcy5vcHRpb25zLmNodW5rU2l6ZTtsZXQgaSxhO2lmKHRoaXMuZW5kZWQpcmV0dXJuITE7Zm9yKGE9ZT09PX5+ZT9lOiEwPT09ZT9XZTpLZSwic3RyaW5nIj09dHlwZW9mIHQ/ci5pbnB1dD1JZS5zdHJpbmcyYnVmKHQpOiJbb2JqZWN0IEFycmF5QnVmZmVyXSI9PT0kZS5jYWxsKHQpP3IuaW5wdXQ9bmV3IFVpbnQ4QXJyYXkodCk6ci5pbnB1dD10LHIubmV4dF9pbj0wLHIuYXZhaWxfaW49ci5pbnB1dC5sZW5ndGg7OylpZigwPT09ci5hdmFpbF9vdXQmJihyLm91dHB1dD1uZXcgVWludDhBcnJheShuKSxyLm5leHRfb3V0PTAsci5hdmFpbF9vdXQ9biksKGE9PT1YZXx8YT09PUdlKSYmci5hdmFpbF9vdXQ8PTYpdGhpcy5vbkRhdGEoci5vdXRwdXQuc3ViYXJyYXkoMCxyLm5leHRfb3V0KSksci5hdmFpbF9vdXQ9MDtlbHNle2lmKGk9Q2UuZGVmbGF0ZShyLGEpLGk9PT1xZSlyZXR1cm4gci5uZXh0X291dD4wJiZ0aGlzLm9uRGF0YShyLm91dHB1dC5zdWJhcnJheSgwLHIubmV4dF9vdXQpKSxpPUNlLmRlZmxhdGVFbmQodGhpcy5zdHJtKSx0aGlzLm9uRW5kKGkpLHRoaXMuZW5kZWQ9ITAsaT09PVllO2lmKDAhPT1yLmF2YWlsX291dCl7aWYoYT4wJiZyLm5leHRfb3V0PjApdGhpcy5vbkRhdGEoci5vdXRwdXQuc3ViYXJyYXkoMCxyLm5leHRfb3V0KSksci5hdmFpbF9vdXQ9MDtlbHNlIGlmKDA9PT1yLmF2YWlsX2luKWJyZWFrfWVsc2UgdGhpcy5vbkRhdGEoci5vdXRwdXQpfXJldHVybiEwfSx0ci5wcm90b3R5cGUub25EYXRhPWZ1bmN0aW9uKHQpe3RoaXMuY2h1bmtzLnB1c2godCl9LHRyLnByb3RvdHlwZS5vbkVuZD1mdW5jdGlvbih0KXt0PT09WWUmJih0aGlzLnJlc3VsdD1IZS5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKSksdGhpcy5jaHVua3M9W10sdGhpcy5lcnI9dCx0aGlzLm1zZz10aGlzLnN0cm0ubXNnfTt2YXIgaXI9dHIsYXI9ZXIsc3I9cnIsb3I9bnIsbHI9ZnQsaHI9e0RlZmxhdGU6aXIsZGVmbGF0ZTphcixkZWZsYXRlUmF3OnNyLGd6aXA6b3IsY29uc3RhbnRzOmxyfTt0LkRlZmxhdGU9aXIsdC5jb25zdGFudHM9bHIsdC5kZWZhdWx0PWhyLHQuZGVmbGF0ZT1hcix0LmRlZmxhdGVSYXc9c3IsdC5nemlwPW9yLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KX0ocy5leHBvcnRzKSkscy5leHBvcnRzKSxsPXtleHBvcnRzOnt9fTt2YXIgaCxjPXtleHBvcnRzOnt9fSx1PXIoT2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsZGVmYXVsdDp7fX0pKTtmdW5jdGlvbiBfKCl7cmV0dXJuIGh8fChoPTEsYy5leHBvcnRzPShlPWV8fGZ1bmN0aW9uKGUscil7dmFyIG47aWYoInVuZGVmaW5lZCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5jcnlwdG8mJihuPXdpbmRvdy5jcnlwdG8pLCJ1bmRlZmluZWQiIT10eXBlb2Ygc2VsZiYmc2VsZi5jcnlwdG8mJihuPXNlbGYuY3J5cHRvKSwidW5kZWZpbmVkIiE9dHlwZW9mIGdsb2JhbFRoaXMmJmdsb2JhbFRoaXMuY3J5cHRvJiYobj1nbG9iYWxUaGlzLmNyeXB0byksIW4mJiJ1bmRlZmluZWQiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cubXNDcnlwdG8mJihuPXdpbmRvdy5tc0NyeXB0byksIW4mJnZvaWQgMCE9PXQmJnQuY3J5cHRvJiYobj10LmNyeXB0byksIW4pdHJ5e249dX1jYXRjaCh0KXt9dmFyIGk9ZnVuY3Rpb24oKXtpZihuKXtpZigiZnVuY3Rpb24iPT10eXBlb2Ygbi5nZXRSYW5kb21WYWx1ZXMpdHJ5e3JldHVybiBuLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMSkpWzBdfWNhdGNoKHQpe31pZigiZnVuY3Rpb24iPT10eXBlb2Ygbi5yYW5kb21CeXRlcyl0cnl7cmV0dXJuIG4ucmFuZG9tQnl0ZXMoNCkucmVhZEludDMyTEUoKX1jYXRjaCh0KXt9fXRocm93IG5ldyBFcnJvcigiTmF0aXZlIGNyeXB0byBtb2R1bGUgY291bGQgbm90IGJlIHVzZWQgdG8gZ2V0IHNlY3VyZSByYW5kb20gbnVtYmVyLiIpfSxhPU9iamVjdC5jcmVhdGV8fGZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpe31yZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHI7cmV0dXJuIHQucHJvdG90eXBlPWUscj1uZXcgdCx0LnByb3RvdHlwZT1udWxsLHJ9fSgpLHM9e30sbz1zLmxpYj17fSxsPW8uQmFzZT17ZXh0ZW5kOmZ1bmN0aW9uKHQpe3ZhciBlPWEodGhpcyk7cmV0dXJuIHQmJmUubWl4SW4odCksZS5oYXNPd25Qcm9wZXJ0eSgiaW5pdCIpJiZ0aGlzLmluaXQhPT1lLmluaXR8fChlLmluaXQ9ZnVuY3Rpb24oKXtlLiRzdXBlci5pbml0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pLGUuaW5pdC5wcm90b3R5cGU9ZSxlLiRzdXBlcj10aGlzLGV9LGNyZWF0ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZXh0ZW5kKCk7cmV0dXJuIHQuaW5pdC5hcHBseSh0LGFyZ3VtZW50cyksdH0saW5pdDpmdW5jdGlvbigpe30sbWl4SW46ZnVuY3Rpb24odCl7Zm9yKHZhciBlIGluIHQpdC5oYXNPd25Qcm9wZXJ0eShlKSYmKHRoaXNbZV09dFtlXSk7dC5oYXNPd25Qcm9wZXJ0eSgidG9TdHJpbmciKSYmKHRoaXMudG9TdHJpbmc9dC50b1N0cmluZyl9LGNsb25lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW5pdC5wcm90b3R5cGUuZXh0ZW5kKHRoaXMpfX0saD1vLldvcmRBcnJheT1sLmV4dGVuZCh7aW5pdDpmdW5jdGlvbih0LGUpe3Q9dGhpcy53b3Jkcz10fHxbXSx0aGlzLnNpZ0J5dGVzPWUhPXI/ZTo0KnQubGVuZ3RofSx0b1N0cmluZzpmdW5jdGlvbih0KXtyZXR1cm4odHx8Xykuc3RyaW5naWZ5KHRoaXMpfSxjb25jYXQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy53b3JkcyxyPXQud29yZHMsbj10aGlzLnNpZ0J5dGVzLGk9dC5zaWdCeXRlcztpZih0aGlzLmNsYW1wKCksbiU0KWZvcih2YXIgYT0wO2E8aTthKyspe3ZhciBzPXJbYT4+PjJdPj4+MjQtYSU0KjgmMjU1O2VbbithPj4+Ml18PXM8PDI0LShuK2EpJTQqOH1lbHNlIGZvcih2YXIgbz0wO288aTtvKz00KWVbbitvPj4+Ml09cltvPj4+Ml07cmV0dXJuIHRoaXMuc2lnQnl0ZXMrPWksdGhpc30sY2xhbXA6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLndvcmRzLHI9dGhpcy5zaWdCeXRlczt0W3I+Pj4yXSY9NDI5NDk2NzI5NTw8MzItciU0KjgsdC5sZW5ndGg9ZS5jZWlsKHIvNCl9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIHQ9bC5jbG9uZS5jYWxsKHRoaXMpO3JldHVybiB0LndvcmRzPXRoaXMud29yZHMuc2xpY2UoMCksdH0scmFuZG9tOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxyPTA7cjx0O3IrPTQpZS5wdXNoKGkoKSk7cmV0dXJuIG5ldyBoLmluaXQoZSx0KX19KSxjPXMuZW5jPXt9LF89Yy5IZXg9e3N0cmluZ2lmeTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC53b3JkcyxyPXQuc2lnQnl0ZXMsbj1bXSxpPTA7aTxyO2krKyl7dmFyIGE9ZVtpPj4+Ml0+Pj4yNC1pJTQqOCYyNTU7bi5wdXNoKChhPj4+NCkudG9TdHJpbmcoMTYpKSxuLnB1c2goKDE1JmEpLnRvU3RyaW5nKDE2KSl9cmV0dXJuIG4uam9pbigiIil9LHBhcnNlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lmxlbmd0aCxyPVtdLG49MDtuPGU7bis9MilyW24+Pj4zXXw9cGFyc2VJbnQodC5zdWJzdHIobiwyKSwxNik8PDI0LW4lOCo0O3JldHVybiBuZXcgaC5pbml0KHIsZS8yKX19LGQ9Yy5MYXRpbjE9e3N0cmluZ2lmeTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC53b3JkcyxyPXQuc2lnQnl0ZXMsbj1bXSxpPTA7aTxyO2krKyl7dmFyIGE9ZVtpPj4+Ml0+Pj4yNC1pJTQqOCYyNTU7bi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYSkpfXJldHVybiBuLmpvaW4oIiIpfSxwYXJzZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5sZW5ndGgscj1bXSxuPTA7bjxlO24rKylyW24+Pj4yXXw9KDI1NSZ0LmNoYXJDb2RlQXQobikpPDwyNC1uJTQqODtyZXR1cm4gbmV3IGguaW5pdChyLGUpfX0sZj1jLlV0Zjg9e3N0cmluZ2lmeTpmdW5jdGlvbih0KXt0cnl7cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoZC5zdHJpbmdpZnkodCkpKX1jYXRjaCh0KXt0aHJvdyBuZXcgRXJyb3IoIk1hbGZvcm1lZCBVVEYtOCBkYXRhIil9fSxwYXJzZTpmdW5jdGlvbih0KXtyZXR1cm4gZC5wYXJzZSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodCkpKX19LHA9by5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtPWwuZXh0ZW5kKHtyZXNldDpmdW5jdGlvbigpe3RoaXMuX2RhdGE9bmV3IGguaW5pdCx0aGlzLl9uRGF0YUJ5dGVzPTB9LF9hcHBlbmQ6ZnVuY3Rpb24odCl7InN0cmluZyI9PXR5cGVvZiB0JiYodD1mLnBhcnNlKHQpKSx0aGlzLl9kYXRhLmNvbmNhdCh0KSx0aGlzLl9uRGF0YUJ5dGVzKz10LnNpZ0J5dGVzfSxfcHJvY2VzczpmdW5jdGlvbih0KXt2YXIgcixuPXRoaXMuX2RhdGEsaT1uLndvcmRzLGE9bi5zaWdCeXRlcyxzPXRoaXMuYmxvY2tTaXplLG89YS8oNCpzKSxsPShvPXQ/ZS5jZWlsKG8pOmUubWF4KCgwfG8pLXRoaXMuX21pbkJ1ZmZlclNpemUsMCkpKnMsYz1lLm1pbig0KmwsYSk7aWYobCl7Zm9yKHZhciB1PTA7dTxsO3UrPXMpdGhpcy5fZG9Qcm9jZXNzQmxvY2soaSx1KTtyPWkuc3BsaWNlKDAsbCksbi5zaWdCeXRlcy09Y31yZXR1cm4gbmV3IGguaW5pdChyLGMpfSxjbG9uZTpmdW5jdGlvbigpe3ZhciB0PWwuY2xvbmUuY2FsbCh0aGlzKTtyZXR1cm4gdC5fZGF0YT10aGlzLl9kYXRhLmNsb25lKCksdH0sX21pbkJ1ZmZlclNpemU6MH0pO28uSGFzaGVyPXAuZXh0ZW5kKHtjZmc6bC5leHRlbmQoKSxpbml0OmZ1bmN0aW9uKHQpe3RoaXMuY2ZnPXRoaXMuY2ZnLmV4dGVuZCh0KSx0aGlzLnJlc2V0KCl9LHJlc2V0OmZ1bmN0aW9uKCl7cC5yZXNldC5jYWxsKHRoaXMpLHRoaXMuX2RvUmVzZXQoKX0sdXBkYXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9hcHBlbmQodCksdGhpcy5fcHJvY2VzcygpLHRoaXN9LGZpbmFsaXplOmZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0aGlzLl9hcHBlbmQodCksdGhpcy5fZG9GaW5hbGl6ZSgpfSxibG9ja1NpemU6MTYsX2NyZWF0ZUhlbHBlcjpmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxyKXtyZXR1cm4gbmV3IHQuaW5pdChyKS5maW5hbGl6ZShlKX19LF9jcmVhdGVIbWFjSGVscGVyOmZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlLHIpe3JldHVybiBuZXcgZy5ITUFDLmluaXQodCxyKS5maW5hbGl6ZShlKX19fSk7dmFyIGc9cy5hbGdvPXt9O3JldHVybiBzfShNYXRoKSxlKSksYy5leHBvcnRzO3ZhciBlfXZhciBkO2Z1bmN0aW9uIGYoKXtyZXR1cm4gZHx8KGQ9MSxsLmV4cG9ydHM9KHQ9XygpLGZ1bmN0aW9uKCl7dmFyIGU9dCxyPWUubGliLldvcmRBcnJheTtmdW5jdGlvbiBuKHQsZSxuKXtmb3IodmFyIGk9W10sYT0wLHM9MDtzPGU7cysrKWlmKHMlNCl7dmFyIG89blt0LmNoYXJDb2RlQXQocy0xKV08PHMlNCoyfG5bdC5jaGFyQ29kZUF0KHMpXT4+PjYtcyU0KjI7aVthPj4+Ml18PW88PDI0LWElNCo4LGErK31yZXR1cm4gci5jcmVhdGUoaSxhKX1lLmVuYy5CYXNlNjQ9e3N0cmluZ2lmeTpmdW5jdGlvbih0KXt2YXIgZT10LndvcmRzLHI9dC5zaWdCeXRlcyxuPXRoaXMuX21hcDt0LmNsYW1wKCk7Zm9yKHZhciBpPVtdLGE9MDthPHI7YSs9Mylmb3IodmFyIHM9KGVbYT4+PjJdPj4+MjQtYSU0KjgmMjU1KTw8MTZ8KGVbYSsxPj4+Ml0+Pj4yNC0oYSsxKSU0KjgmMjU1KTw8OHxlW2ErMj4+PjJdPj4+MjQtKGErMiklNCo4JjI1NSxvPTA7bzw0JiZhKy43NSpvPHI7bysrKWkucHVzaChuLmNoYXJBdChzPj4+NiooMy1vKSY2MykpO3ZhciBsPW4uY2hhckF0KDY0KTtpZihsKWZvcig7aS5sZW5ndGglNDspaS5wdXNoKGwpO3JldHVybiBpLmpvaW4oIiIpfSxwYXJzZTpmdW5jdGlvbih0KXt2YXIgZT10Lmxlbmd0aCxyPXRoaXMuX21hcCxpPXRoaXMuX3JldmVyc2VNYXA7aWYoIWkpe2k9dGhpcy5fcmV2ZXJzZU1hcD1bXTtmb3IodmFyIGE9MDthPHIubGVuZ3RoO2ErKylpW3IuY2hhckNvZGVBdChhKV09YX12YXIgcz1yLmNoYXJBdCg2NCk7aWYocyl7dmFyIG89dC5pbmRleE9mKHMpOy0xIT09byYmKGU9byl9cmV0dXJuIG4odCxlLGkpfSxfbWFwOiJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSJ9fSgpLHQuZW5jLkJhc2U2NCkpLGwuZXhwb3J0czt2YXIgdH12YXIgcCxnPWUoZigpKSx5PXtleHBvcnRzOnt9fSx3PXtleHBvcnRzOnt9fTtmdW5jdGlvbiB2KCl7cmV0dXJuIHB8fChwPTEsdy5leHBvcnRzPSh0PV8oKSxmdW5jdGlvbihlKXt2YXIgcj10LG49ci5saWIsaT1uLldvcmRBcnJheSxhPW4uSGFzaGVyLHM9ci5hbGdvLG89W107IWZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDw2NDt0Kyspb1t0XT00Mjk0OTY3Mjk2KmUuYWJzKGUuc2luKHQrMSkpfDB9KCk7dmFyIGw9cy5NRDU9YS5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5faGFzaD1uZXcgaS5pbml0KFsxNzMyNTg0MTkzLDQwMjMyMzM0MTcsMjU2MjM4MzEwMiwyNzE3MzM4NzhdKX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByPTA7cjwxNjtyKyspe3ZhciBuPWUrcixpPXRbbl07dFtuXT0xNjcxMTkzNSYoaTw8OHxpPj4+MjQpfDQyNzgyNTUzNjAmKGk8PDI0fGk+Pj44KX12YXIgYT10aGlzLl9oYXNoLndvcmRzLHM9dFtlKzBdLGw9dFtlKzFdLGQ9dFtlKzJdLGY9dFtlKzNdLHA9dFtlKzRdLGc9dFtlKzVdLHk9dFtlKzZdLHc9dFtlKzddLHY9dFtlKzhdLG09dFtlKzldLGI9dFtlKzEwXSx4PXRbZSsxMV0saz10W2UrMTJdLHo9dFtlKzEzXSxBPXRbZSsxNF0sRT10W2UrMTVdLFM9YVswXSxCPWFbMV0sTz1hWzJdLEw9YVszXTtTPWgoUyxCLE8sTCxzLDcsb1swXSksTD1oKEwsUyxCLE8sbCwxMixvWzFdKSxPPWgoTyxMLFMsQixkLDE3LG9bMl0pLEI9aChCLE8sTCxTLGYsMjIsb1szXSksUz1oKFMsQixPLEwscCw3LG9bNF0pLEw9aChMLFMsQixPLGcsMTIsb1s1XSksTz1oKE8sTCxTLEIseSwxNyxvWzZdKSxCPWgoQixPLEwsUyx3LDIyLG9bN10pLFM9aChTLEIsTyxMLHYsNyxvWzhdKSxMPWgoTCxTLEIsTyxtLDEyLG9bOV0pLE89aChPLEwsUyxCLGIsMTcsb1sxMF0pLEI9aChCLE8sTCxTLHgsMjIsb1sxMV0pLFM9aChTLEIsTyxMLGssNyxvWzEyXSksTD1oKEwsUyxCLE8seiwxMixvWzEzXSksTz1oKE8sTCxTLEIsQSwxNyxvWzE0XSksUz1jKFMsQj1oKEIsTyxMLFMsRSwyMixvWzE1XSksTyxMLGwsNSxvWzE2XSksTD1jKEwsUyxCLE8seSw5LG9bMTddKSxPPWMoTyxMLFMsQix4LDE0LG9bMThdKSxCPWMoQixPLEwsUyxzLDIwLG9bMTldKSxTPWMoUyxCLE8sTCxnLDUsb1syMF0pLEw9YyhMLFMsQixPLGIsOSxvWzIxXSksTz1jKE8sTCxTLEIsRSwxNCxvWzIyXSksQj1jKEIsTyxMLFMscCwyMCxvWzIzXSksUz1jKFMsQixPLEwsbSw1LG9bMjRdKSxMPWMoTCxTLEIsTyxBLDksb1syNV0pLE89YyhPLEwsUyxCLGYsMTQsb1syNl0pLEI9YyhCLE8sTCxTLHYsMjAsb1syN10pLFM9YyhTLEIsTyxMLHosNSxvWzI4XSksTD1jKEwsUyxCLE8sZCw5LG9bMjldKSxPPWMoTyxMLFMsQix3LDE0LG9bMzBdKSxTPXUoUyxCPWMoQixPLEwsUyxrLDIwLG9bMzFdKSxPLEwsZyw0LG9bMzJdKSxMPXUoTCxTLEIsTyx2LDExLG9bMzNdKSxPPXUoTyxMLFMsQix4LDE2LG9bMzRdKSxCPXUoQixPLEwsUyxBLDIzLG9bMzVdKSxTPXUoUyxCLE8sTCxsLDQsb1szNl0pLEw9dShMLFMsQixPLHAsMTEsb1szN10pLE89dShPLEwsUyxCLHcsMTYsb1szOF0pLEI9dShCLE8sTCxTLGIsMjMsb1szOV0pLFM9dShTLEIsTyxMLHosNCxvWzQwXSksTD11KEwsUyxCLE8scywxMSxvWzQxXSksTz11KE8sTCxTLEIsZiwxNixvWzQyXSksQj11KEIsTyxMLFMseSwyMyxvWzQzXSksUz11KFMsQixPLEwsbSw0LG9bNDRdKSxMPXUoTCxTLEIsTyxrLDExLG9bNDVdKSxPPXUoTyxMLFMsQixFLDE2LG9bNDZdKSxTPV8oUyxCPXUoQixPLEwsUyxkLDIzLG9bNDddKSxPLEwscyw2LG9bNDhdKSxMPV8oTCxTLEIsTyx3LDEwLG9bNDldKSxPPV8oTyxMLFMsQixBLDE1LG9bNTBdKSxCPV8oQixPLEwsUyxnLDIxLG9bNTFdKSxTPV8oUyxCLE8sTCxrLDYsb1s1Ml0pLEw9XyhMLFMsQixPLGYsMTAsb1s1M10pLE89XyhPLEwsUyxCLGIsMTUsb1s1NF0pLEI9XyhCLE8sTCxTLGwsMjEsb1s1NV0pLFM9XyhTLEIsTyxMLHYsNixvWzU2XSksTD1fKEwsUyxCLE8sRSwxMCxvWzU3XSksTz1fKE8sTCxTLEIseSwxNSxvWzU4XSksQj1fKEIsTyxMLFMseiwyMSxvWzU5XSksUz1fKFMsQixPLEwscCw2LG9bNjBdKSxMPV8oTCxTLEIsTyx4LDEwLG9bNjFdKSxPPV8oTyxMLFMsQixkLDE1LG9bNjJdKSxCPV8oQixPLEwsUyxtLDIxLG9bNjNdKSxhWzBdPWFbMF0rU3wwLGFbMV09YVsxXStCfDAsYVsyXT1hWzJdK098MCxhWzNdPWFbM10rTHwwfSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2RhdGEscj10LndvcmRzLG49OCp0aGlzLl9uRGF0YUJ5dGVzLGk9OCp0LnNpZ0J5dGVzO3JbaT4+PjVdfD0xMjg8PDI0LWklMzI7dmFyIGE9ZS5mbG9vcihuLzQyOTQ5NjcyOTYpLHM9bjtyWzE1KyhpKzY0Pj4+OTw8NCldPTE2NzExOTM1JihhPDw4fGE+Pj4yNCl8NDI3ODI1NTM2MCYoYTw8MjR8YT4+PjgpLHJbMTQrKGkrNjQ+Pj45PDw0KV09MTY3MTE5MzUmKHM8PDh8cz4+PjI0KXw0Mjc4MjU1MzYwJihzPDwyNHxzPj4+OCksdC5zaWdCeXRlcz00KihyLmxlbmd0aCsxKSx0aGlzLl9wcm9jZXNzKCk7Zm9yKHZhciBvPXRoaXMuX2hhc2gsbD1vLndvcmRzLGg9MDtoPDQ7aCsrKXt2YXIgYz1sW2hdO2xbaF09MTY3MTE5MzUmKGM8PDh8Yz4+PjI0KXw0Mjc4MjU1MzYwJihjPDwyNHxjPj4+OCl9cmV0dXJuIG99LGNsb25lOmZ1bmN0aW9uKCl7dmFyIHQ9YS5jbG9uZS5jYWxsKHRoaXMpO3JldHVybiB0Ll9oYXNoPXRoaXMuX2hhc2guY2xvbmUoKSx0fX0pO2Z1bmN0aW9uIGgodCxlLHIsbixpLGEscyl7dmFyIG89dCsoZSZyfH5lJm4pK2krcztyZXR1cm4obzw8YXxvPj4+MzItYSkrZX1mdW5jdGlvbiBjKHQsZSxyLG4saSxhLHMpe3ZhciBvPXQrKGUmbnxyJn5uKStpK3M7cmV0dXJuKG88PGF8bz4+PjMyLWEpK2V9ZnVuY3Rpb24gdSh0LGUscixuLGksYSxzKXt2YXIgbz10KyhlXnJebikraStzO3JldHVybihvPDxhfG8+Pj4zMi1hKStlfWZ1bmN0aW9uIF8odCxlLHIsbixpLGEscyl7dmFyIG89dCsocl4oZXx+bikpK2krcztyZXR1cm4obzw8YXxvPj4+MzItYSkrZX1yLk1ENT1hLl9jcmVhdGVIZWxwZXIobCksci5IbWFjTUQ1PWEuX2NyZWF0ZUhtYWNIZWxwZXIobCl9KE1hdGgpLHQuTUQ1KSksdy5leHBvcnRzO3ZhciB0fXZhciBtLGI9e2V4cG9ydHM6e319LHg9e2V4cG9ydHM6e319O2Z1bmN0aW9uIGsoKXtyZXR1cm4gbXx8KG09MSx4LmV4cG9ydHM9KHQ9XygpLGZ1bmN0aW9uKCl7dmFyIGU9dCxyPWUubGliLG49ci5Xb3JkQXJyYXksaT1yLkhhc2hlcixhPWUuYWxnbyxzPVtdLG89YS5TSEExPWkuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3RoaXMuX2hhc2g9bmV3IG4uaW5pdChbMTczMjU4NDE5Myw0MDIzMjMzNDE3LDI1NjIzODMxMDIsMjcxNzMzODc4LDMyODUzNzc1MjBdKX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByPXRoaXMuX2hhc2gud29yZHMsbj1yWzBdLGk9clsxXSxhPXJbMl0sbz1yWzNdLGw9cls0XSxoPTA7aDw4MDtoKyspe2lmKGg8MTYpc1toXT0wfHRbZStoXTtlbHNle3ZhciBjPXNbaC0zXV5zW2gtOF1ec1toLTE0XV5zW2gtMTZdO3NbaF09Yzw8MXxjPj4+MzF9dmFyIHU9KG48PDV8bj4+PjI3KStsK3NbaF07dSs9aDwyMD8xNTE4NTAwMjQ5KyhpJmF8fmkmbyk6aDw0MD8xODU5Nzc1MzkzKyhpXmFebyk6aDw2MD8oaSZhfGkmb3xhJm8pLTE4OTQwMDc1ODg6KGleYV5vKS04OTk0OTc1MTQsbD1vLG89YSxhPWk8PDMwfGk+Pj4yLGk9bixuPXV9clswXT1yWzBdK258MCxyWzFdPXJbMV0raXwwLHJbMl09clsyXSthfDAsclszXT1yWzNdK298MCxyWzRdPXJbNF0rbHwwfSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2RhdGEsZT10LndvcmRzLHI9OCp0aGlzLl9uRGF0YUJ5dGVzLG49OCp0LnNpZ0J5dGVzO3JldHVybiBlW24+Pj41XXw9MTI4PDwyNC1uJTMyLGVbMTQrKG4rNjQ+Pj45PDw0KV09TWF0aC5mbG9vcihyLzQyOTQ5NjcyOTYpLGVbMTUrKG4rNjQ+Pj45PDw0KV09cix0LnNpZ0J5dGVzPTQqZS5sZW5ndGgsdGhpcy5fcHJvY2VzcygpLHRoaXMuX2hhc2h9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIHQ9aS5jbG9uZS5jYWxsKHRoaXMpO3JldHVybiB0Ll9oYXNoPXRoaXMuX2hhc2guY2xvbmUoKSx0fX0pO2UuU0hBMT1pLl9jcmVhdGVIZWxwZXIobyksZS5IbWFjU0hBMT1pLl9jcmVhdGVIbWFjSGVscGVyKG8pfSgpLHQuU0hBMSkpLHguZXhwb3J0czt2YXIgdH12YXIgeixBPXtleHBvcnRzOnt9fTtmdW5jdGlvbiBFKCl7cmV0dXJuIHp8fCh6PTEsQS5leHBvcnRzPSh0PV8oKSxyPShlPXQpLmxpYi5CYXNlLG49ZS5lbmMuVXRmOCx2b2lkKGUuYWxnby5ITUFDPXIuZXh0ZW5kKHtpbml0OmZ1bmN0aW9uKHQsZSl7dD10aGlzLl9oYXNoZXI9bmV3IHQuaW5pdCwic3RyaW5nIj09dHlwZW9mIGUmJihlPW4ucGFyc2UoZSkpO3ZhciByPXQuYmxvY2tTaXplLGk9NCpyO2Uuc2lnQnl0ZXM+aSYmKGU9dC5maW5hbGl6ZShlKSksZS5jbGFtcCgpO2Zvcih2YXIgYT10aGlzLl9vS2V5PWUuY2xvbmUoKSxzPXRoaXMuX2lLZXk9ZS5jbG9uZSgpLG89YS53b3JkcyxsPXMud29yZHMsaD0wO2g8cjtoKyspb1toXV49MTU0OTU1NjgyOCxsW2hdXj05MDk1MjI0ODY7YS5zaWdCeXRlcz1zLnNpZ0J5dGVzPWksdGhpcy5yZXNldCgpfSxyZXNldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2hhc2hlcjt0LnJlc2V0KCksdC51cGRhdGUodGhpcy5faUtleSl9LHVwZGF0ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5faGFzaGVyLnVwZGF0ZSh0KSx0aGlzfSxmaW5hbGl6ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLl9oYXNoZXIscj1lLmZpbmFsaXplKHQpO3JldHVybiBlLnJlc2V0KCksZS5maW5hbGl6ZSh0aGlzLl9vS2V5LmNsb25lKCkuY29uY2F0KHIpKX19KSkpKSxBLmV4cG9ydHM7dmFyIHQsZSxyLG59dmFyIFM7ZnVuY3Rpb24gQigpe3JldHVybiBTfHwoUz0xLGIuZXhwb3J0cz0odD1fKCksaygpLEUoKSxmdW5jdGlvbigpe3ZhciBlPXQscj1lLmxpYixuPXIuQmFzZSxpPXIuV29yZEFycmF5LGE9ZS5hbGdvLHM9YS5NRDUsbz1hLkV2cEtERj1uLmV4dGVuZCh7Y2ZnOm4uZXh0ZW5kKHtrZXlTaXplOjQsaGFzaGVyOnMsaXRlcmF0aW9uczoxfSksaW5pdDpmdW5jdGlvbih0KXt0aGlzLmNmZz10aGlzLmNmZy5leHRlbmQodCl9LGNvbXB1dGU6ZnVuY3Rpb24odCxlKXtmb3IodmFyIHIsbj10aGlzLmNmZyxhPW4uaGFzaGVyLmNyZWF0ZSgpLHM9aS5jcmVhdGUoKSxvPXMud29yZHMsbD1uLmtleVNpemUsaD1uLml0ZXJhdGlvbnM7by5sZW5ndGg8bDspe3ImJmEudXBkYXRlKHIpLHI9YS51cGRhdGUodCkuZmluYWxpemUoZSksYS5yZXNldCgpO2Zvcih2YXIgYz0xO2M8aDtjKyspcj1hLmZpbmFsaXplKHIpLGEucmVzZXQoKTtzLmNvbmNhdChyKX1yZXR1cm4gcy5zaWdCeXRlcz00Kmwsc319KTtlLkV2cEtERj1mdW5jdGlvbih0LGUscil7cmV0dXJuIG8uY3JlYXRlKHIpLmNvbXB1dGUodCxlKX19KCksdC5FdnBLREYpKSxiLmV4cG9ydHM7dmFyIHR9dmFyIE8sTD17ZXhwb3J0czp7fX07dmFyIFI7dmFyIEQsVSxDPShSfHwoUj0xLHkuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZT10LHI9ZS5saWIuQmxvY2tDaXBoZXIsbj1lLmFsZ28saT1bXSxhPVtdLHM9W10sbz1bXSxsPVtdLGg9W10sYz1bXSx1PVtdLF89W10sZD1bXTshZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sZT0wO2U8MjU2O2UrKyl0W2VdPWU8MTI4P2U8PDE6ZTw8MV4yODM7dmFyIHI9MCxuPTA7Zm9yKGU9MDtlPDI1NjtlKyspe3ZhciBmPW5ebjw8MV5uPDwyXm48PDNebjw8NDtmPWY+Pj44XjI1NSZmXjk5LGlbcl09ZixhW2ZdPXI7dmFyIHA9dFtyXSxnPXRbcF0seT10W2ddLHc9MjU3KnRbZl1eMTY4NDMwMDgqZjtzW3JdPXc8PDI0fHc+Pj44LG9bcl09dzw8MTZ8dz4+PjE2LGxbcl09dzw8OHx3Pj4+MjQsaFtyXT13LHc9MTY4NDMwMDkqeV42NTUzNypnXjI1NypwXjE2ODQzMDA4KnIsY1tmXT13PDwyNHx3Pj4+OCx1W2ZdPXc8PDE2fHc+Pj4xNixfW2ZdPXc8PDh8dz4+PjI0LGRbZl09dyxyPyhyPXBedFt0W3RbeV5wXV1dLG5ePXRbdFtuXV0pOnI9bj0xfX0oKTt2YXIgZj1bMCwxLDIsNCw4LDE2LDMyLDY0LDEyOCwyNyw1NF0scD1uLkFFUz1yLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXtpZighdGhpcy5fblJvdW5kc3x8dGhpcy5fa2V5UHJpb3JSZXNldCE9PXRoaXMuX2tleSl7Zm9yKHZhciB0PXRoaXMuX2tleVByaW9yUmVzZXQ9dGhpcy5fa2V5LGU9dC53b3JkcyxyPXQuc2lnQnl0ZXMvNCxuPTQqKCh0aGlzLl9uUm91bmRzPXIrNikrMSksYT10aGlzLl9rZXlTY2hlZHVsZT1bXSxzPTA7czxuO3MrKylzPHI/YVtzXT1lW3NdOihoPWFbcy0xXSxzJXI/cj42JiZzJXI9PTQmJihoPWlbaD4+PjI0XTw8MjR8aVtoPj4+MTYmMjU1XTw8MTZ8aVtoPj4+OCYyNTVdPDw4fGlbMjU1JmhdKTooaD1pWyhoPWg8PDh8aD4+PjI0KT4+PjI0XTw8MjR8aVtoPj4+MTYmMjU1XTw8MTZ8aVtoPj4+OCYyNTVdPDw4fGlbMjU1JmhdLGhePWZbcy9yfDBdPDwyNCksYVtzXT1hW3Mtcl1eaCk7Zm9yKHZhciBvPXRoaXMuX2ludktleVNjaGVkdWxlPVtdLGw9MDtsPG47bCsrKXtpZihzPW4tbCxsJTQpdmFyIGg9YVtzXTtlbHNlIGg9YVtzLTRdO29bbF09bDw0fHxzPD00P2g6Y1tpW2g+Pj4yNF1dXnVbaVtoPj4+MTYmMjU1XV1eX1tpW2g+Pj44JjI1NV1dXmRbaVsyNTUmaF1dfX19LGVuY3J5cHRCbG9jazpmdW5jdGlvbih0LGUpe3RoaXMuX2RvQ3J5cHRCbG9jayh0LGUsdGhpcy5fa2V5U2NoZWR1bGUscyxvLGwsaCxpKX0sZGVjcnlwdEJsb2NrOmZ1bmN0aW9uKHQsZSl7dmFyIHI9dFtlKzFdO3RbZSsxXT10W2UrM10sdFtlKzNdPXIsdGhpcy5fZG9DcnlwdEJsb2NrKHQsZSx0aGlzLl9pbnZLZXlTY2hlZHVsZSxjLHUsXyxkLGEpLHI9dFtlKzFdLHRbZSsxXT10W2UrM10sdFtlKzNdPXJ9LF9kb0NyeXB0QmxvY2s6ZnVuY3Rpb24odCxlLHIsbixpLGEscyxvKXtmb3IodmFyIGw9dGhpcy5fblJvdW5kcyxoPXRbZV1eclswXSxjPXRbZSsxXV5yWzFdLHU9dFtlKzJdXnJbMl0sXz10W2UrM11eclszXSxkPTQsZj0xO2Y8bDtmKyspe3ZhciBwPW5baD4+PjI0XV5pW2M+Pj4xNiYyNTVdXmFbdT4+PjgmMjU1XV5zWzI1NSZfXV5yW2QrK10sZz1uW2M+Pj4yNF1eaVt1Pj4+MTYmMjU1XV5hW18+Pj44JjI1NV1ec1syNTUmaF1ecltkKytdLHk9blt1Pj4+MjRdXmlbXz4+PjE2JjI1NV1eYVtoPj4+OCYyNTVdXnNbMjU1JmNdXnJbZCsrXSx3PW5bXz4+PjI0XV5pW2g+Pj4xNiYyNTVdXmFbYz4+PjgmMjU1XV5zWzI1NSZ1XV5yW2QrK107aD1wLGM9Zyx1PXksXz13fXA9KG9baD4+PjI0XTw8MjR8b1tjPj4+MTYmMjU1XTw8MTZ8b1t1Pj4+OCYyNTVdPDw4fG9bMjU1Jl9dKV5yW2QrK10sZz0ob1tjPj4+MjRdPDwyNHxvW3U+Pj4xNiYyNTVdPDwxNnxvW18+Pj44JjI1NV08PDh8b1syNTUmaF0pXnJbZCsrXSx5PShvW3U+Pj4yNF08PDI0fG9bXz4+PjE2JjI1NV08PDE2fG9baD4+PjgmMjU1XTw8OHxvWzI1NSZjXSlecltkKytdLHc9KG9bXz4+PjI0XTw8MjR8b1toPj4+MTYmMjU1XTw8MTZ8b1tjPj4+OCYyNTVdPDw4fG9bMjU1JnVdKV5yW2QrK10sdFtlXT1wLHRbZSsxXT1nLHRbZSsyXT15LHRbZSszXT13fSxrZXlTaXplOjh9KTtlLkFFUz1yLl9jcmVhdGVIZWxwZXIocCl9KCksdC5BRVN9KF8oKSxmKCksdigpLEIoKSxPfHwoTz0xLEwuZXhwb3J0cz0oRD1fKCksQigpLHZvaWQoRC5saWIuQ2lwaGVyfHxmdW5jdGlvbih0KXt2YXIgZT1ELHI9ZS5saWIsbj1yLkJhc2UsaT1yLldvcmRBcnJheSxhPXIuQnVmZmVyZWRCbG9ja0FsZ29yaXRobSxzPWUuZW5jO3MuVXRmODt2YXIgbz1zLkJhc2U2NCxsPWUuYWxnby5FdnBLREYsaD1yLkNpcGhlcj1hLmV4dGVuZCh7Y2ZnOm4uZXh0ZW5kKCksY3JlYXRlRW5jcnlwdG9yOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0VOQ19YRk9STV9NT0RFLHQsZSl9LGNyZWF0ZURlY3J5cHRvcjpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9ERUNfWEZPUk1fTU9ERSx0LGUpfSxpbml0OmZ1bmN0aW9uKHQsZSxyKXt0aGlzLmNmZz10aGlzLmNmZy5leHRlbmQociksdGhpcy5feGZvcm1Nb2RlPXQsdGhpcy5fa2V5PWUsdGhpcy5yZXNldCgpfSxyZXNldDpmdW5jdGlvbigpe2EucmVzZXQuY2FsbCh0aGlzKSx0aGlzLl9kb1Jlc2V0KCl9LHByb2Nlc3M6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2FwcGVuZCh0KSx0aGlzLl9wcm9jZXNzKCl9LGZpbmFsaXplOmZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0aGlzLl9hcHBlbmQodCksdGhpcy5fZG9GaW5hbGl6ZSgpfSxrZXlTaXplOjQsaXZTaXplOjQsX0VOQ19YRk9STV9NT0RFOjEsX0RFQ19YRk9STV9NT0RFOjIsX2NyZWF0ZUhlbHBlcjpmdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7cmV0dXJuInN0cmluZyI9PXR5cGVvZiB0P3c6Z31yZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJue2VuY3J5cHQ6ZnVuY3Rpb24ocixuLGkpe3JldHVybiB0KG4pLmVuY3J5cHQoZSxyLG4saSl9LGRlY3J5cHQ6ZnVuY3Rpb24ocixuLGkpe3JldHVybiB0KG4pLmRlY3J5cHQoZSxyLG4saSl9fX19KCl9KTtyLlN0cmVhbUNpcGhlcj1oLmV4dGVuZCh7X2RvRmluYWxpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcHJvY2VzcyghMCl9LGJsb2NrU2l6ZToxfSk7dmFyIGM9ZS5tb2RlPXt9LHU9ci5CbG9ja0NpcGhlck1vZGU9bi5leHRlbmQoe2NyZWF0ZUVuY3J5cHRvcjpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLkVuY3J5cHRvci5jcmVhdGUodCxlKX0sY3JlYXRlRGVjcnlwdG9yOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuRGVjcnlwdG9yLmNyZWF0ZSh0LGUpfSxpbml0OmZ1bmN0aW9uKHQsZSl7dGhpcy5fY2lwaGVyPXQsdGhpcy5faXY9ZX19KSxfPWMuQ0JDPWZ1bmN0aW9uKCl7dmFyIGU9dS5leHRlbmQoKTtmdW5jdGlvbiByKGUscixuKXt2YXIgaSxhPXRoaXMuX2l2O2E/KGk9YSx0aGlzLl9pdj10KTppPXRoaXMuX3ByZXZCbG9jaztmb3IodmFyIHM9MDtzPG47cysrKWVbcitzXV49aVtzXX1yZXR1cm4gZS5FbmNyeXB0b3I9ZS5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuX2NpcGhlcixpPW4uYmxvY2tTaXplO3IuY2FsbCh0aGlzLHQsZSxpKSxuLmVuY3J5cHRCbG9jayh0LGUpLHRoaXMuX3ByZXZCbG9jaz10LnNsaWNlKGUsZStpKX19KSxlLkRlY3J5cHRvcj1lLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5fY2lwaGVyLGk9bi5ibG9ja1NpemUsYT10LnNsaWNlKGUsZStpKTtuLmRlY3J5cHRCbG9jayh0LGUpLHIuY2FsbCh0aGlzLHQsZSxpKSx0aGlzLl9wcmV2QmxvY2s9YX19KSxlfSgpLGQ9KGUucGFkPXt9KS5Qa2NzNz17cGFkOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByPTQqZSxuPXItdC5zaWdCeXRlcyVyLGE9bjw8MjR8bjw8MTZ8bjw8OHxuLHM9W10sbz0wO288bjtvKz00KXMucHVzaChhKTt2YXIgbD1pLmNyZWF0ZShzLG4pO3QuY29uY2F0KGwpfSx1bnBhZDpmdW5jdGlvbih0KXt2YXIgZT0yNTUmdC53b3Jkc1t0LnNpZ0J5dGVzLTE+Pj4yXTt0LnNpZ0J5dGVzLT1lfX07ci5CbG9ja0NpcGhlcj1oLmV4dGVuZCh7Y2ZnOmguY2ZnLmV4dGVuZCh7bW9kZTpfLHBhZGRpbmc6ZH0pLHJlc2V0OmZ1bmN0aW9uKCl7dmFyIHQ7aC5yZXNldC5jYWxsKHRoaXMpO3ZhciBlPXRoaXMuY2ZnLHI9ZS5pdixuPWUubW9kZTt0aGlzLl94Zm9ybU1vZGU9PXRoaXMuX0VOQ19YRk9STV9NT0RFP3Q9bi5jcmVhdGVFbmNyeXB0b3I6KHQ9bi5jcmVhdGVEZWNyeXB0b3IsdGhpcy5fbWluQnVmZmVyU2l6ZT0xKSx0aGlzLl9tb2RlJiZ0aGlzLl9tb2RlLl9fY3JlYXRvcj09dD90aGlzLl9tb2RlLmluaXQodGhpcyxyJiZyLndvcmRzKToodGhpcy5fbW9kZT10LmNhbGwobix0aGlzLHImJnIud29yZHMpLHRoaXMuX21vZGUuX19jcmVhdG9yPXQpfSxfZG9Qcm9jZXNzQmxvY2s6ZnVuY3Rpb24odCxlKXt0aGlzLl9tb2RlLnByb2Nlc3NCbG9jayh0LGUpfSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciB0LGU9dGhpcy5jZmcucGFkZGluZztyZXR1cm4gdGhpcy5feGZvcm1Nb2RlPT10aGlzLl9FTkNfWEZPUk1fTU9ERT8oZS5wYWQodGhpcy5fZGF0YSx0aGlzLmJsb2NrU2l6ZSksdD10aGlzLl9wcm9jZXNzKCEwKSk6KHQ9dGhpcy5fcHJvY2VzcyghMCksZS51bnBhZCh0KSksdH0sYmxvY2tTaXplOjR9KTt2YXIgZj1yLkNpcGhlclBhcmFtcz1uLmV4dGVuZCh7aW5pdDpmdW5jdGlvbih0KXt0aGlzLm1peEluKHQpfSx0b1N0cmluZzpmdW5jdGlvbih0KXtyZXR1cm4odHx8dGhpcy5mb3JtYXR0ZXIpLnN0cmluZ2lmeSh0aGlzKX19KSxwPShlLmZvcm1hdD17fSkuT3BlblNTTD17c3RyaW5naWZ5OmZ1bmN0aW9uKHQpe3ZhciBlPXQuY2lwaGVydGV4dCxyPXQuc2FsdDtyZXR1cm4ocj9pLmNyZWF0ZShbMTM5ODg5MzY4NCwxNzAxMDc2ODMxXSkuY29uY2F0KHIpLmNvbmNhdChlKTplKS50b1N0cmluZyhvKX0scGFyc2U6ZnVuY3Rpb24odCl7dmFyIGUscj1vLnBhcnNlKHQpLG49ci53b3JkcztyZXR1cm4gMTM5ODg5MzY4ND09blswXSYmMTcwMTA3NjgzMT09blsxXSYmKGU9aS5jcmVhdGUobi5zbGljZSgyLDQpKSxuLnNwbGljZSgwLDQpLHIuc2lnQnl0ZXMtPTE2KSxmLmNyZWF0ZSh7Y2lwaGVydGV4dDpyLHNhbHQ6ZX0pfX0sZz1yLlNlcmlhbGl6YWJsZUNpcGhlcj1uLmV4dGVuZCh7Y2ZnOm4uZXh0ZW5kKHtmb3JtYXQ6cH0pLGVuY3J5cHQ6ZnVuY3Rpb24odCxlLHIsbil7bj10aGlzLmNmZy5leHRlbmQobik7dmFyIGk9dC5jcmVhdGVFbmNyeXB0b3IocixuKSxhPWkuZmluYWxpemUoZSkscz1pLmNmZztyZXR1cm4gZi5jcmVhdGUoe2NpcGhlcnRleHQ6YSxrZXk6cixpdjpzLml2LGFsZ29yaXRobTp0LG1vZGU6cy5tb2RlLHBhZGRpbmc6cy5wYWRkaW5nLGJsb2NrU2l6ZTp0LmJsb2NrU2l6ZSxmb3JtYXR0ZXI6bi5mb3JtYXR9KX0sZGVjcnlwdDpmdW5jdGlvbih0LGUscixuKXtyZXR1cm4gbj10aGlzLmNmZy5leHRlbmQobiksZT10aGlzLl9wYXJzZShlLG4uZm9ybWF0KSx0LmNyZWF0ZURlY3J5cHRvcihyLG4pLmZpbmFsaXplKGUuY2lwaGVydGV4dCl9LF9wYXJzZTpmdW5jdGlvbih0LGUpe3JldHVybiJzdHJpbmciPT10eXBlb2YgdD9lLnBhcnNlKHQsdGhpcyk6dH19KSx5PShlLmtkZj17fSkuT3BlblNTTD17ZXhlY3V0ZTpmdW5jdGlvbih0LGUscixuLGEpe2lmKG58fChuPWkucmFuZG9tKDgpKSxhKXM9bC5jcmVhdGUoe2tleVNpemU6ZStyLGhhc2hlcjphfSkuY29tcHV0ZSh0LG4pO2Vsc2UgdmFyIHM9bC5jcmVhdGUoe2tleVNpemU6ZStyfSkuY29tcHV0ZSh0LG4pO3ZhciBvPWkuY3JlYXRlKHMud29yZHMuc2xpY2UoZSksNCpyKTtyZXR1cm4gcy5zaWdCeXRlcz00KmUsZi5jcmVhdGUoe2tleTpzLGl2Om8sc2FsdDpufSl9fSx3PXIuUGFzc3dvcmRCYXNlZENpcGhlcj1nLmV4dGVuZCh7Y2ZnOmcuY2ZnLmV4dGVuZCh7a2RmOnl9KSxlbmNyeXB0OmZ1bmN0aW9uKHQsZSxyLG4pe3ZhciBpPShuPXRoaXMuY2ZnLmV4dGVuZChuKSkua2RmLmV4ZWN1dGUocix0LmtleVNpemUsdC5pdlNpemUsbi5zYWx0LG4uaGFzaGVyKTtuLml2PWkuaXY7dmFyIGE9Zy5lbmNyeXB0LmNhbGwodGhpcyx0LGUsaS5rZXksbik7cmV0dXJuIGEubWl4SW4oaSksYX0sZGVjcnlwdDpmdW5jdGlvbih0LGUscixuKXtuPXRoaXMuY2ZnLmV4dGVuZChuKSxlPXRoaXMuX3BhcnNlKGUsbi5mb3JtYXQpO3ZhciBpPW4ua2RmLmV4ZWN1dGUocix0LmtleVNpemUsdC5pdlNpemUsZS5zYWx0LG4uaGFzaGVyKTtyZXR1cm4gbi5pdj1pLml2LGcuZGVjcnlwdC5jYWxsKHRoaXMsdCxlLGkua2V5LG4pfX0pfSgpKSkpKSkseS5leHBvcnRzKSxUPWUoQyksRj17ZXhwb3J0czp7fX07ZnVuY3Rpb24gSCgpe3JldHVybiBVfHwoVT0xLEYuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHI9dCxuPXIubGliLGk9bi5Xb3JkQXJyYXksYT1uLkhhc2hlcixzPXIuYWxnbyxvPVtdLGw9W107IWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtmb3IodmFyIHI9ZS5zcXJ0KHQpLG49MjtuPD1yO24rKylpZighKHQlbikpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gcih0KXtyZXR1cm4gNDI5NDk2NzI5NioodC0oMHx0KSl8MH1mb3IodmFyIG49MixpPTA7aTw2NDspdChuKSYmKGk8OCYmKG9baV09cihlLnBvdyhuLC41KSkpLGxbaV09cihlLnBvdyhuLDEvMykpLGkrKyksbisrfSgpO3ZhciBoPVtdLGM9cy5TSEEyNTY9YS5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5faGFzaD1uZXcgaS5pbml0KG8uc2xpY2UoMCkpfSxfZG9Qcm9jZXNzQmxvY2s6ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9dGhpcy5faGFzaC53b3JkcyxuPXJbMF0saT1yWzFdLGE9clsyXSxzPXJbM10sbz1yWzRdLGM9cls1XSx1PXJbNl0sXz1yWzddLGQ9MDtkPDY0O2QrKyl7aWYoZDwxNiloW2RdPTB8dFtlK2RdO2Vsc2V7dmFyIGY9aFtkLTE1XSxwPShmPDwyNXxmPj4+NyleKGY8PDE0fGY+Pj4xOCleZj4+PjMsZz1oW2QtMl0seT0oZzw8MTV8Zz4+PjE3KV4oZzw8MTN8Zz4+PjE5KV5nPj4+MTA7aFtkXT1wK2hbZC03XSt5K2hbZC0xNl19dmFyIHc9biZpXm4mYV5pJmEsdj0objw8MzB8bj4+PjIpXihuPDwxOXxuPj4+MTMpXihuPDwxMHxuPj4+MjIpLG09XysoKG88PDI2fG8+Pj42KV4obzw8MjF8bz4+PjExKV4obzw8N3xvPj4+MjUpKSsobyZjXn5vJnUpK2xbZF0raFtkXTtfPXUsdT1jLGM9byxvPXMrbXwwLHM9YSxhPWksaT1uLG49bSsodit3KXwwfXJbMF09clswXStufDAsclsxXT1yWzFdK2l8MCxyWzJdPXJbMl0rYXwwLHJbM109clszXStzfDAscls0XT1yWzRdK298MCxyWzVdPXJbNV0rY3wwLHJbNl09cls2XSt1fDAscls3XT1yWzddK198MH0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9kYXRhLHI9dC53b3JkcyxuPTgqdGhpcy5fbkRhdGFCeXRlcyxpPTgqdC5zaWdCeXRlcztyZXR1cm4gcltpPj4+NV18PTEyODw8MjQtaSUzMixyWzE0KyhpKzY0Pj4+OTw8NCldPWUuZmxvb3Iobi80Mjk0OTY3Mjk2KSxyWzE1KyhpKzY0Pj4+OTw8NCldPW4sdC5zaWdCeXRlcz00KnIubGVuZ3RoLHRoaXMuX3Byb2Nlc3MoKSx0aGlzLl9oYXNofSxjbG9uZTpmdW5jdGlvbigpe3ZhciB0PWEuY2xvbmUuY2FsbCh0aGlzKTtyZXR1cm4gdC5faGFzaD10aGlzLl9oYXNoLmNsb25lKCksdH19KTtyLlNIQTI1Nj1hLl9jcmVhdGVIZWxwZXIoYyksci5IbWFjU0hBMjU2PWEuX2NyZWF0ZUhtYWNIZWxwZXIoYyl9KE1hdGgpLHQuU0hBMjU2fShfKCkpKSxGLmV4cG9ydHN9dmFyIFosTT1lKEgoKSksTj17ZXhwb3J0czp7fX07dmFyIEksaj0oWnx8KFo9MSxOLmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoImZ1bmN0aW9uIj09dHlwZW9mIEFycmF5QnVmZmVyKXt2YXIgZT10LmxpYi5Xb3JkQXJyYXkscj1lLmluaXQsbj1lLmluaXQ9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyJiYodD1uZXcgVWludDhBcnJheSh0KSksKHQgaW5zdGFuY2VvZiBJbnQ4QXJyYXl8fCJ1bmRlZmluZWQiIT10eXBlb2YgVWludDhDbGFtcGVkQXJyYXkmJnQgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheXx8dCBpbnN0YW5jZW9mIEludDE2QXJyYXl8fHQgaW5zdGFuY2VvZiBVaW50MTZBcnJheXx8dCBpbnN0YW5jZW9mIEludDMyQXJyYXl8fHQgaW5zdGFuY2VvZiBVaW50MzJBcnJheXx8dCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheXx8dCBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkmJih0PW5ldyBVaW50OEFycmF5KHQuYnVmZmVyLHQuYnl0ZU9mZnNldCx0LmJ5dGVMZW5ndGgpKSx0IGluc3RhbmNlb2YgVWludDhBcnJheSl7Zm9yKHZhciBlPXQuYnl0ZUxlbmd0aCxuPVtdLGk9MDtpPGU7aSsrKW5baT4+PjJdfD10W2ldPDwyNC1pJTQqODtyLmNhbGwodGhpcyxuLGUpfWVsc2Ugci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O24ucHJvdG90eXBlPWV9fSgpLHQubGliLldvcmRBcnJheX0oXygpKSksTi5leHBvcnRzKSxQPWUoaiksJD17ZXhwb3J0czp7fX07dmFyIEs9KEl8fChJPTEsJC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiB0LkhtYWNTSEEyNTZ9KF8oKSxIKCksRSgpKSksJC5leHBvcnRzKSxYPWUoSyk7Y29uc3QgRz0hMTtsZXQgVyxZPWZldGNoO29ubWVzc2FnZT1mdW5jdGlvbih0KXtjb25zdHtqb2I6ZSxjbWQ6cixzZXJ2ZXI6bixwYXRoOmksYnVmZmVyOmEsa2V5QmFzZTY0OnMsZ3ppcDpsLHJlZmVycmVyOmgsaWQ6YyxhcHBJZDp1LHBlcnNpc3RlbnRJZDpfLENST1FVRVRfVkVSU0lPTjpkLGRlYnVnOmYsd2hhdDpwLG9mZmxpbmU6eX09dC5kYXRhO3kmJihZPWspO3N3aXRjaChyKXtjYXNlInVwbG9hZEVuY3J5cHRlZCI6eChpKTticmVhaztjYXNlImdldE9mZmxpbmVGaWxlIjp6KHQuZGF0YS51cmwpO2JyZWFrO2RlZmF1bHQ6Y29uc29sZS5lcnJvcigiVW5rbm93biB3b3JrZXIgY29tbWFuZCIscil9ZnVuY3Rpb24gdyh0KXtjb25zdCBlPURhdGUubm93KCkscj1QLmNyZWF0ZSh0KSxuPWcucGFyc2UocyksaT1YKHIsbiksYT1QLnJhbmRvbSgxNikse2NpcGhlcnRleHQ6b309VC5lbmNyeXB0KHIsbix7aXY6YX0pLGw9bmV3IEFycmF5QnVmZmVyKDQrYS5zaWdCeXRlcytpLnNpZ0J5dGVzK28uc2lnQnl0ZXMpLGg9bmV3IERhdGFWaWV3KGwpO2xldCB1PTA7aC5zZXRVaW50MzIodSwxMTI5NDY4MjA5LCExKSx1Kz00O2Zvcihjb25zdCB0IG9mW2EsaSxvXSlmb3IoY29uc3QgZSBvZiB0LndvcmRzKWguc2V0SW50MzIodSxlLCExKSx1Kz00O3JldHVybiBmJiZjb25zb2xlLmxvZyhjLGAke3B9IGVuY3J5cHRlZCAoJHtsLmJ5dGVMZW5ndGh9IGJ5dGVzKSBpbiAke0RhdGUubm93KCktZX1tc2ApLGx9ZnVuY3Rpb24gdih0KXtjb25zdCBlPURhdGUubm93KCkscj1vLmRlZmxhdGUodCx7Z3ppcDohMCxsZXZlbDoxfSk7cmV0dXJuIGYmJmNvbnNvbGUubG9nKGMsYCR7cH0gY29tcHJlc3NlZCAoJHtyLmxlbmd0aH0gYnl0ZXMpIGluICR7RGF0ZS5ub3coKS1lfW1zYCkscn1mdW5jdGlvbiBtKHQpe2NvbnN0IGU9RGF0ZS5ub3coKSxyPU0oUC5jcmVhdGUodCkpLG49Zy5zdHJpbmdpZnkocikucmVwbGFjZSgvPS9nLCIiKS5yZXBsYWNlKC9cKy9nLCItIikucmVwbGFjZSgvXC8vZywiXyIpO3JldHVybiBmJiZjb25zb2xlLmxvZyhjLGAke3B9IGhhc2hlZCAoJHt0LmJ5dGVMZW5ndGh9IGJ5dGVzKSBpbiAke0RhdGUubm93KCktZX1tc2ApLG59YXN5bmMgZnVuY3Rpb24gYih0KXtpZih5KXtjb25zdCBlPWBvZmZsaW5lOi8vLyR7dH1gO3JldHVybnt1cmw6ZSx1cGxvYWRVcmw6ZX19Y29uc3QgZT1EYXRlLm5vdygpLHI9YCR7bi51cmx9LyR7dH1gO2lmKCFuLmFwaUtleSlyZXR1cm57dXJsOnIsdXBsb2FkVXJsOnJ9O2NvbnN0IGk9YXdhaXQgWShyLHtoZWFkZXJzOnsiWC1Dcm9xdWV0LUF1dGgiOm4uYXBpS2V5LCJYLUNyb3F1ZXQtQXBwIjp1LCJYLUNyb3F1ZXQtSWQiOl8sIlgtQ3JvcXVldC1TZXNzaW9uIjpjLCJYLUNyb3F1ZXQtVmVyc2lvbiI6ZCwiWC1Dcm9xdWV0LVBhdGgiOm5ldyBVUkwoaCkucGF0aG5hbWV9LHJlZmVycmVyOmh9KSx7b2s6YSxzdGF0dXM6cyxzdGF0dXNUZXh0Om99PWk7aWYoIWEpdGhyb3cgRXJyb3IoYEVycm9yIGluIHNpZ25pbmcgVVJMOiAke3N9IC0gJHtvfWApO2NvbnN0e2Vycm9yOmwscmVhZDpnLHdyaXRlOnd9PWF3YWl0IGkuanNvbigpO2lmKGwpdGhyb3cgRXJyb3IobCk7cmV0dXJuIGYmJmNvbnNvbGUubG9nKGMsYCR7cH0gdXBsb2FkIGF1dGhvcml6ZWQgaW4gJHtEYXRlLm5vdygpLWV9bXNgKSx7dXJsOmcsdXBsb2FkVXJsOnd9fWFzeW5jIGZ1bmN0aW9uIHgodCl7dHJ5e2xldCByPXcobD92KGEpOmEpO0csdC5pbmNsdWRlcygiJUhBU0glIikmJih0PXQucmVwbGFjZSgiJUhBU0glIixtKHIpKSk7Y29uc3R7dXBsb2FkVXJsOm4sdXJsOml9PWF3YWl0IGIodCkscz1EYXRlLm5vdygpLHtvazpvLHN0YXR1czp1LHN0YXR1c1RleHQ6X309YXdhaXQgWShuLHttZXRob2Q6IlBVVCIsbW9kZToiY29ycyIsaGVhZGVyczp7IkNvbnRlbnQtVHlwZSI6ImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSJ9LHJlZmVycmVyOmgsYm9keTpyfSk7aWYoIW8pdGhyb3cgRXJyb3IoYHNlcnZlciByZXR1cm5lZCAke3V9ICR7X30gZm9yIFBVVCAke259YCk7ZiYmY29uc29sZS5sb2coYyxgJHtwfSB1cGxvYWRlZCAoJHt1fSkgaW4gJHtEYXRlLm5vdygpLXN9bXMgJHtpfWApLFcoe2pvYjplLHVybDppLG9rOm8sc3RhdHVzOnUsc3RhdHVzVGV4dDpfLGJ5dGVzOnIuYnl0ZUxlbmd0aH0pfWNhdGNoKHQpe2YmJmNvbnNvbGUuZXJyb3IoYCR7Y30gdXBsb2FkIGVycm9yICR7dC5tZXNzYWdlfWApLFcoe2pvYjplLG9rOiExLHN0YXR1czotMSxzdGF0dXNUZXh0OnQubWVzc2FnZX0pfX1mdW5jdGlvbiBrKHQsZSl7cmV0dXJuIGYmJmNvbnNvbGUubG9nKGMsYHN0b3JpbmcgJHt0fWApLHEuc2V0KHQsZS5ib2R5KSx7b2s6ITAsc3RhdHVzOjIwMSxzdGF0dXNUZXh0OiJPZmZsaW5lIGNyZWF0ZWQifX1mdW5jdGlvbiB6KHQpe2NvbnN0IHI9cS5nZXQodCk7aWYoIXIpcmV0dXJuIGYmJmNvbnNvbGUuZXJyb3IoYCR7Y30gZmlsZSBub3QgZm91bmQgJHt0fWApLHZvaWQgVyh7am9iOmUsb2s6ITEsc3RhdHVzOi0xLHN0YXR1c1RleHQ6Ik9mZmxpbmUgZmlsZSBub3QgZm91bmQifSk7ZiYmY29uc29sZS5sb2coYyxgcmV0cmlldmVkICR7dH1gKSxXKHtqb2I6ZSxvazohMCxzdGF0dXM6MjAwLHN0YXR1c1RleHQ6Ik9mZmxpbmUgZmlsZSBmb3VuZCIsYm9keTpyLGJ5dGVzOnIuYnl0ZUxlbmd0aH0pfX0sVz1wb3N0TWVzc2FnZTtjb25zdCBxPW5ldyBNYXB9KCk7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPXVwbG9hZC5qcy5tYXAKCg==");
    var Bl = l2.CROQUET_VERSION;
    var Al = "node" === l2.CROQUET_PLATFORM;
    var $l = "https://croquet.io/files/v1";
    var ql = "https://files.croquet.io";
    var tc = ql;
    var ec = null;
    function sc() {
      globalThis.__MULTISYNQ__ || (Al ? console.log("Croquet " + Bl) : console.log("%cCroquet%c %c" + Bl, "color:#F0493E", "color:inherit", "color:" + (Bl.includes("+") ? "#909" : "inherit")));
      const t3 = !Al && window.location.hostname.match(/^(.*\.)?croquet\.io$/i) && window.location.pathname.startsWith("/dev/"), e3 = m.dev || false !== m.dev && t3;
      if (ec = { messages: m.has("debug", "messages", false), sends: m.has("debug", "sends", false), publish: m.has("debug", "publish", false), events: m.has("debug", "events", false), ticks: m.has("debug", "ticks", false), pong: m.has("debug", "pong", false), snapshot: m.has("debug", "snapshot", false), session: m.has("debug", "session", false), initsnapshot: m.has("debug", "initsnapshot", true), reflector: m.has("debug", "reflector", e3), offline: m.has("debug", "offline", false) }, ec.offline && Qt.showMessage(`${Qt.libName}: offline mode enabled, no multiuser`, { level: "warning" }), m.box) {
        let t4 = new URL(m.box, window.location).href;
        t4.endsWith("/") || (t4 += "/"), m.reflector = t4 + "reflector", m.files = t4 + "files";
      }
    }
    function nc() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
      ec || sc(), "string" == typeof t3 && (t3 = Object.fromEntries(t3.split(",").map((e3) => [e3.replace(/^no/, ""), !t3.startsWith("no")])));
      for (const [e3, s3] of Object.entries(t3)) e3 in ec ? ec[e3] = s3 : Qt.showMessage(`${Qt.libName}: unknown debug option "${e3}"`, { level: "warning", only: "once" });
      return ec;
    }
    var ic = "wss://api.multisynq.io/depin";
    var oc = ic;
    var rc;
    var ac;
    var lc = "reflector";
    var cc = m.nocheat;
    var dc = 200;
    var hc = [0];
    var uc = 4096;
    var mc;
    var pc = new Ol();
    pc.onerror = (t3) => console.error(`UploadWorker error: ${t3.message}`);
    var fc = 0;
    var bc = /* @__PURE__ */ new Set();
    function yc() {
      let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", e3 = null;
      for (const s3 of bc) if (e3 || (e3 = s3), s3.id === t3) {
        e3 = s3;
        break;
      }
      if (e3) {
        const { appId: t4, persistentId: s3 } = e3.sessionSpec;
        return { appId: t4, persistentId: s3, key: e3.key, uploadEncrypted: (t5) => e3.uploadEncrypted(t5), downloadEncrypted: (t5) => e3.downloadEncrypted(t5) };
      }
      return {};
    }
    Object.defineProperty(Ot, "controller", { get() {
      return this.controllers.values().next().value;
    } }), Ot.controllers = bc;
    var gc = class {
      constructor() {
        ec || sc(), this.reset();
      }
      reset() {
        globalThis.CROQUETVM === this.vm && delete globalThis.CROQUETVM, this.vm = null, this.session = null, this.connection = this.connection || new wc(this), this.networkQueue = [], this.reflectorTime = 0, this.msPerTick = this.msPerTick || 0, this.tickMultiplier = this.tickMultiplier || 1, this.extrapolatedTimeBase = Date.now(), this.key = this.key || null, this.tove = this.tove || null, this.viewId = this.viewId || Math.floor(Math.random() * 36 ** 10).toString(36), this.viewDataEncrypted = this.viewDataEncrypted || null, this.timeline = "", this.rejoinTimeout && clearTimeout(this.rejoinTimeout), this.rejoinTimeout = 0, this.sendBuffer = [], this.users = 0, this.usersTotal = 0, this.cpuTime = 0, this.triggeringCpuTime = null, this.lastSnapshotRequest = 0, this.synced = null, this.latency = 0, this.latencyHistory && (this.latencyHistory = []), this.localTicker && (globalThis.clearInterval(this.localTicker), delete this.localTicker), this.syncTimer && (globalThis.clearTimeout(this.syncTimer), delete this.syncTimer), this.tuttiHistory = [], this.auditStats = { lastUsers: -1, minUsers: -1, maxUsers: -1, payloadTally: 0 }, this.lastAnimationEnd = 0, this.animationGapCheck = [], this.rateLimitedSendTimes = [], this.rateLimitBuffer = [], this.rateLimitSoftWarned = false, this.rateLimitBufferWarned = false, this.rateLimitLastLogged = 0, this.payloadSizeWarned = false, Ot.removeAllSubscriptionsFor(this.viewId), Ot.addSubscription(this.viewId, "__views__", this.viewId, (t3) => kt(`users now ${t3}`), "oncePerFrameWhileSynced"), this.leaving || Qt.showSyncWait(true);
      }
      get id() {
        return this.vm ? this.vm.id : this.sessionSpec.id;
      }
      get persistentId() {
        return this.sessionSpec.persistentId;
      }
      get versionId() {
        return this.sessionSpec.codeHash;
      }
      get extrapolatedTime() {
        return Date.now() - this.extrapolatedTimeBase;
      }
      get viewOnly() {
        return this.sessionSpec.viewOnly;
      }
      get backlog() {
        return this.vm ? this.reflectorTime - this.vm.time : 0;
      }
      get starvation() {
        return Date.now() - this.lastReceived;
      }
      get lag() {
        return this.vm ? Math.max(0, this.extrapolatedTime - this.vm.time - this.msPerTick) : 0;
      }
      get activity() {
        return Date.now() - this.lastSent;
      }
      get viewed() {
        return !(!this.session || !this.session.view);
      }
      get connected() {
        return this.connection.connected;
      }
      get shouldLeaveWhenDisconnected() {
        return this.leaving || !this.canRejoinSeamlessly || 0 === this.sessionSpec.rejoinLimit;
      }
      get canRejoinSeamlessly() {
        return !!this.timeline;
      }
      get migratingOldSnapshot() {
        if (!this.sessionSpec) return false;
        const { codeHash: t3, computedCodeHash: e3 } = this.sessionSpec;
        return t3 !== e3;
      }
      checkForConnection(t3) {
        this.connection.checkForConnection(t3);
      }
      dormantDisconnect() {
        this.connected && this.connection.dormantDisconnect();
      }
      async initFromSessionSpec(t3) {
        const { name: s3, optionsFromUrl: n3, persistentIdOptions: i3, password: o3, appId: r2, apiKey: a3, viewData: l3, viewIdDebugSuffix: c2, location: d2 } = t3, h2 = r2 ? `${r2}/${s3}` : s3;
        this.key = io(o3, "", { keySize: 8, hasher: Ui.algo.SHA1, iterations: 1 }), c2 && (this.viewId = this.viewId.replace(/_.*$/, "") + "_" + encodeURIComponent(("" + c2).slice(0, 16)).replace(/[^a-z0-9]/gi, (t4) => `_${"%" === t4 ? "" : t4.charCodeAt(0).toString(16).toUpperCase()}`));
        const u2 = { ...t3.options };
        if (n3) for (const t4 of n3) t4 in m && (u2[t4] = m[t4]);
        const p2 = {}, f2 = {};
        for (const [t4, e3] of Object.entries(u2)) (i3 == null ? void 0 : i3.includes(t4)) ? p2[t4] = e3 : f2[t4] = e3;
        const b2 = ec.events || ec.publish;
        b2 && (f2.__debugEvents = true), d2 && (f2.__location = true);
        const y2 = m.hashOverride || t3.hashOverride, g2 = await async function(t4, s4) {
          return Q(t4 + e2(s4));
        }(h2, p2), { developerId: w2, token: Z2 } = await this.verifyApiKey(a3, r2, g2), { id: X2, codeHash: v2, computedCodeHash: L2 } = await async function(t4, s4, n4, i4, o4) {
          let r3, a4;
          const l4 = D[t4];
          let c3 = "";
          l4 ? (r3 = l4.codeHashes, a4 = l4.computedCodeHash, c3 = " (code hashing from cache)") : (r3 = await Promise.all(U), a4 = await Q([o4, ...r3].join("|")), D[t4] = { codeHashes: r3, computedCodeHash: a4 });
          const d3 = i4 || a4, h3 = await Q(t4 + "|" + s4 + e2(n4) + d3);
          if (E() && !O.has(h3)) {
            (K ? "utf-8" : [...document.getElementsByTagName("meta")].find((t5) => t5.getAttribute("charset"))) || console.warn(`${Qt.libName}: Missing <meta charset="..."> declaration. ${Qt.libName} model code hashing might differ between browsers.`), j[a4].what = "Version ID", j[t4].what = "Persistent ID", j[h3].what = "Session ID", d3 !== a4 && (r3.push(a4), j[a4].what = "Computed Version ID (replaced by overrideHash)", j[d3] = { what: "Version ID (as specified by overrideHash)" });
            const e3 = [...r3, d3, t4, h3].map((t5) => ({ hash: t5, ...j[t5] }));
            console.log(`${Qt.libName}: Debug Hashing for session ${h3}${c3}`, e3), O.add(h3);
          }
          return E() || (j = {}), { id: h3, persistentId: t4, codeHash: d3, computedCodeHash: a4 };
        }(g2, w2, f2, y2, Bl);
        this.tove || (this.tove = await this.encrypt(X2)), l3 && !this.viewDataEncrypted && (this.viewDataEncrypted = await this.encryptPayload(l3)), ec.session && console.log(`${Qt.libName} session "${h2}":
        sessionId=${X2}${r2 ? `
        persistentId=${g2}` : ""}
        versionId=${v2 === L2 ? v2 : `${v2} (specified in hashOverride)
        versionId=${L2} (computed)`}
        viewId=${this.viewId}`), this.eventRateLimit = t3.eventRateLimit, this.eventHistoryLimit = this.eventRateLimit, this.eventMaxBundles = this.eventRateLimit, this.sessionSpec = { ...t3, options: u2, name: h2, id: X2, persistentId: g2, developerId: w2, token: Z2, codeHash: v2, computedCodeHash: L2, debugEvents: b2 };
        const { msPerTick: x2, multiplier: S2 } = this.getTickAndMultiplier();
        this.msPerTick = x2, this.tickMultiplier = S2, this.setUpActivityChecks();
      }
      async establishSession() {
        const { id: t3, persistentId: e3, codeHash: s3 } = this.sessionSpec;
        this.sessionSpec.snapshot = { id: t3, time: 0, meta: { id: t3, persistentId: e3, codeHash: s3, created: (/* @__PURE__ */ new Date()).toISOString() } };
        const n3 = new Promise((t4) => {
          this.sessionSpec.sessionJoined = t4;
        });
        this.checkForConnection(false), ec.session && console.log(t3, "waiting for join and SYNC"), await n3, this.sessionSpec.sessionJoined = () => {
        }, this.syncCompleted = true;
      }
      getBackend(t3) {
        var _a3;
        if (ec.offline) return { apiKey: "none", signServer: "none", reflector: "none" };
        if (m.box || m.reflector) return { apiKey: "none", signServer: "none", reflector: m.reflector };
        const e3 = {};
        for (const s4 of t3.split(",")) {
          const t4 = s4.lastIndexOf(":"), n4 = s4[-1 === t4 ? 0 : t4 + 1];
          if (!(n4 == null ? void 0 : n4.match(/^[12]$/))) throw Error("Invalid API key: " + s4);
          if (n4 in e3) throw Error("Duplicate API key versions");
          e3[n4] = { key: -1 === t4 ? s4 : s4.slice(t4 + 1), backend: -1 === t4 ? "" : s4.slice(0, t4) };
        }
        let s3 = !e3[1];
        s3 && e3[2].backend && (s3 = e3[2].backend), function(t4) {
          void 0 === rc && (rc = "depin" in m ? m.depin : t4, rc && !ec.offline ? (ac = true === rc ? oc : "prod" === rc ? ic : "dev" === rc ? "wss://api.multisynq.dev/depin" : "local" === rc ? "ws://localhost:8787" : rc, ac.endsWith("/") && (ac = ac.slice(0, -1)), ac = ac.replace(/^http(s):/, "ws$1:"), ac.startsWith("ws") || (ac = (Al || "https:" !== window.location.protocol ? "ws://" : "wss://") + ac), lc = "synchronizer", ec.session && console.log(`DEPIN_API=${ac}`)) : rc = false);
        }(s3);
        const n3 = e3[rc ? 2 : 1];
        if (!n3) throw Error(`No ${rc ? "Multisynq" : "Croquet"} API key provided`);
        const i3 = n3.key, o3 = m.backend || n3.backend, r2 = (_a3 = m.reflector) == null ? void 0 : _a3.includes("/");
        if ("none" === o3) return { apiKey: i3, signServer: "none", reflector: "overridden" };
        if (rc) return { apiKey: i3, signServer: `${ac.replace(/^ws/, "http")}/clients`, reflector: "depin" };
        return { apiKey: i3, signServer: "https://api.croquet.io/sign", reflector: r2 ? "overridden" : "wss://api.croquet.io/reflector/v1" };
      }
      async verifyApiKey(t3, e3, s3) {
        const { signServer: n3, apiKey: i3 } = this.getBackend(t3);
        if ("none" === n3) return { developerId: "unknown_dev_id" };
        try {
          const t4 = 2, o3 = await this.fetchWithRetries("verifying API key", [403], t4, () => fetch(`${n3}/join?meta=login`, { method: "GET", mode: "cors", headers: { "X-Croquet-Auth": i3, "X-Croquet-App": e3, "X-Croquet-Id": s3, "X-Croquet-Version": Bl, "X-Croquet-Path": new URL(Qt.referrerURL()).pathname }, referrer: Qt.referrerURL(), referrerPolicy: "no-referrer-when-downgrade" })), r2 = await o3.json(), { developerId: a3, error: l3 } = r2;
          if (l3) throw Error(l3);
          return ec.session && console.log(`${rc ? "Multisynq" : "Croquet"}: verified API key for developer ${a3}`), r2;
        } catch (t4) {
          throw Error(`${rc ? "Multisynq" : "Croquet"} API key validation failed for "${i3}": ${t4.message}`);
        }
      }
      async fetchWithRetries(t3, e3, s3, n3) {
        const i3 = 1 + s3;
        let o3, r2 = 0;
        for (; ; ) {
          let s4, a3;
          try {
            if (s4 = await n3(), s4.ok) return s4;
          } catch (t4) {
            a3 = t4;
          }
          r2++;
          let l3 = "";
          const c2 = s4 && e3.includes(s4.status);
          if (c2 ? l3 = "fatal " : r2 === i3 && (l3 = "final "), o3 = s4 ? `${l3}status ${s4.status} ${s4.statusText} - "${await s4.text()}"` : `${l3}error "${a3 == null ? void 0 : a3.message}"`, r2 === i3 || c2) break;
          const d2 = 1 === r2 ? 100 : 2 === r2 ? 1e3 : 5e3;
          console.warn(`${o3} while ${t3}; retrying in ${d2}ms`), await new Promise((t4) => {
            setTimeout(t4, d2);
          });
        }
        throw console.warn(`${o3} while ${t3}; giving up`), Error(o3);
      }
      lastKnownTime(t3) {
        return Math.max(t3.time, t3.externalTime);
      }
      takeSnapshot() {
        const t3 = this.vm.snapshot(), e3 = this.lastKnownTime(t3), s3 = t3.externalSeq;
        return t3.meta = { ...this.sessionSpec.snapshot.meta, options: this.sessionSpec.options, time: e3, seq: s3, date: new globalThis.CroquetViewDate().toISOString(), host: Al ? "localhost" : window.location.hostname, sdk: Bl }, delete t3.meta.hash, t3;
      }
      takeSnapshotHandleErrors() {
        let t3, e3, s3;
        try {
          t3 = Zt.begin("snapshot"), s3 = this.takeSnapshot();
        } catch (t4) {
          return Pt("snapshot", t4), null;
        } finally {
          e3 = Zt.end("snapshot") - t3;
        }
        return ec.snapshot && console.log(this.id, `snapshot taken in ${Math.ceil(e3)}ms`), s3;
      }
      setDebug(t3) {
        return nc(t3);
      }
      requestDebugSnapshot() {
        nc("snapshot"), this.triggeringCpuTime = 1e-10, this.scheduleSnapshot(this.viewId);
      }
      scheduleSnapshot() {
        let t3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        if (!this.connected || !this.vm || this.viewOnly) return;
        const e3 = this.vm.time, s3 = e3 - this.vm.lastSnapshotPoll;
        if (s3 < 5e3 && !t3) return void (ec.snapshot && console.log(`not requesting snapshot poll (${s3}ms since poll scheduled)`));
        if (this.migratingOldSnapshot) return void alert("Snapshot is due but hashOverride is set. Ignoring.");
        if (t3) {
          const e4 = Object.keys(this.vm.views);
          if (e4.sort(), t3 !== this.viewId && e4[0] !== this.viewId && e4[1] !== this.viewId && e4[2] !== this.viewId) return void (ec.snapshot && console.log("not forcing snapshot poll (not one of the three)"));
          ec.snapshot && console.log("forcing snapshot poll");
        }
        const n3 = new dd(e3, 0, "_", "handlePollForSnapshot", []);
        this.sendTagged(n3, { debounce: 5e3, msgID: "pollForSnapshot" }), ec.snapshot && console.log(this.id, `requesting snapshot poll via ${lc}`);
      }
      handlePollForSnapshot(t3) {
        if (true !== this.synced || this.viewOnly) return void (this.triggeringCpuTime = null);
        const e3 = this.triggeringCpuTime || this.cpuTime;
        let s3, n3, i3;
        this.triggeringCpuTime = null, this.cpuTime = 0;
        try {
          s3 = Zt.begin("snapshot"), n3 = { cpuTime: e3, hash: this.vm.getSummaryHash(), viewId: this.viewId };
        } catch (t4) {
          return void Pt("snapshot", t4);
        } finally {
          i3 = Zt.end("snapshot") - s3, this.cpuTime -= i3;
        }
        ec.snapshot && console.log(this.id, `Summary hashing took ${Math.ceil(i3)}ms`), queueMicrotask(() => this.pollForSnapshot(t3, n3));
      }
      pollForSnapshot(t3, e3) {
        e3.cpuTime += Math.random(), ec.snapshot && console.log(this.id, "sending snapshot vote", e3), this.sendTutti({ time: t3, topic: "snapshot", data: e3, tallyTarget: ["handleSnapshotVote"] });
      }
      handleSnapshotVote(t3) {
        const { tally: e3 } = t3;
        ec.snapshot && console.log(this.id, "received snapshot votes", e3);
        const { numberOfGroups: s3, shouldUpload: n3, dissidentFlag: i3 } = this.analyzeTally(e3, "cpuTime");
        if (s3 > 1) {
          this.diverged = true;
          const t4 = this.vm.diverged ? this.vm.diverged.size : 0;
          console.error(this.id, `Session diverged (#${t4})! Snapshots fall into ${s3} groups`);
        }
        if (true !== this.synced) ec.snapshot && console.log(this.id, "Ignoring snapshot vote during sync");
        else if (n3) {
          const t4 = { ...this.auditStats }, e4 = this.takeSnapshotHandleErrors();
          e4 && queueMicrotask(() => this.uploadSnapshot(e4, t4, i3));
        }
      }
      analyzeTally(t3, e3) {
        let s3 = false, n3 = null;
        const i3 = [], o3 = {};
        let r2 = null;
        Object.keys(t3).forEach((t4, e4) => {
          const s4 = JSON.parse(t4);
          i3.push(s4);
          const { hash: n4, viewId: a4 } = s4;
          a4 === this.viewId && (r2 = e4), o3[n4] || (o3[n4] = []), o3[n4].push(e4);
        });
        const a3 = Object.keys(o3), l3 = a3.length;
        let c2 = 0;
        l3 > 1 && (a3.sort((t4, e4) => o3[e4].length - o3[t4].length), o3[a3[0]].length === o3[a3[1]].length && (ec.snapshot && console.log(this.id, "Deciding consensus by tie-break"), a3[1] < a3[0] && (c2 = 1)));
        const d2 = a3[c2];
        if (null !== r2) {
          const t4 = i3[r2].hash, a4 = o3[t4];
          a4.length > 1 && a4.sort((t5, s4) => i3[t5][e3] - i3[s4][e3]), a4[0] === r2 && (s3 = true, t4 !== d2 && (n3 = { groupVotes: a4.length, allVotes: i3.length }));
        }
        return { numberOfGroups: l3, shouldUpload: s3, dissidentFlag: n3 };
      }
      snapshotPath(t3, e3, s3) {
        const n3 = Math.ceil(t3).toString().padStart(10, "0"), { appId: i3, persistentId: o3, codeHash: r2, apiKey: a3 } = this.sessionSpec;
        return a3 ? `apps/${i3}/snap/${r2}/${o3}.${this.id}/${n3}_${e3}.${s3}` : `snapshots/${this.id}/${n3}_${e3}-${s3}.snap`;
      }
      hashSnapshot(t3) {
        return t3.meta.hash ? t3.meta.hash : (t3.meta.hashPromise || (t3.meta.hashPromise = new Promise((e3) => {
          const s3 = { ...t3 };
          delete s3.meta, Q(JSON.stringify(s3)).then((s4) => {
            t3.meta.hash = s4, delete t3.meta.hashPromise, e3(s4);
          });
        })), t3.meta.hashPromise);
      }
      uploadServer(t3) {
        if ("string" == typeof m.files) {
          let t4 = new URL(m.files, window.location).href;
          return t4.endsWith("/") && (t4 = t4.slice(0, -1)), { url: t4, apiKey: null };
        }
        const { apiKey: e3, signServer: s3 } = this.getBackend(t3);
        if ("none" === s3 && !ec.offline) throw Error("no file server configured");
        return { url: s3, apiKey: e3 };
      }
      async uploadSnapshot(t3, e3) {
        let s3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
        await this.hashSnapshot(t3);
        const n3 = Zt.begin("snapshot"), i3 = JSON.stringify(t3), o3 = Zt.end("snapshot") - n3;
        ec.snapshot && console.log(this.id, `snapshot stringified (${i3.length} bytes) in ${Math.ceil(o3)}ms`);
        const { time: r2, seq: a3, hash: l3 } = t3.meta, c2 = this.connection.socket;
        try {
          const t4 = await this.uploadEncrypted({ content: i3, path: this.snapshotPath(r2, a3, l3), key: this.key, gzip: true, debug: ec.snapshot, what: "snapshot" });
          return this.connection.socket !== c2 ? (console.warn(this.id, "Controller was reset while trying to upload snapshot"), false) : (this.announceSnapshotUrl(r2, a3, l3, t4, e3, s3), true);
        } catch (t4) {
          return console.error(this.id, "Failed to upload snapshot"), false;
        }
      }
      announceSnapshotUrl(t3, e3, s3, n3, i3, o3) {
        if (ec.snapshot) {
          let i4 = `time: ${t3}, seq: ${e3}, hash: ${s3}`;
          o3 && (i4 += ", as dissident; " + JSON.stringify(o3)), console.log(this.id, `sending snapshot url to ${lc} (${i4}): ${n3}`);
        }
        try {
          this.connection.send(JSON.stringify({ id: this.id, action: "SNAP", args: { time: t3, seq: e3, hash: s3, url: n3, auditStats: i3, dissident: o3 } }));
        } catch (t4) {
          console.error("ERROR while sending", t4);
        }
        this.diverged && this.vm.publishFromView("__VM__", "__diverged__", { key: `@${t3}#${e3}`, url: n3, dissident: o3 });
      }
      async diffDivergedSnapshots(t3) {
        const e3 = await Promise.all(t3.map((t4) => this.downloadEncrypted({ url: t4, gzip: true, key: this.key, debug: ec.snapshot, json: true, what: "diverged snapshot" })));
        for (const t4 of e3) delete t4.meta;
        let s3 = 0;
        !function t4(e4, n3, i3) {
          if (typeof e4 != typeof n3) console.log(`${i3} diverged (${typeof e4} vs ${typeof n3}):`, e4, n3), s3++;
          else if (Array.isArray(e4) !== Array.isArray(n3)) console.log(`${i3} diverged (array vs object):`, e4, n3), s3++;
          else if ("object" == typeof e4) {
            const o3 = e4 ? Object.keys(e4) : [], r2 = n3 ? Object.keys(n3) : [], a3 = o3.filter((t5) => !r2.includes(t5)), l3 = r2.filter((t5) => !o3.includes(t5));
            (a3.length || l3.length) && (console.log(`${i3} diverged (keys mismatch):`, a3, l3), s3++);
            for (const s4 of o3) r2.includes(s4) && t4(e4[s4], n3[s4], `${i3}${Mc(e4, s4)}`);
          } else e4 !== n3 && (console.log(`${i3} diverged (value mismatch):`, e4, n3), s3++);
        }(e3[0], e3[1], "CROQUETVM"), s3 ? console.log(`Total ${s3} differences between diverged snapshots:`, e3.slice(0, 2)) : console.log("... but diverged snapshots are identical?!");
      }
      async downloadEncrypted(t3) {
        let { url: e3, gzip: s3, key: n3, debug: i3, json: o3, what: r2 } = t3;
        e3.startsWith($l) && (e3 = e3.replace($l, ql));
        const a3 = e3.startsWith("offline:"), l3 = a3 ? 1 : 3;
        let c2 = Date.now();
        const d2 = await this.fetchWithRetries(`fetching ${r2}`, [], l3, () => a3 ? this.fetchOffline(e3, r2, i3) : fetch(e3, { method: "GET", mode: "cors", referrer: Qt.referrerURL() })), h2 = await d2.arrayBuffer();
        i3 && console.log(this.id, `${r2} fetched (${h2.byteLength} bytes) in ${-c2 + (c2 = Date.now())}ms`), Zt.addNetworkTraffic(`${r2}_in`, h2.byteLength);
        const u2 = this.decryptBinary(h2, n3);
        i3 && console.log(this.id, `${r2} decrypted (${u2.length} bytes) in ${-c2 + (c2 = Date.now())}ms`);
        const m2 = s3 ? Fl.inflate(u2) : u2;
        return i3 && s3 && console.log(this.id, `${r2} inflated (${m2.length} bytes) in ${-c2 + (c2 = Date.now())}ms`), o3 ? JSON.parse(new TextDecoder().decode(m2)) : m2;
      }
      async fetchOffline(t3, e3, s3) {
        const n3 = ++fc;
        return new Promise((i3, o3) => {
          const r2 = Al ? "addListener" : "addEventListener", a3 = Al ? "removeListener" : "removeEventListener";
          pc.postMessage({ job: n3, cmd: "getOfflineFile", url: t3, id: this.id, what: e3, debug: s3, offline: ec.offline });
          const l3 = (t4) => {
            if (n3 !== t4.data.job) return;
            const { ok: s4, status: r3, statusText: c2, body: d2, bytes: h2 } = t4.data;
            Zt.addNetworkTraffic(`${e3}_out`, h2), pc[a3]("message", l3), s4 ? i3({ arrayBuffer: () => d2 }) : o3(Error(`${r3}: ${c2}`));
          };
          try {
            pc[r2]("message", l3);
          } catch (t4) {
            console.log("failed to add listener", t4);
          }
        });
      }
      async uploadEncrypted(t3) {
        let { content: e3, path: s3, key: n3, gzip: i3, keep: o3, debug: r2, what: a3 } = t3;
        const l3 = "string" == typeof e3 ? new TextEncoder().encode(e3).buffer : e3, c2 = o3 ? void 0 : [l3], d2 = "string" == typeof n3 ? n3 : Qi.stringify(n3), { apiKey: h2, appId: u2, persistentId: m2 } = this.sessionSpec, p2 = ++fc;
        return new Promise((t4, e4) => {
          const n4 = Al ? "addListener" : "addEventListener", o4 = Al ? "removeListener" : "removeEventListener";
          pc.postMessage({ job: p2, cmd: "uploadEncrypted", server: this.uploadServer(h2), path: s3, buffer: l3, keyBase64: d2, gzip: i3, referrer: Qt.referrerURL(), id: this.id, appId: u2, persistentId: m2, CROQUET_VERSION: Bl, debug: r2, what: a3, offline: ec.offline }, c2);
          const f2 = (s4) => {
            if (p2 !== s4.data.job) return;
            const { url: n5, ok: i4, status: r3, statusText: l4, bytes: c3 } = s4.data;
            Zt.addNetworkTraffic(`${a3}_out`, c3), pc[o4]("message", f2), i4 ? t4(n5) : e4(Error(`${r3}: ${l4}`));
          };
          try {
            pc[n4]("message", f2);
          } catch (t5) {
            console.log("failed to add listener", t5);
          }
        });
      }
      persistentPath(t3) {
        const { appId: e3, persistentId: s3 } = this.sessionSpec;
        return `apps/${e3}/${s3}/save/${t3}`;
      }
      pollForPersist(t3, e3, s3, n3, i3) {
        if (!this.synced) return;
        if (!this.sessionSpec.appId) throw Error("Persistence API requires appId");
        if (ec.offline) return;
        const o3 = { viewId: this.viewId, hash: n3, ms: i3 + 1e-3 * Math.random() }, r2 = { persistTime: e3, persistentHash: n3, persistentString: s3 };
        ec.snapshot && console.log(this.id, `sending persistence vote for time @${e3}`, o3), this.sendTutti({ time: t3, topic: "persist", data: o3, localContext: r2, tallyTarget: ["handlePersistVote"] });
      }
      async handlePersistVote(t3) {
        const { tally: e3, localContext: s3 } = t3;
        if (ec.snapshot) {
          const t4 = !!s3 ? `for time @${s3.persistTime}` : "that we didn't participate in";
          console.log(this.id, `received persistence vote ${t4}`, e3);
        }
        const { numberOfGroups: n3, shouldUpload: i3, dissidentFlag: o3 } = this.analyzeTally(e3, "ms");
        if (n3 > 1 && console.warn(this.id, `Persistence records fall into ${n3} groups`), !i3 || !s3) return;
        const { persistTime: r2, persistentHash: a3, persistentString: l3 } = s3;
        this.doPersist(r2, l3, a3, o3);
      }
      async doPersist(t3, e3, s3, n3) {
        const i3 = await this.uploadEncrypted({ path: this.persistentPath(s3), content: e3, key: this.key, gzip: true, debug: ec.snapshot, what: "persistence" });
        if (ec.snapshot) {
          const t4 = n3 ? ` (as dissident; ${JSON.stringify(n3)})` : "";
          console.log(this.id, `sending persistent data url to ${lc}${t4}: ${i3}`);
        }
        try {
          this.connection.send(JSON.stringify({ id: this.id, action: "SAVE", args: { persistTime: t3, url: i3, dissident: n3 } }));
        } catch (t4) {
          console.error("ERROR while sending", t4);
        }
      }
      async forcePersist(t3, e3, s3) {
        this.didForcePersist ? console.warn(this.id, "forcePersist called more than once, ignoring") : (console.warn(this.id, `forcePersist, will upload ${e3.length} bytes`), "alert" === m.forcePersist && confirm("forcePersist triggered. Do it?"), await this.doPersist(t3, e3, s3), console.warn(this.id, "forcePersist completed"), this.didForcePersist = true);
      }
      convertReflectorMessage(t3) {
        let e3 = "noop", s3 = [];
        switch (t3[2].what) {
          case "users": {
            const { joined: n4, left: i3, active: o3, total: r2 } = t3[2];
            this.users = o3, this.usersTotal = r2;
            const a3 = "__VM__", l3 = "__peers__", c2 = { entered: n4 || [], exited: i3 || [], count: o3, total: r2 };
            for (const t4 of c2.entered.concat(c2.exited)) t4.data && (t4.data = this.decryptPayload(t4.data));
            e3 = "publishFromModelOnly", s3 = [a3, l3, c2], Ot.handleEvent(this.viewId + ":__views__", c2.count);
            break;
          }
          case "tally": {
            const { tuttiSeq: n4, tuttiKey: i3, tally: o3, tallyTarget: r2, missingClients: a3 } = t3[2];
            (ec.messages || ec.snapshot) && a3 && console.log(`${a3} ${1 === a3 ? "client" : "clients"} failed to participate in tally ${i3 || n4}`), e3 = "handleTuttiResult", s3 = [{ tuttiSeq: n4, tuttiKey: i3, tally: o3, tallyTarget: r2 }];
            break;
          }
          case "audit": {
            const n4 = t3[0];
            ec.messages && console.log(`audit request at time ${n4}`), e3 = "handleAuditRequest", s3 = [{ time: n4 }];
            break;
          }
        }
        const n3 = new dd(0, 0, "_", e3, s3);
        t3[2] = n3.asState()[2];
      }
      handleTuttiResult(t3) {
        const { tuttiSeq: e3, tuttiKey: s3, tally: n3, tallyTarget: i3 } = t3, o3 = s3 ? (t4) => t4.tuttiKey === s3 : (t4) => t4.dummyTuttiSeq === e3, r2 = this.tuttiHistory.findIndex(o3), a3 = -1 !== r2 && this.tuttiHistory.splice(r2, 1)[0];
        let l3 = null, c2 = null;
        if (a3 && (l3 = a3.payload, c2 = a3.localContext), i3) {
          const [t4, ...e4] = i3, s4 = [...e4, { tally: n3, localPayload: l3, localContext: c2 }], o4 = new dd(0, 0, "_", t4, s4);
          this.vm.verifyExternal(o4), o4.executeOn(this.vm, true);
        }
      }
      handleAuditRequest(t3) {
        const { time: e3 } = t3;
        this.vm.time !== e3 && console.error(`time ${this.vm.time} cf audit time ${e3}`);
        const { auditStats: s3 } = this, { lastUsers: n3, minUsers: i3, maxUsers: o3, payloadTally: r2, sessionTimeAtDispatch: a3 } = s3;
        if (s3.payloadTally = 0, this.vm.time > a3 && (s3.minUsers = s3.maxUsers = n3), !this.fastForwardHandler) {
          const t4 = Zt.networkTraffic.audit_reflector_in || 0, s4 = Zt.networkTraffic.audit_reflector_out || 0;
          Zt.resetAuditStats();
          const { clientId: a4 } = this.connection.socket;
          queueMicrotask(() => {
            ec.session && console.log(this.id, `handling audit request at ${e3} after ${t4} bytes in, ${s4} out`);
            const l3 = encodeURIComponent(JSON.stringify({ time: e3, clientId: a4, lastUsers: n3, minUsers: i3, maxUsers: o3, payloadTally: r2, bytesIn: t4, bytesOut: s4 })), c2 = `${ac}/clients/report?session=${this.id}&stats=${l3}`.replace("ws", "http");
            fetch(c2, { mode: "no-cors" });
          });
        }
      }
      handleUserTotalForAccounting(t3) {
        if (rc) {
          const { auditStats: e3 } = this;
          if (e3.lastUsers = t3, this.vm.time <= e3.sessionTimeAtDispatch) return;
          (-1 === e3.minUsers || t3 < e3.minUsers) && (e3.minUsers = t3), t3 > e3.maxUsers && (e3.maxUsers = t3);
        }
      }
      messageSizeForAccounting(t3) {
        let e3 = "string" == typeof t3[2] ? t3[2].length : t3[2]._size || 0;
        return e3 += 16, e3;
      }
      async receive(t3, e3) {
        var _a3;
        const s3 = this.lastReceived;
        switch (this.lastReceived = this.connection.lastReceived, t3) {
          case "SYNC": {
            this.syncReceived = true, this.clearSyncReceiptTimeout(), bc.add(this);
            const { progressReporter: t4 } = this.sessionSpec, s4 = t4 || (() => {
            }), { messages: n3, url: i3, persisted: o3, time: r2, seq: a3, snapshotSeq: l3, tove: c2, reflector: d2, flags: h2, auditStatsInitializer: u2 } = e3;
            if (c2 && c2 !== this.tove) try {
              if (this.decrypt(c2) !== this.id) throw Error("wrong sessionId in tove?!");
            } catch (t5) {
              return this.connection.closeConnectionWithError("SYNC", Error(`session password check: ${t5.message}`), 4200), void s4(-1);
            }
            const m2 = e3.timeline;
            this.flags = h2 || {};
            const p2 = o3 ? "persistence" : "snapshot";
            ec.session && console.log(this.id, `received SYNC from ${d2} ${lc}: time ${r2}, ${n3.length} messages, ${p2} ${i3 || "<none>"}`);
            let f2 = !!this.vm;
            if (f2) {
              this.networkQueue.length = 0;
              const t5 = !!m2 && m2 === this.timeline, e4 = n3[0], s5 = a3, i4 = void 0 !== l3 ? l3 : e4 ? e4[1] : s5;
              ec.messages && console.log(this.id, `rejoin: we have #${this.vm.seq} SYNC has #${i4}-#${s5}`);
              let o4 = t5 && cd(i4, this.vm.seq) && cd(this.vm.seq, s5) && r2 >= this.reflectorTime;
              if (o4) {
                let t6 = 0;
                e4 && cd(e4[1], this.vm.seq) && (t6 = this.vm.seq - e4[1] + 1 >>> 0);
                for (let e5 = t6; o4 && e5 < n3.length; e5++) {
                  const t7 = n3[e5][2];
                  "string" != typeof t7 && "users" === t7.what && t7.left && t7.left.includes(this.viewId) && (ec.session && console.log(this.id, `${lc} reports that this view has left`), o4 = false);
                }
                o4 && t6 && (ec.messages && console.log(this.id, `rejoin: discarding ${t6} messages #${e4[1]}-#${this.vm.seq}`), n3.splice(0, t6));
              }
              if (o4) {
                if (this.sendBuffer.length > 0) {
                  const t6 = this.sendBuffer;
                  this.sendBuffer = [], ec.session && console.log(this.id, `rejoin: sending ${t6.length} messages buffered while disconnected`);
                  for (const e5 of t6) e5();
                }
              } else ec.session && console.log(this.id, "cannot rejoin seamlessly; rebooting model/view"), this.leave(true), f2 = false;
            }
            const b2 = this.networkQueue;
            this.networkQueue = [];
            for (const t5 of n3) {
              const e4 = this.messageSizeForAccounting(t5);
              if ("string" != typeof t5[2]) this.convertReflectorMessage(t5);
              else try {
                t5[2] = this.decryptPayload(t5[2])[0];
              } catch (t6) {
                return this.connection.closeConnectionWithError("SYNC", Error(`session password decrypt: ${t6.message}`), 4200), void s4(-1);
              }
              ec.messages && console.log(this.id, "received in SYNC " + JSON.stringify(t5)), this.networkQueue.push([t5, e4]);
            }
            if (this.networkQueue.push(...b2), r2 > this.reflectorTime && this.timeFromReflector(r2, "reflector"), f2) return ec.session && console.log(this.id, "seamless rejoin successful"), void (this.syncCompleted = true);
            let y2;
            if (this.timeline = m2 || "", ec.snapshot && i3 && console.log(this.id, `fetching ${p2} ${i3}`), i3) try {
              y2 = await this.downloadEncrypted({ url: i3, gzip: true, key: this.key, debug: ec.snapshot, json: true, what: p2 });
            } catch (t5) {
              return this.connection.closeConnectionWithError("SYNC", Error(`failed to fetch ${p2}: ${t5.message}`), 4200), void s4(-1);
            }
            if (!this.connected) return console.log(this.id, "disconnected during SYNC"), void s4(-1);
            if (o3) {
              if (this.migratingOldSnapshot) throw Error("hashOverride is enabled but got persisted data instead of snapshot");
              this.install(y2);
            } else y2 && (this.sessionSpec.snapshot = y2), this.install();
            u2 && (ec.session && console.log(this.id, `installing audit stats: ${JSON.stringify(u2)}`), this.auditStats = u2), ec.session && console.log(this.id, `fast-forwarding from ${Math.round(this.vm.time)} to at least ${r2}`);
            const g2 = this.vm.time, w2 = await new Promise((t5) => {
              const { port1: e4, port2: n4 } = new MessageChannel();
              e4.onmessage = () => {
                let e5 = true;
                if (this.vm) if (this.vm.time === this.reflectorTime) this.viewId in this.vm.views && (s4(1), t5(true), e5 = false);
                else {
                  const t6 = (this.vm.time - g2) / (this.reflectorTime - g2);
                  s4(t6);
                }
                else ec.session && console.log(this.id, "disconnected during SYNC fast-forwarding"), s4(-1), t5(false), e5 = false;
                e5 && this.stepSession("fastForward", { budget: dc });
              };
              this.fastForwardHandler = (e5) => {
                this.connected && this.vm ? "error" === e5 ? (s4(-1), t5(false)) : n4.postMessage("tick") : (console.log(this.id, "disconnected during SYNC fast-forwarding"), s4(-1), t5(false));
              }, queueMicrotask(() => this.stepSession("fastForward", { budget: dc }));
            });
            return delete this.fastForwardHandler, void (w2 && (ec.session && console.log(this.id, `fast-forwarded to ${Math.round(this.vm.time)}`), this.vm.diverged && Qt.showMessage(`${Qt.libName}: session had diverged. Try CROQUETVM.debugDiverged()`, { level: "warning", only: "once" }), this.sessionSpec.sessionJoined()));
          }
          case "RECV": {
            const t4 = e3;
            t4[1] >>>= 0;
            const s4 = this.messageSizeForAccounting(t4);
            if ("string" != typeof t4[2]) ec.messages && console.log(this.id, "received META " + JSON.stringify(t4)), this.convertReflectorMessage(t4), ec.messages && console.log(this.id, "converted to " + JSON.stringify(t4));
            else try {
              const [e4, s5, n4] = this.decryptPayload(t4[2]);
              t4[2] = e4, s5 === this.viewId && this.addToStatistics(n4, this.lastReceived), ec.messages && console.log(this.id, "received " + JSON.stringify(t4));
            } catch (t5) {
              return void this.connection.closeConnectionWithError("RECV", Error(`session password decrypt: ${t5.message}`), 4200);
            }
            let n3;
            return this.networkQueue.push([t4, s4]), this.flags.rawtime && (n3 = t4[t4.length - 1]), this.timeFromReflector(t4[0], "reflector", n3), void (this.simulateIfNeeded && queueMicrotask(() => this.simulateIfNeeded()));
          }
          case "TICK": {
            if (!this.vm) return;
            const t4 = "number" == typeof e3 ? e3 : e3.time;
            if (ec.ticks) {
              const e4 = s3 && this.lastReceived - s3 - this.msPerTick * this.tickMultiplier | 0, n3 = t4 - this.vm.time;
              console.log(this.id, `received TICK ${t4} ${Math.abs(e4) < 5 ? "on time" : e4 < 0 ? "early" : "late"} (${n3} ms, jitter ${e4 > 0 ? "+" : ""}${e4} ms)`);
            }
            return this.timeFromReflector(t4, "reflector"), this.tickMultiplier > 1 && this.multiplyTick(t4), void (this.simulateIfNeeded && queueMicrotask(() => this.simulateIfNeeded()));
          }
          case "INFO": {
            const { msg: t4, options: s4 } = e3, n3 = rc ? "Multisynq Synchronizer" : "Croquet Reflector";
            return void Qt.showMessage(`${n3}: ${t4}`, s4);
          }
          case "REQU":
            return ec.snapshot && console.log(`received REQU (snapshot request) from ${lc}`), void (this.reflectorNeedsSnapshot = true);
          case "RECONNECT":
            (_a3 = this.connection.socket) == null ? void 0 : _a3.synchronizerDisconnected(4003, "told to reconnect");
            break;
          default:
            console.warn("Unknown action:", t3, e3);
        }
      }
      install(t3) {
        const e3 = Date.now(), { snapshot: s3, initFn: n3, options: i3, debugEvents: o3 } = this.sessionSpec, [r2, a3] = s3.models ? ["deserializ", "snapshot"] : ["initializ", "root model"];
        ec.session && console.log(this.id, `${r2}ing ${a3}`);
        let l3 = new ad(s3, o3, () => {
          try {
            return n3(i3, t3);
          } catch (t4) {
            throw Pt("init", t4, "fatal"), t4;
          }
        }, this.migratingOldSnapshot);
        if ((ec.session || ec.snapshot && s3.models) && console.log(this.id, `${a3} ${r2}ed in ${Date.now() - e3}ms`), ec.initsnapshot && !s3.models) {
          ec.snapshot && console.log(this.id, "exercising snapshot and restore after init()");
          let t4 = null;
          try {
            t4 = JSON.stringify(l3.snapshot());
          } catch (t5) {
            throw Pt("initial snapshot", t5, "fatal"), t5;
          }
          try {
            l3 = new ad(JSON.parse(t4), o3, () => n3(i3));
          } catch (t5) {
            throw Pt("initial snapshot resume", t5, "fatal"), t5;
          }
        }
        const c2 = this.lastKnownTime(l3);
        this.reflectorTime = Math.max(this.reflectorTime, c2), this.setVM(l3);
      }
      setVM(t3) {
        this.vm = t3, this.vm.controller = this;
      }
      sendJoin() {
        this.syncReceived = false, this.syncCompleted = false, delete this.fastForwardHandler, this.rejoinTimeout && (clearTimeout(this.rejoinTimeout), this.rejoinTimeout = 0), ec.session && console.log(this.id, "Controller sending JOIN");
        const { tick: t3, delay: e3 } = this.getTickAndMultiplier(), { name: s3, codeHash: n3, appId: i3, apiKey: o3, persistentId: r2, developerId: a3, heraldUrl: l3, rejoinLimit: c2, autoSleep: d2, computedCodeHash: h2, location: u2, flags: m2 } = this.sessionSpec, p2 = rc ? "hiddenName" : s3, f2 = rc ? "hiddenApiKey" : this.getBackend(o3).apiKey, b2 = rc ? "hiddenAppId" : i3, y2 = rc ? "hiddenUrl" : Qt.referrerURL(), g2 = this.viewDataEncrypted ? { id: this.viewId, data: this.viewDataEncrypted } : u2 ? [this.viewId] : this.viewId, w2 = { name: p2, apiKey: f2, appId: b2, url: y2, persistentId: r2, sdk: Bl, developerId: a3, version: 1, user: g2, location: u2, ticks: { tick: t3, delay: e3 }, dormantDelay: d2, tove: this.tove, codeHash: n3 };
        l3 && Object.assign(w2, { heraldUrl: l3 }), c2 && Object.assign(w2, { leaveDelay: c2 + 250 }), h2 !== n3 && Object.assign(w2, { computedCodeHash: h2 }), m2 && Object.assign(w2, { flags: m2 }), this.connection.send(JSON.stringify({ id: this.id, action: "JOIN", args: w2 })), this.syncReceiptTimeout = setTimeout(() => {
          delete this.syncReceiptTimeout, this.syncReceived || this.connection.closeConnectionWithError("JOIN", Error("Initial reflector connection timed out"));
        }, 5e3);
      }
      clearSyncReceiptTimeout() {
        this.syncReceiptTimeout && (clearTimeout(this.syncReceiptTimeout), delete this.syncReceiptTimeout);
      }
      connectionInterrupted() {
        this.syncReceived && (this.shouldLeaveWhenDisconnected ? this.leave() : this.rejoinTimeout || (this.rejoinTimeout = setTimeout(() => {
          this.leaving ? ec.session && console.log(this.id, "abandoning rejoin; session is defunct") : (ec.session && console.log(this.id, "rejoin timed out"), this.rejoinTimeout = 0, this.leave());
        }, this.sessionSpec.rejoinLimit)));
      }
      leave() {
        let t3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        const { rebootModelView: e3 } = this.sessionSpec;
        if (this.reset(), ec.session && console.log(this.id, `resetting ${t3 ? "(but keeping)" : "and discarding"} controller`), t3 || bc.delete(this), !this.sessionSpec) throw Error("do not discard sessionSpec!");
        e3();
      }
      async encrypt(t3) {
        const e3 = V.random(16), s3 = Zo.encrypt(t3, this.key, { iv: e3 }), n3 = Lo(t3, this.key);
        return `${Qi.stringify(e3)}${Qi.stringify(n3)}${s3}`;
      }
      get deprecatedDefaultKey() {
        return mc || (mc = io("THIS SHOULDN'T BE IN LOGS", "", { keySize: 8, hasher: Ui.algo.SHA1, iterations: 1 })), mc;
      }
      decrypt(t3) {
        let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.key;
        const s3 = Qi.parse(t3.slice(0, 24)), n3 = Qi.parse(t3.slice(24, 68)), i3 = t3.slice(68), o3 = Zo.decrypt(i3, e3, { iv: s3 });
        let r2 = "";
        try {
          r2 = Ai.stringify(o3);
        } catch (t4) {
        }
        const a3 = Lo(r2, this.key);
        if (this.compareHmacs(n3.words, a3.words)) return r2;
        if (e3 !== this.deprecatedDefaultKey) return this.decrypt(t3, this.deprecatedDefaultKey);
        throw Error("Decryption error");
      }
      decryptBinary(t3, e3) {
        const s3 = new TextDecoder().decode(new Uint8Array(t3, 0, 4));
        let n3, i3, o3, r2, a3;
        switch ("string" == typeof e3 && (e3 = Qi.parse(e3)), s3) {
          case "CRQ0":
            n3 = new TextDecoder().decode(t3), i3 = Qi.parse(n3.slice(4, 28)), o3 = Qi.parse(n3.slice(28, 72)), r2 = n3.slice(72), a3 = Zo.decrypt(r2, e3, { iv: i3 });
            break;
          case "CRQ1":
            n3 = new Uint8Array(t3), i3 = V.create(n3.subarray(4, 20)), o3 = V.create(n3.subarray(20, 52)), r2 = V.create(n3.subarray(52)), a3 = Zo.decrypt({ ciphertext: r2 }, e3, { iv: i3 });
            break;
          default:
            throw Error(`${this.id} unknown encryption version ${s3}`);
        }
        a3.clamp();
        const l3 = Lo(a3, e3);
        if (this.compareHmacs(o3.words, l3.words)) return z(a3);
        if (e3 !== this.deprecatedDefaultKey) return this.decryptBinary(t3, this.deprecatedDefaultKey);
        throw Error("Decryption error");
      }
      async encryptMessage(t3, e3, s3) {
        const [n3, i3, o3] = t3.asState();
        return [n3, i3, await this.encryptPayload([o3, e3, s3])];
      }
      async encryptPayload(t3) {
        return this.encrypt(JSON.stringify(t3));
      }
      decryptPayload(t3) {
        return JSON.parse(this.decrypt(t3));
      }
      compareHmacs(t3, e3) {
        let s3 = t3.length === e3.length;
        for (let n3 = 0; n3 < t3.length; n3++) t3[n3] !== e3[n3] && (s3 = false);
        return s3;
      }
      sendMessage(t3) {
        if (this.viewOnly || !this.vm) return;
        const e3 = t3.asState()[2].length;
        if (e3 > 16384) return void console.warn(this.id, `Message with payload of ${e3} bytes exceeds maximum 16384 and will not be sent to ${lc}.`);
        !this.payloadSizeWarned && e3 > uc && (console.log(this.id, `Message with payload of ${e3} bytes being sent to ${lc}. Maximum recommended is 4096.`), this.payloadSizeWarned = true);
        const s3 = Date.now(), n3 = this.rateLimitedSendTimes, i3 = this.rateLimitBuffer;
        if (Zt.perSecondTally({ requestedMessages: 1 }), i3.length) return void this.addToRateLimitBuffer(t3);
        let o3 = 0;
        if (n3.length && this.synced) {
          const t4 = n3[n3.length - 1], e4 = 1e3 / this.eventRateLimit - (s3 - t4);
          e4 > 1 && (o3 = Math.ceil(e4));
        }
        o3 ? (this.addToRateLimitBuffer(t3), setTimeout(() => this.serviceRateLimitBuffer(), o3)) : (this.recordRateLimitedSend(s3), this.socketSendMessage(t3), Zt.perSecondTally({ sentSingleMessages: 1, sentMessagesTotal: 1, sentPayloadTotal: e3 }));
      }
      recordRateLimitedSend(t3) {
        const e3 = this.rateLimitedSendTimes;
        !this.synced && e3.length && e3[e3.length - 1] === t3 || (e3.push(t3), e3.length > this.eventHistoryLimit && e3.shift()), !this.rateLimitSoftWarned && e3.length === this.eventHistoryLimit && t3 - e3[0] < 1010 && (console.warn(this.id, `Sends to ${lc} are at or above recommended limit of ${this.eventHistoryLimit} within one second. Events will be bundled as necessary to keep to the limit.`), this.rateLimitSoftWarned = true);
      }
      addToRateLimitBuffer(t3) {
        Zt.perSecondTally({ bundledMessages: 1 });
        const e3 = Date.now(), s3 = t3.asState(), n3 = s3[2].length, i3 = this.rateLimitBuffer;
        if (i3.length) {
          const t4 = i3[i3.length - 1], { msgStates: o4, totalPayload: r2 } = t4;
          if (r2 < uc) return o4.push({ msgState: s3, bufferTime: e3 }), void (t4.totalPayload += n3);
        }
        Zt.perSecondTally({ newBundles: 1 }), i3.push({ msgStates: [{ msgState: s3, bufferTime: e3 }], totalPayload: n3 });
        const o3 = i3.length;
        ec.session && o3 % 5 == 0 && o3 !== this.rateLimitLastLogged && (console.log(this.id, `SEND rate-limit buffer grew to ${o3} event bundles (max ${this.eventMaxBundles})`), this.rateLimitLastLogged = o3), o3 > this.eventMaxBundles ? (console.error(this.id, "Disconnecting after overflow of SEND rate-limit buffer."), this.connection.closeConnectionWithError("SEND", Error("Send rate exceeded"), 4200)) : !this.rateLimitBufferWarned && o3 > this.eventMaxBundles / 2 && (console.warn(this.id, "SEND rate-limit buffer is 50% full. If send rate does not drop, the app will be disconnected."), this.rateLimitBufferWarned = true);
      }
      serviceRateLimitBuffer() {
        if (!this.connected) return;
        const t3 = this.rateLimitBuffer;
        if (!t3.length) return;
        const e3 = Date.now(), s3 = 1e3 / this.eventRateLimit, n3 = this.rateLimitedSendTimes;
        if (n3.length) {
          const t4 = n3[n3.length - 1];
          if (s3 - (e3 - t4) > 0) return;
        }
        const i3 = t3.shift(), { msgStates: o3, totalPayload: r2 } = i3, a3 = [];
        let l3 = 0;
        if (o3.forEach((t4) => {
          a3.push(t4.msgState), l3 += e3 - t4.bufferTime;
        }), 1 === a3.length) {
          const t4 = dd.fromState(a3[0], this.vm);
          this.socketSendMessage(t4);
        } else {
          const t4 = new dd(this.vm.time, 0, "_", "handleBundledEvents", [a3]);
          this.socketSendMessage(t4);
        }
        if (this.recordRateLimitedSend(e3), Zt.perSecondTally({ sentBundles: 1, sentMessagesTotal: o3.length, sendDelay: l3, sentBundlePayload: r2, sentPayloadTotal: r2 }), ec.session && this.connected) {
          const e4 = t3.length;
          e4 && e4 % 5 == 0 && e4 !== this.rateLimitLastLogged && (console.log(this.id, `SEND rate-limit buffer dropped to ${e4} event bundles`), this.rateLimitLastLogged = e4);
        }
        t3.length && setTimeout(() => this.serviceRateLimitBuffer(), s3);
      }
      async socketSendMessage(t3) {
        let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        const s3 = await this.encryptMessage(t3, this.viewId, Date.now()), n3 = ec.sends && (e3 ? `tagged SEND ${t3.asState()} with tags ${JSON.stringify(e3)}` : `SEND ${t3.asState()}`);
        if (!this.connected || !this.syncCompleted) return void (this.vm && (ec.sends && console.log(this.id, `buffering ${n3}`), this.sendBuffer.push(() => this.socketSendMessage(t3, e3))));
        ec.sends && console.log(this.id, `sending ${n3}`);
        const i3 = { id: this.id, action: "SEND", args: [...s3, this.latency] };
        e3 && (i3.tags = e3), this.lastSent = Date.now(), this.connection.send(JSON.stringify(i3));
      }
      async sendTagged(t3, e3) {
        this.viewOnly || this.socketSendMessage(t3, e3);
      }
      async sendTutti(t3) {
        let { time: s3, topic: n3, data: i3, localContext: o3 = null, firstMessage: r2 = null, wantsVote: a3 = true, tallyTarget: l3 = null } = t3;
        if (this.viewOnly) return;
        const c2 = r2 && await this.encryptMessage(r2, this.viewId, Date.now()), d2 = e2(i3);
        if (!this.connected || !this.syncCompleted) return void (this.vm && (ec.sends && console.log(this.id, `buffering "${n3}" TUTTI ${d2} ${r2 && r2.asState()}`), this.sendBuffer.push(() => this.sendTutti({ time: s3, topic: n3, data: i3, localContext: o3, firstMessage: r2, wantsVote: a3, tallyTarget: l3 }))));
        ec.sends && console.log(this.id, `sending "${n3}" TUTTI ${d2} ${r2 && r2.asState()}`), this.lastSent = Date.now();
        const h2 = `${n3}@${s3}`;
        this.connection.send(JSON.stringify({ id: this.id, action: "TUTTI", args: [s3, 0, d2, c2, a3, l3, h2] })), this.tuttiHistory.length > 100 && this.tuttiHistory.shift(), this.tuttiHistory.push({ time: s3, tuttiKey: h2, dummyTuttiSeq: 0, payload: d2, localContext: o3 });
      }
      sendLog() {
        for (var t3 = arguments.length, e3 = new Array(t3), s3 = 0; s3 < t3; s3++) e3[s3] = arguments[s3];
        this.connected && this.syncCompleted ? (ec.sends && console.log(this.id, "sending LOG"), e3.length < 2 && (e3 = e3[0]), this.connection.send(JSON.stringify({ action: "LOG", args: e3 }))) : this.vm && (ec.sends && console.log(this.id, "buffering LOG"), this.sendBuffer.push(() => this.sendLog(...e3)));
      }
      addToStatistics(t3, e3) {
        this.latency = e3 - t3, this.latencyHistory && (this.latencyHistory.length >= 100 && this.latencyHistory.shift(), this.latencyHistory.push({ time: e3, ms: this.latency }));
      }
      get latencies() {
        return this.latencyHistory || (this.latencyHistory = []), this.latencyHistory;
      }
      getTickAndMultiplier() {
        const t3 = this.sessionSpec.options, e3 = ["number", "string"].includes(typeof t3.tps) ? t3.tps : ["number", "string"].includes(typeof this.sessionSpec.tps) ? this.sessionSpec.tps : 20, [s3, n3] = (e3 + "x").split("x").map((t4) => Number.parseFloat("0" + t4)), i3 = 1e3 / Math.max(1 / 30, Math.min(60, s3)), o3 = Math.max(1, n3);
        let r2 = i3, a3 = 0;
        return o3 > 1 && !cc && (r2 = i3 / o3, a3 = Math.ceil(r2 * (o3 - 1))), { msPerTick: r2, multiplier: o3, tick: i3, delay: a3 };
      }
      simulate(t3) {
        if (!this.vm) return true;
        try {
          let e3 = true;
          if (this.networkQueue.length + this.vm.messages.size === 0) e3 = this.vm.advanceTo(this.reflectorTime, t3);
          else {
            const s4 = Zt.begin("simulate");
            for (; e3; ) {
              const s5 = this.networkQueue[0];
              if (!s5) break;
              const [n4, i4] = s5;
              if (e3 = this.vm.advanceTo(n4[0], t3), !e3) break;
              this.networkQueue.shift(), rc && (this.auditStats.payloadTally += i4);
              const o3 = this.vm.scheduleExternalMessage(n4);
              e3 = this.vm.advanceTo(o3.time, t3), this.cpuTime += 5;
            }
            e3 && (e3 = this.vm.advanceTo(this.reflectorTime, t3)), this.cpuTime += Math.max(0.01, Zt.end("simulate") - s4);
          }
          Zt.backlog(this.backlog);
          const s3 = this.lag, n3 = Math.max(200, 0.1 * this.msPerTick), i3 = Math.max(2e3, 0.2 * this.msPerTick);
          if ("boolean" == typeof this.synced && this.viewed && (this.synced && s3 > i3 || !this.synced && s3 < n3)) {
            !this.synced ? this.syncTimer || (this.syncTimer = setTimeout(() => {
              delete this.syncTimer, this.connected && this.lag < n3 && this.applySyncChange(true);
            }, 200)) : this.applySyncChange(false);
          }
          if (!ec.offline) if (this.synced && e3 && this.vm.time - this.lastSnapshotRequest > 5e3) {
            let t4 = false;
            this.cpuTime > 5e3 ? (ec.snapshot && console.log(this.id, `due for snapshot: cpuTime is ${Math.round(this.cpuTime)}ms`), t4 = true) : rc && this.vm.time - this.vm.lastSnapshotPoll > 3e5 && (ec.snapshot && console.log(this.id, `due for snapshot: time since last is ${this.vm.time - this.vm.lastSnapshotPoll}ms`), t4 = true), t4 && (this.lastSnapshotRequest = this.vm.time, this.triggeringCpuTime = this.cpuTime, this.cpuTime = 0, this.isBeingAnimated() ? setTimeout(() => this.scheduleSnapshot(), Math.floor(2e3 * Math.random())) : this.scheduleSnapshot());
          } else this.reflectorNeedsSnapshot && (this.triggeringCpuTime = this.synced ? this.cpuTime : 12345, this.scheduleSnapshot(true), this.reflectorNeedsSnapshot = false);
          return e3;
        } catch (t4) {
          return Pt("simulate", t4), this.connection.closeConnectionWithError("simulate", t4), "error";
        }
      }
      stepSession(t3) {
        let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        const s3 = Zt.stepSession(e3.frameTime, true);
        s3 && console.log(s3);
        const { backlog: n3, latency: i3, starvation: o3, activity: r2 } = this;
        if ("animation" === t3) {
          Zt.animationFrame(e3.frameTime, { backlog: n3, starvation: o3, latency: i3, activity: r2, users: this.users });
          const t4 = Date.now();
          if (this.lastAnimationEnd) {
            const e4 = t4 - this.lastAnimationEnd;
            if (true === this.animationGapCheck && e4 > 200 && (this.animationGapCheck = [], ec.session && console.log(this.id, "animation has stopped (too long between steps)")), true !== this.animationGapCheck) {
              const t5 = this.animationGapCheck;
              t5.push(e4), t5.length > 4 && t5.shift(), 4 === t5.length && t5.reduce((t6, e5) => t6 + e5, 0) <= 400 && (this.animationGapCheck = true, ec.session && console.log(this.id, "animation has started"));
            }
          }
          this.lastAnimationEnd = t4;
        }
        if (!this.connected) return void (this.isInBackground() || this.checkForConnection(true));
        if (!this.vm) return;
        let a3;
        switch (t3) {
          case "animation": {
            const t4 = e3.expectedSimFPS, s4 = Date.now(), n4 = hc.reduce((t5, e4) => t5 + e4, 0) / hc.length;
            if (a3 = this.simulate(s4 + Math.min(n4, dc)), false === a3) {
              const e4 = 0 === t4 ? 0 : 1e3 / t4 * 4;
              this.backlog > e4 && (a3 = this.simulate(s4 + dc - n4));
            }
            "error" !== a3 && (hc.push(Date.now() - s4), hc.length > 4 && hc.shift());
            break;
          }
          case "fastForward":
          case "background":
            a3 = this.simulate(Date.now() + e3.budget);
            break;
          default:
            console.warn(t3);
        }
        this.fastForwardHandler && this.fastForwardHandler(a3), "error" !== a3 && (Zt.begin("update"), this.processModelViewEvents("animation" === t3), Zt.end("update"), this.vm && (this.serviceRateLimitBuffer(), "animation" === t3 && (e3.view && (Zt.begin("render"), this.inViewRealm(() => e3.view.update(e3.frameTime)), Zt.end("render")), this.lastAnimationEnd = Date.now())));
      }
      applySyncChange(t3) {
        ec.session && console.log(this.id, `synced=${t3}`), this.synced = t3, Qt.showSyncWait(!t3), this.vm.publishFromView(this.viewId, "synced", t3);
      }
      inViewRealm(t3) {
        return se(this.vm, () => t3(this.vm));
      }
      processModelViewEvents(t3) {
        return this.vm ? this.vm.processModelViewEvents(t3) : 0;
      }
      timeFromReflector(t3, e3, s3) {
        t3 < this.reflectorTime ? ("controller" !== e3 || ec.ticks) && console.warn(`time is ${this.reflectorTime}, ignoring time ${t3} from ${e3}`) : ("boolean" != typeof this.synced && (this.synced = false), this.reflectorTime = t3, this.extrapolatedTimeBase = Date.now() - t3, this.vm && Zt.backlog(this.backlog), this.tickHook && this.tickHook(t3, s3));
      }
      multiplyTick(t3) {
        this.localTicker && globalThis.clearInterval(this.localTicker);
        const e3 = this.msPerTick, s3 = this.tickMultiplier;
        let n3 = 1;
        this.localTicker = globalThis.setInterval(() => {
          this.timeFromReflector(Math.round(t3 + n3 * e3), "controller"), ec.ticks && console.log(this.id, "Controller generate TICK " + this.reflectorTime, n3), ++n3 >= s3 && (globalThis.clearInterval(this.localTicker), this.localTicker = 0);
        }, e3);
      }
      startStepping(t3) {
        const e3 = (s3) => {
          this.leaving || (this.isOutOfSight() || t3(s3), window.requestAnimationFrame(e3));
        };
        window.requestAnimationFrame(e3);
      }
      setUpActivityChecks() {
        let t3 = null;
        if (this.isOutOfSight = () => !(Al || "hidden" !== document.visibilityState && t3), this.isBeingAnimated = () => {
          const t4 = true === this.animationGapCheck, e4 = Date.now() - this.lastAnimationEnd < 200;
          return t4 && !e4 && (this.animationGapCheck = [], ec.session && console.log(this.id, "animation has stopped (too long since last step)")), t4 && e4;
        }, this.isInBackground = () => this.isOutOfSight() || !this.isBeingAnimated(), !Al) {
          new IntersectionObserver((e4, s4) => t3 = e4[0].isIntersecting).observe(document.body);
        }
        const e3 = this.sessionSpec.autoSleep;
        let s3;
        if (e3) {
          const t4 = 1e3 * e3;
          let n4 = 0, i4 = 0;
          s3 = () => {
            const e4 = Date.now();
            e4 - n4 < 980 || (n4 = e4, this.isOutOfSight() ? i4 ? e4 - i4 > t4 && (this.dormantDisconnect(), i4 = 0) : i4 = e4 : i4 = 0);
          };
        }
        const n3 = () => {
          this.leaving ? i3 && (clearInterval(i3), i3 = null) : this.connected && this.vm && (s3 && s3(), this.isBeingAnimated() || this.connection.keepAlive(Date.now()));
        };
        let i3 = setInterval(n3, 1e3);
        this.simulateIfNeeded = () => {
          if (!this.isBeingAnimated() && (n3(), !this.fastForwardHandler && this.connected)) {
            let t4 = 0.9 * this.msPerTick;
            e3 && (t4 = Math.min(t4, dc));
            const s4 = this.synced ? "background" : "fastForward";
            this.stepSession(s4, { budget: t4 });
          }
        };
      }
      toString() {
        return `Controller[${this.id}]`;
      }
      [Symbol.toPrimitive]() {
        return this.toString();
      }
    };
    var wc = class {
      constructor(t3) {
        this.controller = t3, this.socketLastSent = 0, this.connectBlocked = false, this.connectRestricted = false, this.connectHasBeenCalled = false, this.reconnectDelay = 0, this.missingTickThreshold = 1 / 0;
      }
      get id() {
        return this.controller.id;
      }
      setTick(t3) {
        this.missingTickThreshold = Math.min(3 * t3, 45e3);
      }
      get connected() {
        return !(!this.socket || !this.socket.isConnected());
      }
      checkForConnection(t3) {
        this.socket || this.connectHasBeenCalled || this.connectBlocked || this.connectRestricted && !t3 || this.connectToReflector();
      }
      connectToReflector() {
        if (this.socket || this.connectHasBeenCalled) return;
        let t3;
        this.connectHasBeenCalled = true, this.connectBlocked = false, this.connectRestricted = false;
        const e3 = () => {
          ec.session && console.log(this.id, this.socket.constructor.name, "connected to", this.socket.url), this.reconnectDelay = 0, Zt.connected(true), this.controller.sendJoin();
        };
        if (ec.offline) t3 = new El(), t3.isConnected = () => t3.readyState === WebSocket.OPEN;
        else if (rc) {
          const { synchSpec: s3, developSpec: n3 } = m;
          if (s3 && n3) throw Error("Cannot handle both synchSpec and developSpec options");
          let i3 = "";
          const o3 = s3 || n3;
          o3 && (i3 += `&synch=${encodeURIComponent(o3)}`);
          const r2 = this.id, { persistentId: a3, appId: l3, developerId: c2 } = this.controller.sessionSpec;
          t3 = new Ql(`${ac}/clients/connect?session=${r2}&persist=${a3}&app=${encodeURIComponent(l3)}&developer=${c2}${i3}`), t3.isConnected = () => {
            var _a3;
            return "open" === ((_a3 = t3.dataChannel) == null ? void 0 : _a3.readyState);
          }, t3.onconnected = e3;
        } else {
          let e4 = this.controller.getBackend(this.controller.sessionSpec.apiKey).reflector;
          const s3 = Al ? void 0 : window.location.href, n3 = {}, i3 = this.controller.sessionSpec.token;
          if (i3 && (n3.token = i3), m.reflector) {
            const t4 = m.reflector.toUpperCase();
            "CF" === t4 || t4.match(/^[A-Z]{3}$/) ? (e4 = ec.reflector ? "wss://croquet.network/reflector/dev/" : "wss://croquet.network/reflector/", 3 === t4.length && (n3.colo = t4)) : m.reflector.match(/^[-a-z0-9]+$/i) ? n3.region = m.reflector : e4 = new URL(m.reflector, s3).href.replace(/^http/, "ws");
          }
          if (!e4.match(/^wss?:/)) throw Error("Cannot interpret reflector address " + e4);
          e4.endsWith("/") || (e4 += "/");
          const o3 = new URL(e4 + this.id, s3);
          for (const [t4, e5] of Object.entries(n3)) o3.searchParams.append(t4, e5);
          t3 = new WebSocket(o3), t3.isConnected = () => t3.readyState === WebSocket.OPEN;
        }
        t3.onopen = (s3) => {
          const n3 = this.socket;
          n3 && (n3.onopen = n3.onmessage = n3.onerror = n3.onclose = null), this.socket = t3, this.connectHasBeenCalled = false, t3.twoStageConnection || e3();
        }, t3.onmessage = (e4) => {
          if (t3 !== this.socket) return;
          const { data: s3 } = e4, n3 = "_CHUNK";
          if (s3.startsWith(n3)) {
            const e5 = "1" === s3.charAt(6), n4 = "1" === s3.charAt(7), i3 = s3.slice(8);
            if (e5 && (t3.chunkCollector = []), t3.chunkCollector.push(i3), n4) {
              const e6 = "".concat(...t3.chunkCollector);
              t3.chunkCollector = [], Zt.addNetworkTraffic("reflector_in", e6.length, !!rc), this.receive(e6);
            }
          } else Zt.addNetworkTraffic("reflector_in", s3.length, !!rc), this.receive(s3);
        }, t3.onerror = (e4) => {
          ec.session && console.log(this.id, t3.constructor.name, "connection error"), this.connectHasBeenCalled = false, this.controller.clearSyncReceiptTimeout();
        }, t3.onclose = (e4) => {
          this.socket && t3 !== this.socket || this.socketClosed(e4.code, e4.reason);
        };
      }
      socketClosed(t3, e3) {
        ec.session && console.log(this.id, `socketClosed with code=${t3} message="${e3}"`), t3 >= 4100 && 4110 !== t3 && (ec.session && console.warn("resuming this session will require a new Session.join()"), this.controller.leaving || (this.controller.leaving = () => {
        }), this.reconnectDelay = 0);
        const s3 = !!!this.controller.leaving && 1e3 !== t3 && t3 < 4100, n3 = 4110 === t3;
        n3 || 1e3 === t3 || this.reconnectDelay || setTimeout(() => {
          var _a3, _b;
          if (this.connected || ((_b = (_a3 = this.socket) == null ? void 0 : _a3.isConnecting) == null ? void 0 : _b.call(_a3))) return;
          const n4 = s3 ? "Reconnecting" : "Connection closed";
          Qt.showMessage(`${n4}: ${t3} ${e3}`, { level: s3 ? "warning" : "fatal" });
        }, 500), ec.session && console.log(this.id, `${this.socket ? this.socket.constructor.name + " closed" : "closed before opening,"} with code: ${t3} ${e3}`), this.connectHasBeenCalled = false, this.controller.clearSyncReceiptTimeout(), Zt.connected(false), Zt.resetAuditStats(), n3 ? this.connectRestricted = true : this.connectBlocked = true, this.disconnected(), s3 && (ec.session && console.log(this.id, `reconnecting in ${this.reconnectDelay} ms`), this.reconnectTimeout = globalThis.setTimeout(() => {
          delete this.reconnectTimeout, this.connectToReflector();
        }, this.reconnectDelay), this.reconnectDelay = Math.min(3e4, Math.round((this.reconnectDelay + 100) * (1 + Math.random()))));
      }
      disconnected() {
        this.socket && (this.socket = null, this.lastReceived = 0, this.socketLastSent = 0, this.stalledSince = 0, this.connectHasBeenCalled = false, this.controller.connectionInterrupted());
      }
      send(t3) {
        this.socketLastSent = Date.now(), this.socket.send(t3), Zt.addNetworkTraffic("reflector_out", t3.length, !!rc);
      }
      receive(t3) {
        this.lastReceived = Date.now();
        const { id: e3, action: s3, args: n3 } = JSON.parse(t3);
        if (e3) try {
          this.controller.receive(s3, n3);
        } catch (t4) {
          this.closeConnectionWithError("receive", t4);
        }
        else if ("PONG" === s3) {
          if (ec.pong && console.log("PONG after", Date.now() - n3, "ms"), this.pongHook) try {
            this.pongHook(n3);
          } catch (t4) {
            console.error(t4);
          }
        } else console.warn("Unknown action", s3);
      }
      dormantDisconnect() {
        this.connected && (ec.session && console.log(this.id, `dormant; disconnecting from ${lc}`), this.closeConnection(4110, "Going dormant"));
      }
      closeConnectionWithError(t3, e3) {
        let s3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 4e3;
        console.error(s3, e3), this.closeConnection(s3, `Error in ${t3}: ${e3.message || e3}`);
      }
      closeConnection(t3, e3) {
        if (this.socket) {
          this.socket.onclose = null;
          try {
            this.socket.close(t3, e3);
          } catch (s3) {
            console.error(`Error in socket.close(${t3}, ${JSON.stringify(e3)}):`, s3);
          }
        }
        this.socketClosed(t3, e3);
      }
      PULSE(t3) {
        this.connected && (0 === this.socket.bufferedAmount ? (this.send(JSON.stringify({ action: "PULSE" })), this.stalledSince = 0) : this.stalledSince && t3 - this.stalledSince > 500 ? console.log(this.id, `Reflector connection stalled: ${this.socket.bufferedAmount} bytes unsent for ${t3 - this.stalledSince} ms`) : this.stalledSince = Date.now());
      }
      keepAlive(t3) {
        0 !== this.lastReceived && (t3 - this.socketLastSent > 25e3 ? this.PULSE(t3) : t3 - this.lastReceived > 5e4 ? this.closeConnectionWithError("connection", Error((rc ? "Synchronizer" : "Reflector") + " has gone away")) : t3 - this.lastReceived > this.missingTickThreshold && this.PULSE(t3));
      }
      PING() {
        let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Date.now();
        this.connected && this.send(JSON.stringify({ action: "PING", args: t3 }));
      }
    };
    globalThis.setInterval(() => {
      for (const t3 of bc) t3.connected && t3.vm && t3.connection.keepAlive(Date.now());
    }, 100);
    var Zc = Symbol("hash");
    var Xc = Symbol("key");
    var vc = Symbol("url");
    var Lc = /* @__PURE__ */ new Map();
    var xc = 0;
    function Sc(t3) {
      return m.has("debug", t3, false);
    }
    function Gc(t3) {
      return t3.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function Tc(t3) {
      return t3.replace(/-/g, "+").replace(/_/g, "/").padEnd(t3.length + 3 & -4, "=");
    }
    function Wc(t3, e3) {
      return t3 || (t3 = "*"), e3.replace(/[\s\S]/g, (e4) => String.fromCharCode(e4.charCodeAt(0) ^ t3.charCodeAt(0)));
    }
    var Cc = class {
      async store() {
        throw Error("Data.store() needs to be called from session.data");
      }
      async fetch() {
        throw Error("Data.fetch() needs to be called from session.data");
      }
      static async store(t3, e3, s3) {
        if (ad.hasCurrent()) throw Error(`${Qt.libName}.Data.store() called from Model code`);
        let n3, i3, o3;
        if ("string" == typeof t3 ? (n3 = t3, t3 = e3, i3 = true, o3 = s3) : (n3 = e3 && e3.sessionId, i3 = e3 && e3.shareable, o3 = e3 && e3.keep), !(t3 instanceof ArrayBuffer)) throw Error(`${Qt.libName}.Data.store() called with non-ArrayBuffer data`);
        const { appId: r2, persistentId: a3, key: l3, uploadEncrypted: c2 } = yc(n3), d2 = i3 ? V.random(32).toString(Qi) : Qi.stringify(l3), h2 = `apps/${r2}/${a3}/data/%HASH%`, u2 = "data#" + ++xc;
        Sc("data") && console.log(`${Qt.libName}.Data: storing ${u2} ${t3.byteLength} bytes`);
        const m2 = await c2({ path: h2, content: t3, key: d2, keep: o3, debug: Sc("data"), what: u2 }), p2 = function(t4) {
          return t4.replace(/.*\//, "");
        }(m2), f2 = new kc(p2, i3 && d2, m2);
        return Sc("data") && console.log(`${Qt.libName}.Data: stored ${u2} as ${this.toId(f2)}`), f2;
      }
      static async fetch(t3, e3) {
        let s3;
        if (e3 && e3[vc] ? (s3 = t3, t3 = e3) : s3 = e3 && e3.sessionId, ad.hasCurrent()) throw Error(`${Qt.libName}.Data.fetch() called from Model code`);
        const { downloadEncrypted: n3, key: i3 } = yc(s3), o3 = t3 && t3[Zc], r2 = t3 && t3[Xc] || Qi.stringify(i3), a3 = t3 && t3[vc];
        if ("string" != typeof o3 || "string" != typeof r2 || "string" != typeof a3) throw Error(`${Qt.libName}.Data.fetch() called with invalid handle`);
        const l3 = "data#" + ++xc;
        return Sc("data") && console.log(`${Qt.libName}.Data: fetching ${l3} ${this.toId(t3)}`), n3({ url: a3, key: r2, debug: Sc("data"), what: l3 });
      }
      static hash(t3) {
        let s3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "base64url";
        "function" == typeof t3 && (t3 = Function.prototype.toString.call(t3)), "string" == typeof t3 ? t3 = new TextEncoder().encode(t3) : t3 && t3.constructor === DataView ? t3 = new Uint8Array(t3.buffer, t3.byteOffset, t3.byteLength) : t3 && t3.constructor === ArrayBuffer ? t3 = new Uint8Array(t3) : ArrayBuffer.isView(t3) || (t3 = new TextEncoder().encode(e2(t3)));
        const n3 = H(V.create(t3));
        switch (s3) {
          case "hex":
            return n3.toString();
          case "base64":
            return n3.toString(Qi);
          case "base64url":
            return Gc(n3.toString(Qi));
          default:
            throw Error(`${Qt.libName}.Data: unknown hash output "${s3}", expected "hex"/"base64"/"base64url"`);
        }
      }
      static fromId(t3) {
        const e3 = t3.slice(0, 1);
        let s3, n3, i3, o3;
        switch (e3) {
          case "0":
            s3 = t3.slice(1, 44), n3 = t3.slice(44), i3 = `${tc}/sessiondata/${s3}`;
            break;
          case "1":
            s3 = t3.slice(1, 44), n3 = t3.slice(44, 87) + "=", o3 = t3.slice(87), i3 = `${tc}/apps/${o3}/data/${s3}`;
            break;
          case "2":
            s3 = t3.slice(1, 44), n3 = Tc(t3.slice(44, 87)), o3 = Wc(n3, atob(Tc(t3.slice(87)))), i3 = `${tc}/apps/${o3}/data/${s3}`;
            break;
          case "3":
            n3 = Tc(t3.slice(1, 44)), i3 = Wc(n3, atob(Tc(t3.slice(44)))), s3 = i3.slice(-43);
            break;
          case "4":
            n3 = null, i3 = Wc(n3, atob(Tc(t3.slice(1)))), s3 = i3.slice(-43);
            break;
          default:
            throw Error(`${Qt.libName}.Data expected handle v0-v4 got v${e3}`);
        }
        return new this(s3, n3, i3);
      }
      static toId(t3) {
        if (!t3) return "";
        const e3 = t3[Zc], s3 = t3[Xc], n3 = t3[vc];
        if (n3.slice(-43) !== e3) throw Error(`${Qt.libName} Data: malformed URL`);
        const i3 = s3 && Gc(s3), o3 = Gc(btoa(Wc(s3, n3)));
        return s3 ? `3${i3}${o3}` : `4${o3}`;
      }
      constructor(t3) {
        let e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, s3 = arguments.length > 2 ? arguments[2] : void 0;
        const n3 = Lc.get(t3);
        if (n3) return n3;
        if (s3.slice(-43) !== t3) throw Error(`${Qt.libName} Data: malformed URL`);
        Object.defineProperty(this, Zc, { value: t3 }), e3 && Object.defineProperty(this, Xc, { value: e3 }), Object.defineProperty(this, vc, { value: s3 }), Lc.set(t3, this);
      }
    };
    var kc = class extends Cc {
    };
    var Pc = { cls: kc, write: (t3) => kc.toId(t3), read: (t3) => kc.fromId(t3) };
    var Ic = null;
    var Rc = null;
    var Vc = Symbol("DEBUG_WRITE_TARGET");
    var Yc = null;
    function Mc(t3, e3) {
      return Array.isArray(t3) || "string" != typeof e3 ? `[${e3}]` : e3.match(/^[a-z_$][a-z0-9_$]*$/i) ? `.${e3}` : `["${e3}"]`;
    }
    var Hc = class extends Error {
    };
    function Kc() {
      if (!globalThis.CroquetViewMath) {
        globalThis.CroquetMath.random = () => Ic.random(), globalThis.CroquetViewMath = {};
        for (const [t3, e3] of Object.entries(Object.getOwnPropertyDescriptors(Math))) globalThis.CroquetViewMath[t3] = e3.value;
        for (const [s3, n3] of Object.entries(globalThis.CroquetMath)) {
          const i3 = Math[s3];
          Math[s3] = 1 === n3.length ? (t3) => Ic ? n3(t3) : i3(t3) : (t3, e3) => Ic ? n3(t3, e3) : i3(t3, e3);
        }
      }
      if (!globalThis.CroquetViewDate) {
        let a3 = function(t3, e3) {
          return r2 || (r2 = true, console.warn(new Hc(`${t3} used in Model code`))), e3;
        }, l3 = function(t3, e3, s3, n3, i3, r3, c2) {
          const d2 = this instanceof l3, h2 = [t3, e3, s3, n3, i3, r3, c2];
          if (h2.length = arguments.length, Ic) switch (a3(d2 ? "new Date()" : "Date()"), arguments.length) {
            case 0:
              h2.push(Ic.time);
              break;
            case 1:
              break;
            default:
              h2[0] = o3.UTC(...h2), h2.length = 1;
          }
          const u2 = new o3(...h2);
          return d2 ? u2 : "" + u2;
        };
        const o3 = globalThis.Date;
        let r2 = false;
        l3.prototype = o3.prototype, l3.UTC = o3.UTC, l3.now = () => Ic ? a3("Date.now()", Ic.time) : o3.now(), l3.parse = function() {
          return Ic ? a3("Date.parse()", 0) : o3.parse(...arguments);
        }, globalThis.CroquetViewDate = o3, globalThis.Date = l3;
      }
    }
    Object.defineProperty(Hc.prototype, "name", { value: `${Qt.libName}Warning` });
    var Nc = Symbol("QFUNC");
    function zc(t3, e3, s3, n3) {
      const i3 = new Fc(t3, e3, s3, n3), o3 = i3.compile();
      return o3[Nc] = i3, o3;
    }
    function _c(t3, e3, s3, n3) {
      const i3 = [], o3 = [];
      let r2, a3, l3, c2;
      if (s3) {
        if ("this" in s3) {
          for (e3 = s3.this, r2 = "_this"; r2 in s3; ) r2 = "_" + r2;
          delete (s3 = { ...s3, [r2]: e3 }).this;
        }
        if (l3 = [...Object.keys(s3).sort()], c2 = [...l3.map((t4) => s3[t4])], l3.length) {
          for (a3 = "env"; a3 in s3 || a3 === n3; ) a3 = "_" + a3;
          i3.push(a3), o3.push(c2);
        }
      }
      t3.match(/\bCroquet\b/) && !(l3 == null ? void 0 : l3.includes("Croquet")) && (i3.push("Croquet"), o3.push(Sd.Croquet)), t3.match(/\bMultisynq\b/) && !(l3 == null ? void 0 : l3.includes("Multisynq")) && (i3.push("Multisynq"), o3.push(Sd.Croquet));
      let d2 = n3 || "qFunc";
      for (; l3 == null ? void 0 : l3.includes(d2); ) d2 = "_" + d2;
      let h2 = '"use strict"\n\n';
      h2 += "// Croquet QFunc Compiler by Codefrau\n\n", h2 += "//////////////// Start Compiler /////////////////\n", h2 += "try { const ", (l3 == null ? void 0 : l3.length) && (h2 += `[${l3.join(", ")}] = ${a3}, `);
      let u2 = t3.split("\n");
      const m2 = u2.slice(1), p2 = Math.min(...m2.map((t4) => t4.match(/^\s*/)[0].length));
      if (p2 > 0) {
        u2.some((t4) => (t4.match(/`/g) || []).length % 2 == 1) || (u2 = [u2[0], ...m2.map((t4) => t4.slice(p2))], t3 = u2.join("\n"));
      }
      const f2 = u2[u2.length - 1].match(/^\s*/)[0];
      f2 && (t3 = f2 + t3), h2 += `${d2} =
`, h2 += "//////////////// Start User Code ////////////////\n\n", h2 += t3, h2 += "\n\n///////////////// End User Code /////////////////\n", h2 += `return ${d2}`, r2 && (h2 += `.bind(${r2})`), h2 += " } catch (compileError) { return compileError; }\n", h2 += "///////////////// End Compiler //////////////////";
      try {
        const t4 = new Function(...i3, h2).call(e3, ...o3);
        if (t4 instanceof Error) throw console.warn("rethrowing error", t4), t4;
        return t4;
      } catch (e4) {
        throw console.warn(`createQFunc compiling:

${t3}`), Error(`createQFunc(): ${e4.message}`);
      }
    }
    var Fc = class {
      constructor(t3, e3, s3, n3) {
        if (this.thisVal = t3, this.env = e3, this.selfRef = n3, this.source = s3, void 0 === n3) {
          this.selfRef = "", "function" == typeof s3 && (this.source = s3.toString());
          const t4 = Object.keys(e3);
          for (const n4 of t4) if (s3 === e3[n4]) {
            if (this.selfRef) throw Error(`createQFunc: env.${this.selfRef} and env.${n4} cannot both reference the function`);
            this.selfRef = n4;
          }
          this.selfRef && (this.env = { ...e3 }, delete this.env[this.selfRef]);
        }
        Object.freeze(this.env);
      }
      compile() {
        return _c(this.source, this.thisVal, this.env, this.selfRef);
      }
    };
    var Ec = { cls: Nc, write: (t3) => {
      let { [Nc]: { thisVal: e3, env: s3, source: n3, selfRef: i3 } } = t3;
      return [e3, n3, i3, ...Object.entries(s3).flat()];
    }, read: (t3) => {
      let [e3, s3, n3, ...i3] = t3;
      const o3 = {};
      for (let t4 = 0; t4 < i3.length; t4 += 2) o3[i3[t4]] = i3[t4 + 1];
      return zc(e3, o3, s3, n3);
    } };
    var jc = "future message";
    var Jc = "message in cancelFuture";
    var Qc = "subscription handler";
    function Uc(t3) {
      return `qFunc~${t3.split(" ")[0]}~`;
    }
    var Dc = Uc(jc);
    var Oc = Uc(Qc);
    function Bc(t3) {
      return t3 === jc || t3 === Qc;
    }
    function Ac(t3) {
      return t3.startsWith(Dc);
    }
    function $c(t3) {
      return `${Oc}${t3}`;
    }
    function qc(t3, e3) {
      return !!t3.startsWith(Oc) && t3.slice(Oc.length) === e3;
    }
    function td(t3, e3) {
      if (Ic) throw Error("VirtualMachine confusion");
      if (!(t3 instanceof ad)) throw Error("not a VM: " + t3);
      const s3 = Ic;
      try {
        Ic = t3, globalThis.CROQUETVM = t3, e3();
      } finally {
        Ic = s3;
      }
    }
    var ed = "#reflected";
    var sd = ["handleModelEventInModel", "handleBundledEvents", "publishFromModelOnly", "handlePollForSnapshot", "handleTuttiResult", "handleTuttiDivergence", "handleSnapshotVote", "handlePersistVote", "handleModelEventInView", "noop", "handleAuditRequest"];
    var nd = {};
    for (let t3 = 0; t3 < sd.length; t3++) nd[sd[t3]] = t3;
    var id = /* @__PURE__ */ new WeakMap();
    function od(t3) {
      id.set(t3, null);
    }
    var rd = class {
      random() {
        throw Error("Math.random() cannot be used in Model.evaluate()");
      }
    };
    var ad = class {
      static current() {
        return Ic || console.warn("VirtualMachine.current() called from outside the vm!"), Ic;
      }
      static hasCurrent() {
        return !!Ic;
      }
      static evaluate(t3) {
        if (Ic) return t3();
        Kc();
        const e3 = Ic;
        try {
          return Ic = new rd(), t3();
        } finally {
          Ic = e3;
        }
      }
      constructor(t3, e3, s3, n3) {
        Kc(), Rc = { snapshot: m.has("debug", "snapshot", false), session: m.has("debug", "session", false), write: m.has("debug", "write", false) }, od(this), td(this, () => {
          ee(this, () => {
            if (this.models = {}, this.namedModels = {}, this.messages = new _i((t4, e4) => t4.before(e4)), this.subscriptions = {}, this.subscribers = /* @__PURE__ */ new Map(), this.genericSubscriptions = [], this.currentEvent = "", this.currentEventFromModel = false, this.debugEvents = e3, this.views = {}, this._random = () => {
              throw Error("You must not use random when applying state!");
            }, this.id = t3.id, this.time = 0, this.seq = 4294967280, this.externalTime = 0, this.externalSeq = this.seq, this.futureSeq = 0, this.lastSnapshotPoll = 0, this.lastPersistencePoll = 0, this.inPersistenceCoolOff = false, this.persisted = "", this.modelsId = 0, this.diverged = null, this.controller = null, t3.models) {
              const e4 = fd.newOrRecycled(this).readVM(t3, "VM", n3);
              let s4 = [], i3 = [];
              for (const t4 of Object.keys(e4)) "meta" !== t4 && ("staticInitializers" === t4 ? s4 = e4[t4] : t4 in this ? "_random" === t4 ? this[t4] = new Z(null, { state: e4[t4] }) : "messages" === t4 ? i3 = e4.messages : this[t4] = e4[t4] : console.warn(`Ignoring property snapshot.${t4}`));
              for (const t4 of s4) t4();
              for (const t4 of i3) this.messages.add(t4);
              for (const [t4, e5] of Object.entries(this.subscriptions)) for (const s5 of e5) {
                const [e6] = s5.split(".");
                let n4 = this.subscribers.get(e6);
                n4 || this.subscribers.set(e6, n4 = /* @__PURE__ */ new Set()), n4.add(t4);
              }
            } else this._random = new Z(t3.id, { state: true }), this.addSubscription(this, "__VM__", "__peers__", this.generateJoinExit), this.addSubscription(this, "__VM__", "__diverged__", this.handleSessionDiverged), s3(this);
          });
        });
      }
      registerModel(t3, e3) {
        if (Ic !== this) throw Error("You can only create models from model code!");
        return e3 || (e3 = "M" + ++this.modelsId), this.models[e3] = t3, e3;
      }
      deregisterModel(t3) {
        if (Ic !== this) throw Error("You can only destroy models from model code!");
        const e3 = this.models;
        delete this.models[t3];
        for (const [t4, s3] of Object.entries(this.namedModels)) e3 === s3 && delete this.namedModels[t4];
        this.messages.removeMany((e4) => e4.hasReceiver(t3));
      }
      lookUpModel(t3) {
        if ("_" === t3) return this;
        let e3 = this.models[t3];
        if (e3) return e3;
        const [s3, n3, i3] = t3.match(/^([^#]+)#(.*)$/) || [];
        return e3 = this.models[n3], e3 && e3.lookUp(i3);
      }
      get(t3) {
        const e3 = this.namedModels[t3];
        return Ic !== this && Rc.write && e3 ? this.debugWriteProxy(this, e3, e3.id) : e3;
      }
      set(t3, e3) {
        if (Ic !== this) throw Error("You can only make a model well-known from model code!");
        this.namedModels[t3] = e3;
      }
      debugWriteProxy(t3, e3, s3) {
        if ("object" != typeof e3 || null === e3 || e3[Vc]) return e3;
        if (e3 instanceof Sd && (s3 = e3.id), !this.$debugWriteProxyHandler) {
          let i3 = function(t4, e4, s4) {
            s4 && (t4 += ` ${s4} of`);
            const n4 = Yc.get(e4).path;
            if (console.warn(`write-debug: non-model code is ${t4} ${n4}:`, e4), s4 && "$" !== s4[0]) throw Error(`write-debug: Attempt to modify ${Qt.libName} model state from outside!`);
          };
          Yc || (Yc = /* @__PURE__ */ new WeakMap()), this.$debugWriteProxyHandler = { set(e4, s4, n4) {
            Ic !== t3 ? i3("assigning", e4, s4) : console.warn(`${Qt.libName} debug write protection inside model - this should not happen!`), e4[s4] = n4;
          }, deleteProperty(e4, s4) {
            Ic !== t3 ? i3("deleting", e4, s4) : console.warn(`${Qt.libName} debug write protection inside model - this should not happen!`), delete e4[s4];
          }, get(e4, s4) {
            if (s4 === Vc) return e4;
            const n4 = e4[s4];
            if (n4 && n4[Vc]) return n4;
            if (Ic !== t3) {
              if ("object" == typeof n4 && null !== n4) {
                const o3 = Yc.get(e4).path;
                if (n4 instanceof Map) {
                  const e5 = new Map([...n4.entries()].map((e6, s5) => {
                    let [n5, i4] = e6;
                    return [t3.debugWriteProxy(t3, n5, `${o3}.key#${s5}`), t3.debugWriteProxy(t3, i4, `${o3}.value#${s5}`)];
                  }));
                  return e5[Vc] = n4, e5.set = () => i3("setting an item in", n4), e5.delete = () => i3("deleting from", n4), e5.clear = () => i3("clearing", n4), Yc.set(n4, { proxy: e5, path: o3 + Mc(n4, s4) }), e5;
                }
                if (n4 instanceof Set) {
                  const e5 = new Set([...n4.values()].map((e6, s5) => t3.debugWriteProxy(t3, e6, `${o3}.item#${s5}`)));
                  return e5[Vc] = n4, e5.add = () => i3("adding to", n4), e5.delete = () => i3("deleting from", n4), e5.clear = () => i3("clearing", n4), Yc.set(n4, { proxy: e5, path: o3 + Mc(n4, s4) }), e5;
                }
                return t3.debugWriteProxy(t3, n4, o3 + Mc(n4, s4));
              }
            } else console.warn(`${Qt.libName} debug write protection inside model - this should not happen!`);
            return n4;
          } };
        }
        let n3 = Yc.get(e3);
        return n3 || (n3 = { proxy: new Proxy(e3, this.$debugWriteProxyHandler), path: s3 }, Yc.set(e3, n3)), n3.proxy;
      }
      noop() {
      }
      generateJoinExit(t3) {
        let { entered: e3, exited: s3, count: n3, total: i3 } = t3;
        this.controller.handleUserTotalForAccounting(i3);
        const o3 = {};
        for (const t4 of e3) {
          if ("string" == typeof t4) continue;
          let e4, s4, n4;
          Array.isArray(t4) ? [e4, s4] = t4 : (e4 = t4.id, n4 = t4.data, s4 = t4.location), o3[e4] = {}, n4 && (o3[e4].data = n4), s4 && (s4.region && (s4.country = s4.region.slice(0, 2), s4.region = s4.region.slice(2)), o3[e4].loc = s4);
        }
        if (e3 = e3.map((t4) => "string" == typeof t4 ? t4 : Array.isArray(t4) ? t4[0] : t4.id), s3 = s3.map((t4) => "string" == typeof t4 ? t4 : Array.isArray(t4) ? t4[0] : t4.id), e3.length === n3) {
          s3 = Object.keys(this.views);
          for (const t4 of s3) this.views[t4].extraConnections = 0;
        }
        if (e3.length > 0 && s3.length > 0 && e3.some((t4) => s3.includes(t4))) {
          for (let t4 = 0; t4 < e3.length; t4++) {
            const n4 = e3[t4], i4 = s3.indexOf(n4);
            i4 >= 0 && (e3.splice(t4, 1), s3.splice(i4, 1), t4--);
          }
          if (e3.length + s3.length === 0) return;
        }
        const r2 = (t4) => {
          const { data: e4, loc: s4 } = this.views[t4];
          if (!e4) return t4;
          const n4 = { viewId: t4, viewData: e4 };
          return s4 && (n4.location = s4), n4;
        };
        for (const t4 of s3) if (this.views[t4]) {
          if (this.views[t4].extraConnections) {
            this.views[t4].extraConnections--, Rc.session && console.log(this.id, `@${this.time}#${this.seq} view ${t4} closed extra connection`);
            continue;
          }
          const e4 = r2(t4);
          delete this.views[t4], this.publishFromModelOnly(this.id, "view-exit", e4);
        } else {
          const { time: e4, seq: s4 } = this;
          console.error(`${this.id} @${e4}#${s4} view ${t4} exited without being present - this should not happen`), Promise.resolve().then(() => {
            this.controller.sendLog(`view-exit-mismatch @${e4}#${s4} ${t4} left without being present`);
          });
        }
        for (const t4 of e3) if (this.views[t4]) Rc.session && console.log(this.id, `@${this.time}#${this.seq} view ${t4} opened another connection`), this.views[t4].extraConnections = (this.views[t4].extraConnections || 0) + 1;
        else {
          this.views[t4] = o3[t4] || {};
          const e4 = r2(t4);
          this.publishFromModelOnly(this.id, "view-join", e4);
        }
        const a3 = Object.values(this.views).reduce((t4, e4) => t4 + 1 + (e4.extraConnections || 0), 0);
        if (n3 !== a3) {
          const { time: t4, seq: e4 } = this;
          console.error(`@${t4}#${e4} view count mismatch (model: ${a3}, reflector: ${n3}) - this should not happen`), Promise.resolve().then(() => {
            this.controller.sendLog(`view-exit-mismatch @${t4}#${e4} connections model: ${a3} reflector: ${n3}`);
          });
        }
      }
      scheduleExternalMessage(t3) {
        const e3 = dd.fromState(t3, this);
        if (e3.time < this.time) throw Error("past message from reflector " + t3);
        const s3 = this.externalSeq + 1 >>> 0;
        if (e3.seq !== s3) throw Error(`External message error. Expected message #${s3} got #${e3.seq}`);
        return this.externalTime = e3.time, this.externalSeq = e3.seq, e3.seq = 2 * e3.seq + 1, this.verifyExternal(e3), this.messages.add(e3), e3;
      }
      verifyExternal(t3) {
        if ("_" !== t3.receiver) throw Error(`invalid receiver in external message: ${t3}`);
        if (!(t3.selector in nd)) throw Error(`unexpected external message: ${t3.selector}`);
      }
      futureSend(t3, e3, s3, n3) {
        if (t3.every) return this.futureRepeat(t3.every, e3, s3, n3);
        if (t3 < 0) throw Error("attempt to send future message into the past");
        this.futureSeq = this.futureSeq + 1 >>> 0;
        const i3 = new dd(this.time + t3, 2 * this.futureSeq, e3, s3, n3);
        return this.messages.add(i3), { time: i3.time, seq: i3.seq };
      }
      cancelFuture(t3, e3) {
        const s3 = this.messages;
        let n3;
        if ("number" == typeof e3.time) {
          const { time: t4, seq: i3 } = e3;
          n3 = s3.removeOne((e4) => e4.time === t4 && e4.seq === i3);
        } else {
          if ("*" === e3) return n3 = s3.removeMany((e4) => e4.receiver === t3.id), n3.length > 0;
          {
            const i3 = this.asMethodName(t3, e3, Jc), o3 = t3.id;
            n3 = s3.removeOne((t4) => t4.receiver === o3 && t4.selector === i3 || "_" === t4.receiver && "futureExecAndRepeat" === t4.selector && t4.args[1] === o3 && t4.args[2] === i3), Ac(i3) && delete t3[i3];
          }
        }
        return void 0 !== n3;
      }
      futureRepeat(t3, e3, s3, n3) {
        this.futureSend(t3, "_", "futureExecAndRepeat", [t3, e3, s3, n3]);
      }
      futureExecAndRepeat(t3, e3, s3, n3) {
        const i3 = this.lookUpModel(e3);
        if (i3) {
          if ("function" == typeof i3[s3]) try {
            i3[s3](...n3);
          } catch (t4) {
            Pt(`future message ${i3}.${s3}`, t4);
          }
          else {
            const t4 = this.compileFuncString(s3, i3);
            try {
              t4(...n3);
            } catch (e4) {
              Pt(`future message ${i3} ${t4}`, e4);
            }
          }
          this.futureRepeat(t3, e3, s3, n3);
        }
      }
      future(t3, e3, s3, n3) {
        if (!this.lookUpModel(t3.id)) throw Error(`future send to unregistered model ${t3}`);
        if (void 0 === s3) {
          const s4 = this;
          return new Proxy(t3, { get: (n4, i4) => function() {
            for (var n5 = arguments.length, o3 = new Array(n5), r2 = 0; r2 < n5; r2++) o3[r2] = arguments[r2];
            return s4.future(t3, e3, i4, o3);
          } });
        }
        const i3 = this.asMethodName(t3, s3, jc);
        if ("string" != typeof i3) throw Error(`future message to ${t3} ${i3} is not a string`);
        if ("function" != typeof t3[i3] && i3.indexOf(".") < 0 && "{" !== i3[0]) throw Error(`future send to ${t3} with unknown method ${i3}()`);
        return this.futureSend(e3, t3.id, i3, n3);
      }
      advanceTo(t3, e3) {
        if (Ic) throw Error("cannot advance time from model code");
        let s3;
        for (; (s3 = this.messages.peek()) && s3.time <= t3; ) {
          const { time: t4, seq: n3 } = s3;
          if (t4 < this.time) throw Error("past message encountered: " + s3);
          if (1 & n3 && (this.seq = this.seq + 1 >>> 0, n3 / 2 >>> 0 !== this.seq)) throw Error(`Sequence error: expected ${this.seq} got ${n3 / 2 >>> 0} in ${s3}`);
          if (this.messages.poll(), this.time = s3.time, s3.executeOn(this), globalThis.CroquetViewDate.now() >= e3) return false;
        }
        return this.time = t3, true;
      }
      asMethodName(t3, e3, s3) {
        let n3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
        if ("string" == typeof e3) return e3;
        if ("function" == typeof e3) {
          if (t3[e3.name] === e3) return e3.name;
          if (e3[Nc] && n3) {
            const s4 = $c(n3);
            if (t3[s4] === e3) return s4;
          }
          let o3 = t3;
          for (; null !== o3; ) {
            for (const [t4, n4] of Object.entries(Object.getOwnPropertyDescriptors(o3))) if (n4.value === e3) {
              if (e3[Nc] && ((i3 = s3) !== jc && i3 !== Jc || !Ac(t4))) continue;
              return t4;
            }
            if (o3 === t3 && e3[Nc]) {
              if (!Bc(s3)) return Ct(`${s3} is not a registered QFunc: ${e3}`, { only: "once" }), null;
              let i4;
              if (n3) i4 = $c(n3);
              else {
                const e4 = Dc;
                let s4 = 0;
                do {
                  i4 = `${e4}${s4++}`;
                } while (t3[i4]);
              }
              return t3[i4] = e3, i4;
            }
            o3 = Object.getPrototypeOf(o3);
          }
          Ct(`${s3} is not a method of ${t3} and not a QFunc: ${e3}
`, { only: "once" });
          const r2 = /^\(?([a-z][a-z0-9]*)?\)? *=> *this\.([a-z][a-z0-9]*) *\( *([a-z][a-z0-9]*)? *\) *$/i, a3 = e3.toString().match(r2);
          return !a3 || a3[3] && a3[3] !== a3[1] ? this.asFuncString(e3) : a3[2];
        }
        var i3;
        return null;
      }
      asFuncString(t3) {
        const e3 = t3.toString();
        return `{${btoa(JSON.stringify(e3))}}`;
      }
      compileFuncString(t3, e3) {
        this.$compiledFuncs || (this.$compiledFuncs = {});
        const s3 = e3.id + ":" + t3;
        let n3 = this.$compiledFuncs[s3];
        if (!n3) {
          const i3 = JSON.parse(atob(t3.slice(1, -1)));
          n3 = _c(i3, e3), i3.startsWith("function") && (n3 = n3.bind(e3)), this.$compiledFuncs[s3] = n3;
        }
        return n3;
      }
      addSubscription(t3, e3, s3, n3) {
        if (Ic !== this) throw Error("Cannot add a model subscription from outside model code");
        if (e3.includes(":")) throw Error(`Invalid subscription scope "${e3}" (must not contain ':')`);
        const i3 = e3 + ":" + s3, o3 = this.asMethodName(t3, n3, Qc, i3);
        if ("string" != typeof o3) throw Error(`Subscription handler for "${s3}" must be a method name`);
        if (o3.indexOf(".") < 0 && "function" != typeof t3[o3] && "{" !== o3[0]) throw Error(`Subscriber method for "${s3}" not found: ${t3}.${o3}()`);
        const r2 = t3 === this ? "_" : t3.id, a3 = r2 + "." + o3;
        if ("*" === e3 || "*" === s3) return void this.addGenericSubscription(i3, a3);
        if (this.subscriptions[i3]) {
          if (-1 !== this.subscriptions[i3].indexOf(a3)) throw Error(`${t3}.${o3} already subscribed to ${s3}`);
        } else this.subscriptions[i3] = [];
        this.subscriptions[i3].push(a3);
        let l3 = this.subscribers.get(r2);
        l3 || this.subscribers.set(r2, l3 = /* @__PURE__ */ new Set()), l3.add(i3);
      }
      removeSubscription(t3, e3, s3) {
        let n3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "*";
        if (Ic !== this) throw Error("Cannot remove a model subscription from outside model code");
        if ("*" === e3 || "*" === s3) return void this.removeGenericSubscription(t3, e3, s3, n3);
        const i3 = e3 + ":" + s3, o3 = this.subscriptions[i3];
        if (o3) {
          const e4 = t3.id + ".";
          if ("*" === n3) {
            for (let s4 = o3.length - 1; s4 >= 0; s4--) if (o3[s4].startsWith(e4)) {
              const n4 = o3[s4].slice(e4.length);
              qc(n4, i3) && delete t3[n4], o3.splice(s4, 1);
            }
            0 === o3.length && delete this.subscriptions[i3];
          } else {
            const r3 = this.asMethodName(t3, n3, "unsubscribe argument", i3);
            if ("string" != typeof r3) throw Error(`Invalid unsubscribe args for "${s3}" in ${t3}: ${n3}`);
            const a3 = e4 + r3, l3 = o3.indexOf(a3);
            if (-1 !== l3 && (o3.splice(l3, 1), 0 === o3.length && delete this.subscriptions[i3], qc(r3, i3) && delete t3[r3]), o3.find((t4) => t4.startsWith(e4))) return;
          }
          const r2 = this.subscribers.get(t3.id);
          r2.delete(i3), 0 === r2.size && this.subscribers.delete(t3.id);
        }
      }
      addGenericSubscription(t3, e3) {
        this.genericSubscriptions.push({ topic: t3, handler: e3 });
      }
      removeGenericSubscription(t3, e3, s3) {
        let n3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "*";
        const i3 = e3 + ":" + s3, o3 = t3.id + ".";
        for (let e4 = this.genericSubscriptions.length - 1; e4 >= 0; e4--) {
          const s4 = this.genericSubscriptions[e4];
          s4.topic === i3 && s4.handler.startsWith(o3) && ("*" !== n3 && s4.handler !== o3 + n3 || (this.genericSubscriptions.splice(e4, 1), qc(n3, i3) && delete t3[n3]));
        }
      }
      removeAllSubscriptionsFor(t3) {
        const e3 = this.subscribers.get(t3.id);
        if (e3) {
          const s3 = t3.id + ".";
          for (const n3 of e3) {
            const e4 = this.subscriptions[n3];
            for (let i3 = e4.length - 1; i3 >= 0; i3--) if (e4[i3].startsWith(s3)) {
              const o3 = e4[i3].slice(s3.length);
              qc(o3, n3) && delete t3[o3], e4.splice(i3, 1);
            }
            0 === e4.length && delete this.subscriptions[n3];
          }
          this.subscribers.delete(t3.id);
        }
      }
      publishFromModel(t3, e3, s3) {
        if (Ic !== this) throw Error("Cannot publish a model event from outside model code");
        if (t3.includes(":")) throw Error(`Invalid publish scope "${t3}" (must not contain ':')`);
        const n3 = e3.endsWith(ed);
        n3 && (e3 = e3.slice(0, e3.length - 10));
        const i3 = this.currentEventFromModel;
        this.currentEventFromModel = true;
        const o3 = t3 + ":" + e3;
        this.handleModelEventInModel(o3, s3, n3), this.handleModelEventInView(o3, s3), this.currentEventFromModel = i3;
      }
      publishFromModelOnly(t3, e3, s3) {
        if (Ic !== this) throw Error("Cannot publish a model event from outside model code");
        const n3 = t3 + ":" + e3;
        this.handleModelEventInModel(n3, s3);
      }
      publishFromView(t3, e3, s3) {
        if (Ic) throw Error("Cannot publish a view event from model code");
        if (t3.includes(":")) throw Error(`Invalid publish scope "${t3}" (must not contain ':')`);
        const n3 = t3 + ":" + e3;
        this.handleViewEventInModel(n3, s3), this.handleViewEventInView(n3, s3);
      }
      handleBundledEvents(t3) {
        for (const e3 of t3) {
          const t4 = dd.fromState(e3, this);
          this.verifyExternal(t4), t4.executeOn(this, true);
        }
      }
      handleModelEventInModel(t3, e3) {
        let s3 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        if (Ic !== this) throw Error("handleModelEventInModel called from outside model code");
        if (s3) {
          if (true !== this.controller.synced) return;
          const s4 = t3 + "#__vote", n3 = t3 + "#divergence", i3 = !!Ot.subscriptions[s4], o3 = !!this.subscriptions[t3], r2 = !!this.subscriptions[n3];
          i3 && r2 && console.log(`divergence subscription for ${t3} overridden by vote subscription`);
          const a3 = o3 ? new dd(this.time, 0, "_", "handleModelEventInModel", [t3, e3]) : null;
          let l3;
          l3 = i3 ? ["handleModelEventInView", s4] : ["handleTuttiDivergence", n3], Promise.resolve().then(() => this.controller.sendTutti({ time: this.time, topic: t3, data: e3, firstMessage: a3, wantsVote: i3, tallyTarget: l3 }));
        } else this.genericSubscriptions.length > 0 && this.invokeGenericHandlers(t3, e3), this.subscriptions[t3] && this.invokeHandlers(this.subscriptions[t3], t3, e3);
      }
      invokeHandlers(t3, e3, s3) {
        const n3 = t3.slice();
        for (let i3 = 0; i3 < n3.length; i3++) {
          const o3 = n3[i3];
          (o3 === t3[i3] || t3.includes(o3)) && this.invokeHandler(o3, e3, s3);
        }
      }
      invokeGenericHandlers(t3, e3) {
        const [s3, n3] = t3.split(":");
        if (!(s3.startsWith("__") && s3.endsWith("__") || n3.startsWith("__") && n3.endsWith("__"))) for (const i3 of this.genericSubscriptions) {
          const [o3, r2] = i3.topic.split(":");
          ("*" === o3 && r2 === n3 || o3 === s3 && "*" === r2 || "*" === o3 && "*" === r2) && this.invokeHandler(i3.handler, t3, e3);
        }
      }
      invokeHandler(t3, e3, s3) {
        const n3 = this.currentEvent;
        this.currentEvent = e3;
        try {
          const [n4, ...i3] = t3.split("."), o3 = i3.join("."), r2 = this.lookUpModel(n4);
          if (!r2) return void Ct(`event ${e3} .${o3}(): subscriber not found`);
          if ("{" === o3[0]) {
            const t4 = this.compileFuncString(o3, r2);
            try {
              t4(s3);
            } catch (s4) {
              Pt(`event ${e3} ${r2} ${t4}`, s4);
            }
            return;
          }
          if (o3.indexOf(".") >= 0) {
            const t4 = o3.indexOf("."), n5 = o3.slice(0, t4), i4 = o3.slice(t4 + 1);
            try {
              r2.call(n5, i4, s3);
            } catch (t5) {
              Pt(`event ${e3} ${r2}.call(${JSON.stringify(n5)}, ${JSON.stringify(i4)})`, t5);
            }
            return;
          }
          if ("function" != typeof r2[o3]) return void Pt(`event ${e3} ${r2}.${o3}(): method not found`);
          try {
            r2[o3](s3);
          } catch (t4) {
            Pt(`event ${e3} ${r2}.${o3}()`, t4);
          }
        } finally {
          this.currentEvent = n3;
        }
      }
      handleViewEventInModel(t3, e3) {
        if (this.subscriptions[t3]) {
          const s3 = [t3];
          void 0 !== e3 && s3.push(e3);
          const n3 = new dd(this.time, 0, "_", "handleModelEventInModel", s3);
          this.controller.sendMessage(n3);
        }
      }
      handleModelEventInView(t3, e3) {
        Rc.write && (e3 = this.debugWriteProxy(this, e3, `event ${t3} arg`)), Ot.handleEvent(t3, e3, (t4) => function(t5) {
          if (!Ic) throw Error("VirtualMachine confusion");
          const e4 = Ic;
          try {
            Ic = null, t5();
          } finally {
            Ic = e4;
          }
        }(() => se(this, t4, true)));
      }
      handleViewEventInView(t3, e3) {
        Ot.handleEvent(t3, e3);
      }
      handleTuttiDivergence(t3, e3) {
        if (this.subscriptions[t3]) this.handleModelEventInModel(t3, e3);
        else {
          const s3 = t3.split(":").slice(-1)[0];
          console.warn(`uncaptured divergence in ${s3}:`, e3);
        }
      }
      handleSessionDiverged(t3) {
        const { key: e3, url: s3 } = t3;
        this.diverged || (this.diverged = /* @__PURE__ */ new Map());
        let n3 = this.diverged.get(e3);
        n3 || this.diverged.set(e3, n3 = []), n3.push(s3), 2 === n3.length && this.controller && !this.controller.fastForwardHandler && this.debugDiverged(e3);
      }
      debugDiverged(t3) {
        t3 || (t3 = this.diverged.keys().next().value);
        const e3 = this.diverged.get(t3);
        if (!e3 || e3.length < 2) throw Error(`no diverged urls for snapshot ${t3}`);
        Promise.resolve().then(() => this.controller.diffDivergedSnapshots(e3));
      }
      processModelViewEvents(t3) {
        if (Ic) throw Error("cannot process view events in model code");
        return se(this, () => Ot.processFrameEvents(t3, !!this.controller.synced));
      }
      handlePollForSnapshot() {
        const t3 = this.time, e3 = t3 - this.lastSnapshotPoll;
        e3 < 5e3 ? console.log(`rejecting snapshot poll ${e3}ms after previous`) : (this.lastSnapshotPoll = t3, this.controller.handlePollForSnapshot(t3));
      }
      handleTuttiResult(t3) {
        this.controller.handleTuttiResult(t3);
      }
      handleSnapshotVote(t3) {
        this.controller.handleSnapshotVote(t3);
      }
      handlePersistVote(t3) {
        this.controller.handlePersistVote(t3);
      }
      handleAuditRequest(t3) {
        this.controller.handleAuditRequest(t3);
      }
      snapshot() {
        return md.newOrRecycled(this).snapshot(this, "VM");
      }
      getSummaryHash() {
        return e2(new ud().getHash(this));
      }
      debug(t3) {
        return this.controller.setDebug(t3);
      }
      forceSnapshot() {
        this.controller.requestDebugSnapshot();
      }
      persist(t3, s3) {
        this.controller && "no.appId" === this.controller.sessionSpec.appId && console.warn(`${Qt.libName}: appId should be provided in Session.join() to not overwrite another apps's persistent data`);
        const n3 = Zt.begin("snapshot"), i3 = "function" == typeof s3 ? s3.call(t3) : s3;
        if ("object" != typeof i3) throw Error(`${Qt.libName}: persistSession() can only persist objects (got ${typeof i3})`);
        const o3 = e2(i3), r2 = kc.hash(o3), a3 = Zt.end("snapshot") - n3, l3 = this.persisted === r2, c2 = this.time;
        var d2, h2;
        if (Rc.snapshot && console.log(this.id, `persistent data @${c2} collected, stringified and hashed in ${Math.ceil(a3)}ms${l3 ? " (unchanged, ignoring)" : ""}`), m.forcePersist && queueMicrotask(() => this.controller.forcePersist(c2, o3, r2)), !l3) if (d2 = this, h2 = { persistTime: c2, persistentString: o3, persistentHash: r2, ms: a3 }, id.set(d2, h2), this.persisted = r2, this.inPersistenceCoolOff) Rc.snapshot && console.log(this.id, "persistence poll postponed by cooloff");
        else {
          const t4 = this.lastPersistencePoll ? this.lastPersistencePoll + 25e3 - this.time : 0;
          t4 > 0 ? (Rc.snapshot && console.log(this.id, `postponing persistence poll by ${t4}ms`), this.futureSend(t4, "_", "triggerPersistencePoll", []), this.inPersistenceCoolOff = true) : this.triggerPersistencePoll();
        }
      }
      triggerPersistencePoll() {
        this.inPersistenceCoolOff = false, this.lastPersistencePoll = this.controller ? this.time : 0;
        const t3 = (e3 = this, id.get(e3));
        var e3;
        if (!t3) return;
        const { persistTime: s3, persistentString: n3, persistentHash: i3, ms: o3 } = t3;
        if (od(this), this.controller && this.controller.synced) {
          Rc.snapshot && console.log(this.id, `asking controller to poll for persistence @${s3}`);
          const t4 = this.time;
          Promise.resolve().then(() => this.controller.pollForPersist(t4, s3, n3, i3, o3));
        }
      }
      random() {
        if (Ic !== this) throw Error("synchronized random accessed from outside the model");
        return this._random();
      }
      randomID() {
        if (Ic !== this) throw Error("synchronized random accessed from outside the model");
        let t3 = "";
        for (let e3 = 0; e3 < 4; e3++) t3 += (this._random.int32() >>> 0).toString(16).padStart(8, "0");
        return t3;
      }
      toString() {
        return `VirtualMachine[${this.id}]`;
      }
      [Symbol.toPrimitive]() {
        return this.toString();
      }
    };
    function ld(t3, e3, s3) {
      let n3;
      if ("_" === t3) {
        const t4 = nd[e3];
        "number" == typeof t4 && (n3 = t4.toString(36));
      }
      if (void 0 === n3 && (n3 = `${t3}>${e3}`), s3.length > 0) {
        const t4 = bd.newOrRecycled();
        n3 += JSON.stringify(t4.encode(s3));
      }
      return n3;
    }
    function cd(t3, e3) {
      return (e3 - t3 | 0) >= 0;
    }
    var dd = class _dd {
      constructor(t3, e3, s3, n3, i3) {
        this.time = t3, this.seq = e3, this.receiver = s3, this.selector = n3, this.args = i3;
      }
      before(t3) {
        return this.time !== t3.time ? this.time < t3.time : this.isExternal() !== t3.isExternal() ? t3.isExternal() : this.isExternal() ? cd(this.externalSeq, t3.externalSeq) : cd(this.internalSeq, t3.internalSeq);
      }
      hasReceiver(t3) {
        return this.receiver === t3;
      }
      isExternal() {
        return 1 & this.seq;
      }
      get externalSeq() {
        return this.seq / 2 >>> 0;
      }
      set externalSeq(t3) {
        this.seq = 2 * t3 + 1;
      }
      get internalSeq() {
        return this.seq / 2 >>> 0;
      }
      set internalSeq(t3) {
        this.seq = 2 * t3;
      }
      asState() {
        return [this.time, this.seq, ld(this.receiver, this.selector, this.args)];
      }
      static fromState(t3, e3) {
        const [s3, n3, i3] = t3, { receiver: o3, selector: r2, args: a3 } = function(t4, e4) {
          let s4, n4, i4;
          if (1 === t4.length || "[" === t4[1]) {
            const e5 = parseInt(t4[0], 36);
            s4 = "_", n4 = sd[e5], i4 = t4.slice(1);
          } else {
            const e5 = t4.indexOf(">");
            let o5 = t4.indexOf("[");
            -1 === o5 && (o5 = t4.length), s4 = t4.slice(0, e5), n4 = t4.slice(e5 + 1, o5), i4 = t4.slice(o5);
          }
          let o4 = [];
          i4 && (o4 = yd.newOrRecycled(e4).decode(JSON.parse(i4)));
          return { receiver: s4, selector: n4, args: o4 };
        }(i3, e3);
        return new _dd(s3, n3, o3, r2, a3);
      }
      executeOn(t3) {
        let e3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        t3.currentEventFromModel = !this.isExternal();
        const s3 = e3 ? (t4) => t4() : (e4) => td(t3, () => ee(t3, e4)), { receiver: n3, selector: i3, args: o3 } = this, r2 = t3.lookUpModel(n3);
        if (r2) if ("{" === i3[0]) {
          const e4 = t3.compileFuncString(i3, r2);
          s3(() => {
            try {
              e4(...o3);
            } catch (t4) {
              Pt(`${this.shortString()} ${e4}`, t4);
            }
          });
        } else i3.indexOf(".") >= 0 ? s3(() => {
          const t4 = i3.indexOf("."), e4 = i3.slice(0, t4), s4 = i3.slice(t4 + 1);
          try {
            r2.call(e4, s4, ...o3);
          } catch (t5) {
            Pt(`${this.shortString()} ${r2}.call(${JSON.stringify(e4)}, ${JSON.stringify(s4)})`, t5);
          }
        }) : "function" != typeof r2[i3] ? Ct(`${this.shortString()} ${r2}.${i3}(): method not found`) : s3(() => {
          try {
            if (Ac(i3)) {
              const t4 = r2[i3];
              delete r2[i3], t4(...o3);
            } else r2[i3](...o3);
          } catch (t4) {
            Pt(`${this.shortString()} ${r2}.${i3}()`, t4);
          }
        });
        else Ct(`${this.shortString()} ${i3}(): receiver not found`);
      }
      shortString() {
        return (this.isExternal() ? "External" : "Future") + "Message";
      }
      toString() {
        const { receiver: t3, selector: e3, args: s3 } = this, n3 = this.isExternal(), i3 = n3 ? this.externalSeq : this.internalSeq;
        return `${n3 ? "External" : "Future"}Message[${this.time}${":#"[+n3]}${i3} ${t3}.${e3}(${s3.map(JSON.stringify).join(", ")})]`;
      }
      [Symbol.toPrimitive]() {
        return this.toString();
      }
    };
    var hd = (() => {
      const t3 = new ArrayBuffer(8), e3 = new DataView(t3);
      return (t4) => (e3.setFloat64(0, t4, true), e3.getInt32(0, true) + e3.getInt32(4, true));
    })();
    var ud = class {
      constructor() {
        this.done = /* @__PURE__ */ new Set(), this.todo = [], this.hashers = /* @__PURE__ */ new Map(), this.addHasher("Teatime:Message", dd), this.addHasher("Teatime:Data", Pc), this.addHasher("Teatime:QFunc", Ec);
        for (const [t3, e3] of Sd.allClassTypes()) this.addHasher(t3, e3);
      }
      addHasher(t3, e3) {
        const { cls: s3, write: n3 } = Object.getPrototypeOf(e3) === Object.prototype ? e3 : { cls: e3, write: (t4) => ({ ...t4 }) };
        n3 && this.hashers.set(s3, (t4) => this.hashStructure(t4, n3(t4)));
      }
      getHash(t3) {
        this.hashState = { oC: 0, mC: 0, nanC: 0, infC: 0, zC: 0, nC: 0, nH: 0, sC: 0, sL: 0, fC: 0 };
        for (const [e3, s3] of Object.entries(t3)) if ("controller" !== e3 && "meta" !== e3) if ("_random" === e3) this.hash(s3.state(), false);
        else if ("messages" === e3) {
          const t4 = s3.asArray();
          (this.hashState.fC = t4.length) && this.hash(t4, false);
        } else this.hashEntry(e3, s3);
        return this.hashDeferred(), this.hashState;
      }
      hashDeferred() {
        let t3 = 0;
        for (; t3 < this.todo.length; ) {
          const { key: e3, value: s3 } = this.todo[t3++];
          this.hashEntry(e3, s3, false);
        }
        this.todo.length = 0;
      }
      hash(t3) {
        let e3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        switch (typeof t3) {
          case "number":
            return void (Number.isNaN(t3) ? this.hashState.nanC++ : Number.isFinite(t3) ? 0 === t3 ? this.hashState.zC++ : (this.hashState.nC++, this.hashState.nH += hd(t3)) : this.hashState.infC++);
          case "string":
            return this.hashState.sC++, void (this.hashState.sL += t3.length);
          case "boolean":
          case "undefined":
            return;
          case "bigint":
            if (0n === t3) this.hashState.zC++;
            else {
              this.hashState.nC++;
              const e4 = t3 < 0 ? -1n : 0n;
              for (; t3 !== e4; ) this.hashState.nH += Number(0xFFFFFFFFn & t3), t3 >>= 32n;
            }
            return;
          default: {
            if (this.done.has(t3)) return;
            if (null === t3) return;
            if (this.hashers.has(t3.constructor)) return void this.hashers.get(t3.constructor)(t3);
            const s3 = Object.prototype.toString.call(t3).slice(8, -1);
            if (this.hashers.has(s3)) return void this.hashers.get(s3)(t3);
            switch (s3) {
              case "Array":
                return void this.hashArray(t3, e3);
              case "ArrayBuffer":
                return void this.hashIntArray(new Uint8Array(t3));
              case "Set":
                return void this.hashStructure(t3, [...t3]);
              case "Map":
                return void this.hashStructure(t3, [...t3], false);
              case "DataView":
                return void this.hashIntArray(new Uint8Array(t3.buffer, t3.byteOffset, t3.byteLength));
              case "Int8Array":
              case "Uint8Array":
              case "Uint8ClampedArray":
              case "Int16Array":
              case "Uint16Array":
              case "Int32Array":
              case "Uint32Array":
                return void this.hashIntArray(t3);
              case "Float32Array":
              case "Float64Array":
                return void this.hashArray(t3, false);
              case "Object":
                t3 instanceof Sd ? this.hashModel(t3) : t3.constructor === Object && this.hashObject(t3, e3);
            }
          }
        }
      }
      hashModel(t3) {
        this.hashState.mC++, this.done.add(t3);
        for (const [e3, s3] of Object.entries(t3)) "__realm" !== e3 && void 0 !== s3 && this.hashEntry(e3, s3);
      }
      hashObject(t3) {
        let e3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        this.hashState.oC++, this.done.add(t3);
        for (const [s3, n3] of Object.entries(t3)) void 0 !== n3 && this.hashEntry(s3, n3, e3);
      }
      hashArray(t3) {
        let e3 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
        this.done.add(t3);
        for (let s3 = 0; s3 < t3.length; s3++) this.hashEntry(s3, t3[s3], e3);
      }
      hashIntArray(t3) {
        this.done.add(t3);
        for (let e3 = 0; e3 < t3.length; e3++) {
          const s3 = t3[e3];
          0 === s3 ? this.hashState.zC++ : (this.hashState.nC++, this.hashState.nH += s3);
        }
      }
      hashStructure(t3, e3) {
        let s3 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
        void 0 !== e3 && (this.done.add(t3), this.hash(e3, s3));
      }
      hashEntry(t3, e3) {
        let s3 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
        "$" !== t3[0] && (s3 && "object" == typeof e3 ? this.todo.push({ key: t3, value: e3 }) : this.hash(e3, s3));
      }
    };
    var md = class {
      static newOrRecycled(t3) {
        let e3 = this.reusableInstance;
        return e3 ? (e3.vm = t3, e3.nextRef = 1, e3.refs = /* @__PURE__ */ new Map(), e3.todo = []) : e3 = this.reusableInstance = new this(t3), e3;
      }
      static get reusableInstance() {
        return this[this.name + "-instance"];
      }
      static set reusableInstance(t3) {
        this[this.name + "-instance"] = t3;
      }
      static resetInstance() {
        this.reusableInstance = null;
      }
      constructor(t3) {
        this.vm = t3, this.nextRef = 1, this.refs = /* @__PURE__ */ new Map(), this.todo = [], this.writers = /* @__PURE__ */ new Map(), this.addWriter("Teatime:Message", dd), this.addWriter("Teatime:Data", Pc), this.addWriter("Teatime:QFunc", Ec);
        for (const [t4, e3] of Sd.allClassTypes()) this.addWriter(t4, e3);
        this.okayToIgnore = { $debugWriteProxyHandler: true };
        for (const t4 of Sd.allClasses()) if (Object.prototype.hasOwnProperty.call(t4, "okayToIgnore")) {
          const e3 = t4.okayToIgnore();
          if (!Array.isArray(e3)) throw new Error("okayToIgnore() must return an array");
          for (const t5 of e3) {
            if ("$" !== t5[0]) throw Error(`okayToIgnore: ignored prop "${t5}" must start with '$'`);
            this.okayToIgnore[t5] = true;
          }
        }
      }
      addWriter(t3, e3) {
        const s3 = Object.getPrototypeOf(e3) === Object.prototype, { cls: n3, write: i3 } = s3 ? e3 : { cls: e3, write: (t4) => ({ ...t4 }) };
        if (n3 === Object) throw Error(`${Qt.libName} types: '${t3}' is the Object class itself, must be a user class`);
        if (n3 === Array) throw Error(`${Qt.libName} types: '${t3}' is the Array class, must be a user class`);
        i3 ? this.writers.set(n3, (e4, o3) => this.writeAs(t3, e4, i3(e4), s3 ? `${o3}.write(${n3.name})` : o3)) : e3.writeStatic || console.warn(`${Qt.libName} types: ${t3} does not implement write() or writeStatic()`);
      }
      snapshot(t3, e3) {
        const s3 = { _random: t3._random.state(), messages: this.write(t3.messages.asArray(), "FutureMessages"), subscribers: void 0, controller: void 0, $compiledFuncs: void 0 };
        this.writeAllStaticInto(s3);
        for (const [n3, i3] of Object.entries(t3)) n3 in s3 || this.writeInto(s3, n3, i3, e3);
        return this.writeDeferred(), delete s3.controller, delete s3.subscribers, delete s3.$compiledFuncs, s3;
      }
      writeAllStaticInto(t3) {
        for (const e3 of Sd.allClasses()) if (e3 !== Sd) for (const [s3, n3] of Object.entries(e3)) {
          if ("$" === s3[0]) continue;
          const i3 = Sd.classToID(e3);
          t3.staticModelProps || (t3.staticModelProps = {}), i3 in t3.staticModelProps || (t3.staticModelProps[i3] = {}), this.writeInto(t3.staticModelProps[i3], s3, n3, `Model(${i3}).static`), Zd("Model", i3);
        }
        for (const [e3, s3] of Sd.allClassTypes()) if ("object" == typeof s3) {
          const { writeStatic: n3 } = s3;
          if (n3) {
            const s4 = n3();
            s4 && (t3.staticTypeProps || (t3.staticTypeProps = {}), t3.staticTypeProps[e3] = this.write(s4, `Type(${e3}).writeStatic()`), Zd("Type", e3));
          }
        }
      }
      writeDeferred() {
        let t3 = 0;
        for (; t3 < this.todo.length; ) {
          const { state: e3, key: s3, value: n3, path: i3 } = this.todo[t3++];
          this.writeInto(e3, s3, n3, i3, false);
        }
        this.todo.length = 0;
      }
      write(t3, e3) {
        let s3 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
        switch (typeof t3) {
          case "number":
            return Object.is(t3, -0) ? { $class: "NegZero" } : Number.isFinite(t3) ? t3 : Number.isNaN(t3) ? { $class: "NaN" } : { $class: "Infinity", $value: Math.sign(t3) };
          case "string":
          case "boolean":
            return t3;
          case "undefined":
            return { $class: "Undefined" };
          case "bigint":
            return { $class: "BigInt", $value: t3.toString() };
          default: {
            if (this.refs.has(t3)) return this.writeRef(t3);
            if (null === t3) return t3;
            if (this.writers.has(t3.constructor)) return this.writers.get(t3.constructor)(t3, e3);
            const n3 = Object.prototype.toString.call(t3).slice(8, -1);
            if (this.writers.has(n3)) return this.writers.get(n3)(t3, e3);
            switch (n3) {
              case "Array":
                return this.writeArray(t3, e3, s3);
              case "ArrayBuffer":
                return this.writeArrayBuffer(t3);
              case "Set":
                return this.writeAs(n3, t3, [...t3], e3);
              case "Map":
                return this.writeAs(n3, t3, [...t3].flat(), e3);
              case "DataView":
              case "Int8Array":
              case "Uint8Array":
              case "Uint8ClampedArray":
              case "Int16Array":
              case "Uint16Array":
              case "Int32Array":
              case "Uint32Array":
              case "Float32Array":
              case "Float64Array":
                return this.writeTypedArray(n3, t3);
              case "Object":
                if (t3 instanceof Sd) return this.writeModel(t3, e3);
                if (t3.constructor === Object || "function" != typeof t3.constructor) return this.writeObject(t3, e3, s3);
                throw console.warn(`${Qt.libName}: unknown class at ${e3}:`, t3), Error(`${Qt.libName}: class not registered in Model.types(): ${t3.constructor.name}`);
              case "Function":
                if (t3[Nc]) return this.writers.get(Nc)(t3, e3);
                throw console.warn(`${Qt.libName}: found function at ${e3}:`, t3), Error(`${Qt.libName}: cannot serialize functions except for QFuncs`);
              default:
                throw console.warn(`${Qt.libName}: unsupported property at ${e3}:`, t3), Error(`${Qt.libName}: serialization of ${n3}s is not supported`);
            }
          }
        }
      }
      writeModel(t3, e3) {
        const s3 = {};
        this.refs.set(t3, s3);
        try {
          s3.$model = Sd.classToID(t3.constructor);
        } catch (s4) {
          throw console.error(`unregistered model class at ${e3}:`, t3), s4;
        }
        for (const e4 of Object.keys(t3).sort()) {
          if ("__realm" === e4) continue;
          const n3 = t3[e4];
          ("number" == typeof n3 && Number.isFinite(n3) && !Object.is(n3, -0) || "string" == typeof n3 || "boolean" == typeof n3) && "$" !== e4[0] ? s3[e4] = n3 : this.writeInto(s3, e4, n3, `${t3}`, true);
        }
        return s3;
      }
      writeObject(t3, e3) {
        let s3 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
        const n3 = {};
        this.refs.set(t3, n3);
        for (const i3 of Object.keys(t3).sort()) {
          const o3 = t3[i3];
          ("number" == typeof o3 && Number.isFinite(o3) && !Object.is(o3, -0) || "string" == typeof o3 || "boolean" == typeof o3) && "$" !== i3[0] ? n3[i3] = o3 : this.writeInto(n3, i3, o3, e3, s3);
        }
        return n3;
      }
      writeArray(t3, e3) {
        let s3 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
        const n3 = [];
        this.refs.set(t3, n3);
        for (let i3 = 0; i3 < t3.length; i3++) {
          const o3 = t3[i3];
          "number" == typeof o3 && Number.isFinite(o3) && !Object.is(o3, -0) || "string" == typeof o3 || "boolean" == typeof o3 ? n3[i3] = o3 : this.writeInto(n3, i3, o3, e3, s3);
        }
        return n3;
      }
      writeArrayBuffer(t3) {
        const e3 = { $class: "ArrayBuffer", $value: Xd(t3) };
        return this.refs.set(t3, e3), e3;
      }
      writeTypedArray(t3, e3) {
        const s3 = { $class: t3, $value: [this.write(e3.buffer), e3.byteOffset, "DataView" === t3 ? e3.byteLength : e3.length] };
        return this.refs.set(e3, s3), s3;
      }
      writeAs(t3, e3, s3, n3) {
        const i3 = { $class: t3 };
        this.refs.set(e3, i3);
        const o3 = this.write(s3, n3, false);
        return "object" != typeof o3 || null === o3 || o3.$class || Array.isArray(o3) ? i3.$value = o3 : Object.assign(i3, o3), i3;
      }
      writeRef(t3) {
        const e3 = this.refs.get(t3);
        if ("object" != typeof e3) throw Error("Non-object in refs: " + t3);
        Array.isArray(e3) && (e3.toJSON = function() {
          return { $id: this.$id, $class: "Array", $value: [...this] };
        });
        return { $ref: e3.$id || (e3.$id = this.nextRef++) };
      }
      writeInto(t3, e3, s3, n3) {
        let i3 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
        if ("$" === e3[0]) return void (this.okayToIgnore[e3] || (Ct(`snapshot: ignoring property ${e3} (declare as okayToIgnore to suppress warning)`, { only: "once" }), this.okayToIgnore[e3] = true));
        if (i3 && "object" == typeof s3) return void this.todo.push({ state: t3, key: e3, value: s3, path: n3 });
        const o3 = this.write(s3, n3 + Mc(t3, e3));
        t3[e3] = o3;
      }
    };
    var pd = Symbol("croquet:unresolved");
    var fd = class {
      static newOrRecycled(t3) {
        let e3 = this.reusableInstance;
        return e3 ? (e3.vm = t3, e3.refs = /* @__PURE__ */ new Map(), e3.todo = [], e3.unresolved = [], e3.postprocess = []) : e3 = this.reusableInstance = new this(t3), e3;
      }
      static get reusableInstance() {
        return this[this.name + "-instance"];
      }
      static set reusableInstance(t3) {
        this[this.name + "-instance"] = t3;
      }
      static resetInstance() {
        this.reusableInstance = null;
      }
      constructor(t3) {
        this.vm = t3, this.refs = /* @__PURE__ */ new Map(), this.todo = [], this.unresolved = [], this.postprocess = [], this.readers = /* @__PURE__ */ new Map(), this.addReader("Teatime:Message", dd), this.addReader("Teatime:Data", Pc), this.addReader("Teatime:QFunc", Ec), this.readers.set("Undefined", () => {
        }), this.readers.set("NaN", () => NaN), this.readers.set("Infinity", (t4) => t4 * (1 / 0)), this.readers.set("NegZero", () => -0), this.readers.set("BigInt", (t4) => BigInt(t4)), this.readers.set("ArrayBuffer", (t4) => function(t5) {
          const e3 = globalThis.atob(t5), s3 = e3.length, n3 = new Uint8Array(s3);
          for (let t6 = 0; t6 < s3; t6++) n3[t6] = e3.charCodeAt(t6);
          return n3.buffer;
        }(t4)), this.readers.set("DataView", (t4) => new DataView(...t4)), this.readers.set("Int8Array", (t4) => new Int8Array(...t4)), this.readers.set("Uint8Array", (t4) => new Uint8Array(...t4)), this.readers.set("Uint8ClampedArray", (t4) => new Uint8ClampedArray(...t4)), this.readers.set("Int16Array", (t4) => new Int16Array(...t4)), this.readers.set("Uint16Array", (t4) => new Uint16Array(...t4)), this.readers.set("Int32Array", (t4) => new Int32Array(...t4)), this.readers.set("Uint32Array", (t4) => new Uint32Array(...t4)), this.readers.set("Float32Array", (t4) => new Float32Array(...t4)), this.readers.set("Float64Array", (t4) => new Float64Array(...t4));
        for (const [t4, e3] of Sd.allClassTypes()) this.addReader(t4, e3);
      }
      addReader(t3, e3) {
        let s3 = (t4) => Object.assign(Object.create(e3.prototype), t4);
        "object" == typeof e3 && (s3 = e3.read), this.readers.set(t3, s3);
      }
      enableBackwardCompatibility(t3) {
        var _a3;
        const e3 = (_a3 = t3 == null ? void 0 : t3.meta) == null ? void 0 : _a3.sdk;
        if (!e3) return;
        const [s3, n3, i3, o3] = e3.split(/[-.+]/).map((t4) => +t4);
        let r2 = `${s3}.${n3}`;
        i3 && (r2 += `.${i3}`), o3 && (r2 += `-${o3}`), console.warn(`${Qt.libName}: reading snapshot version ${r2}`), this.compatMaps = s3 < 1 || 1 === s3 && (n3 < 1 || 1 === n3 && i3 < 7);
      }
      readVM(t3, e3, s3) {
        if ("VM" !== e3) throw Error("VirtualMachine must be root object");
        s3 && this.enableBackwardCompatibility(t3);
        const n3 = this.read(t3, e3, false);
        return this.readDeferred(), this.resolveRefs(), this.doPostprocess(), this.readAllStatic(n3), n3;
      }
      readDeferred() {
        let t3 = 0;
        for (; t3 < this.todo.length; ) {
          const { object: e3, key: s3, value: n3, path: i3 } = this.todo[t3++];
          this.readInto(e3, s3, n3, i3, false);
        }
        this.todo.length = 0;
      }
      resolveRefs() {
        for (const { object: t3, key: e3, ref: s3, path: n3 } of this.unresolved) {
          if (!this.refs.has(s3)) throw Error(`Unresolved ref: ${s3} at ${n3}[${JSON.stringify(e3)}]`);
          t3[e3] = this.refs.get(s3);
        }
        this.unresolved.length = 0, this.refs.clear();
      }
      doPostprocess() {
        for (const t3 of this.postprocess) t3();
        this.postprocess.length = 0;
      }
      readAllStatic(t3) {
        const { staticModelProps: e3, staticTypeProps: s3 } = t3, n3 = [];
        if (e3) {
          for (const [t4, s4] of Object.entries(e3)) {
            const e4 = Sd.classFromID(t4);
            n3.push(() => Object.assign(e4, s4)), Zd("Model", t4);
          }
          delete t3.staticModelProps;
        }
        if (s3) {
          const e4 = Object.fromEntries(Sd.allClassTypes());
          for (const [t4, i3] of Object.entries(s3)) {
            const s4 = e4[t4];
            if ("object" == typeof s4) {
              const t5 = s4;
              n3.push(() => t5.readStatic(i3));
            } else {
              const t5 = s4;
              n3.push(() => Object.assign(t5, i3));
            }
            Zd("Type", t4);
          }
          delete t3.staticTypeProps;
        }
        n3.length && (t3.staticInitializers = n3);
      }
      read(t3, e3) {
        let s3 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
        switch (typeof t3) {
          case "number":
          case "string":
          case "boolean":
            return t3;
          default: {
            const n3 = Object.prototype.toString.call(t3).slice(8, -1);
            switch (n3) {
              case "Array":
                return this.readArray(t3, e3, s3);
              case "Null":
                return null;
              case "Object": {
                const { $class: n4, $model: i3, $ref: o3 } = t3;
                if (o3) throw Error("refs should have been handled in readInto()");
                return i3 ? this.readModel(t3, e3) : n4 ? this.readAs(n4, t3, e3) : this.readObject(Object, t3, e3, s3);
              }
              default:
                throw Error(`Don't know how to deserialize ${n3} at ${e3}`);
            }
          }
        }
      }
      readModel(t3, e3) {
        const s3 = Sd.instantiateClassID(t3.$model, t3.id);
        t3.$id && this.refs.set(t3.$id, s3);
        for (const [n3, i3] of Object.entries(t3)) "id" !== n3 && "$" !== n3[0] && this.readInto(s3, n3, i3, e3);
        return s3;
      }
      readObject(t3, e3, s3) {
        let n3 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
        const i3 = new t3();
        e3.$id && this.refs.set(e3.$id, i3);
        for (const [t4, o3] of Object.entries(e3)) "$" !== t4[0] && this.readInto(i3, t4, o3, s3, n3);
        return i3;
      }
      readArray(t3, e3) {
        let s3 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
        const n3 = [];
        t3.$id && this.refs.set(t3.$id, n3);
        for (let i3 = 0; i3 < t3.length; i3++) void 0 !== t3[i3] && this.readInto(n3, i3, t3[i3], e3, s3);
        return n3;
      }
      readAsArray(t3, e3) {
        let s3 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
        const n3 = t3.$value;
        return t3.$id && (n3.$id = t3.$id), this.readArray(n3, e3, s3);
      }
      readAsSet(t3, e3) {
        const s3 = /* @__PURE__ */ new Set();
        t3.$id && this.refs.set(t3.$id, s3);
        const n3 = this.unresolved.length, i3 = this.read(t3.$value, e3, false), o3 = () => {
          for (const t4 of i3) s3.add(t4);
        };
        return this.unresolved.length === n3 ? o3() : this.postprocess.push(o3), s3;
      }
      readAsMap(t3, e3) {
        const s3 = /* @__PURE__ */ new Map();
        t3.$id && this.refs.set(t3.$id, s3);
        const n3 = this.unresolved.length, i3 = this.read(t3.$value, e3, false), o3 = this.compatMaps ? () => {
          if (i3.some((t4) => 2 !== t4.length)) console.warn("Deferring map resolution at", e3), this.postprocess.push(o3);
          else for (const [t4, e4] of i3) s3.set(t4, e4);
        } : () => {
          for (let t4 = 0; t4 < i3.length; t4 += 2) s3.set(i3[t4], i3[t4 + 1]);
        };
        return this.unresolved.length === n3 ? o3() : this.postprocess.push(o3), s3;
      }
      readAsClass(t3, e3, s3) {
        let n3 = {};
        const i3 = /* @__PURE__ */ new Map();
        if ("$value" in e3) n3 = this.read(e3.$value, s3, false);
        else for (const [t4, o4] of Object.entries(e3)) {
          if ("$" === t4[0]) continue;
          const e4 = o4 && o4.$ref;
          e4 ? this.refs.has(e4) ? n3[t4] = this.refs.get(e4) : (n3[t4] = pd, i3.set(e4, t4)) : this.readInto(n3, t4, o4, s3, false);
        }
        const o3 = this.readers.get(t3)(n3, s3);
        o3 || "Undefined" === t3 || "BigInt" === t3 || "NaN" === t3 || "NegZero" === t3 || console.warn(`Reading "${t3}" returned ${o3} at ${s3}`), e3.$id && this.refs.set(e3.$id, o3);
        for (const [t4, e4] of i3.entries()) this.unresolved.push({ object: o3, key: e4, ref: t4, path: s3 });
        return o3;
      }
      readAs(t3, e3, s3) {
        switch (t3) {
          case "Array":
            return this.readAsArray(e3, s3);
          case "Set":
            return this.readAsSet(e3, s3);
          case "Map":
            return this.readAsMap(e3, s3);
          default:
            return this.readAsClass(t3, e3, s3);
        }
      }
      readRef(t3, e3, s3, n3) {
        if (!s3 || !s3.$ref) return false;
        const i3 = s3.$ref;
        return this.refs.has(i3) ? t3[e3] = this.refs.get(i3) : (t3[e3] = pd, this.unresolved.push({ object: t3, key: e3, ref: i3, path: n3 })), true;
      }
      readInto(t3, e3, s3, n3) {
        let i3 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
        this.readRef(t3, e3, s3, n3) || (i3 && "object" == typeof s3 ? this.todo.push({ object: t3, key: e3, value: s3, path: n3 }) : t3[e3] = this.read(s3, n3 + Mc(t3, e3)));
      }
    };
    var bd = class extends md {
      encode(t3) {
        const e3 = this.writeArray(t3, "args");
        return this.writeDeferred(), e3;
      }
      writeModel(t3) {
        return { $ref: t3.id };
      }
    };
    var yd = class extends fd {
      decode(t3) {
        const e3 = this.readArray(t3, "args");
        return this.readDeferred(), this.resolveRefs(), this.doPostprocess(), e3;
      }
      resolveRefs() {
        for (const { object: t3, key: e3, ref: s3, path: n3 } of this.unresolved) if (this.refs.has(s3)) t3[e3] = this.refs.get(s3);
        else {
          const i3 = this.vm.lookUpModel(s3);
          if (!i3) throw Error(`Unresolved ref: ${s3} at ${n3}[${JSON.stringify(e3)}]`);
          t3[e3] = i3;
        }
      }
    };
    var gd = [Object, Array, Map, Set, BigInt, ArrayBuffer, DataView, Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
    function wd(t3, e3, s3, n3) {
      const i3 = Array.isArray(t3) ? t3 : t3.constructor === Set ? t3.values() : t3.constructor === Map ? t3.entries() : Object.values(t3), o3 = [];
      for (const t4 of i3) "object" != typeof t4 || null === t4 || n3.has(t4) || (n3.add(t4), o3.push(t4));
      for (const t4 of o3) {
        if (gd.includes(t4.constructor)) continue;
        const n4 = e3 + "." + t4.constructor.name;
        if (s3[n4]) {
          if (s3[n4] !== t4.constructor) throw new Error("Class with name " + n4 + " already gathered, but new one has different identity");
        } else s3[n4] = t4.constructor;
      }
      for (const t4 of o3) wd(t4, e3, s3, n3);
    }
    function Zd(t3, e3) {
      const s3 = Ot.controllers.size;
      s3 > 1 && Ct(`Static properties in shared ${t3} ${e3} can lead to divergence because ${s3} ${Qt.libName} sessions are running simultaneaously. Consider using wellKnownModel() instead.`, { only: "once" });
    }
    function Xd(t3) {
      const e3 = new Uint8Array(t3), s3 = [];
      for (let t4 = 0; t4 < e3.byteLength; t4 += 4096) {
        const n3 = e3.subarray(t4, t4 + 4096);
        s3.push(String.fromCharCode.apply(null, n3));
      }
      return globalThis.btoa(s3.join(""));
    }
    var vd = { classes: m.has("debug", "classes") };
    var Ld = Symbol("SECRET");
    var xd = /* @__PURE__ */ new WeakSet();
    var Sd = class _Sd {
      static create() {
        if (!Cd(this)) throw Error(`Model class "${this.name}" not registered`);
        const t3 = this, e3 = this.createNoInit();
        return !this.wellKnownModel("modelRoot") && (e3.beWellKnownAs("modelRoot"), e3.__realm.vm.debugEvents && this.eventDebugInit(e3)), xd.add(e3), e3.init(...arguments), xd.has(e3) && (xd.delete(e3), Object.getPrototypeOf(t3) !== _Sd && console.warn(`${e3} did not call super.init(options)`)), e3;
      }
      static createNoInit(t3) {
        const e3 = te(), s3 = new this(Ld);
        return t3 || (t3 = e3.register(s3)), void 0 === vd.write && (vd.write = m.has("debug", "write"), vd.publish = m.has("debug", "publish"), vd.events = m.has("debug", "events")), Object.defineProperty(s3, "__realm", { value: e3, writable: vd.write }), Object.defineProperty(s3, "id", { value: t3, enumerable: true }), s3;
      }
      static allowConstructors() {
        Ld = void 0, console.warn("disabling error reporting for Model constructors");
      }
      static register(t3) {
        return t3 || (t3 = this.name, console.warn(`Deprecation warning: ${this.name}.register(classId) called without classId. See https://croquet.io/docs/croquet/Model.html#.register`)), fd.resetInstance(), md.resetInstance(), bd.resetInstance(), yd.resetInstance(), function(t4, e3) {
          const s3 = _(t4), n3 = Q(`${e3}:${s3}`);
          U.push(n3), n3.then((t5) => j[t5].what = `Class ${e3}`);
        }(this, t3), function(t4, e3) {
          const s3 = Gd[e3];
          if (s3 && s3 !== t4) throw Error(`Registering model class ${t4.name} failed, id "${e3}" already used by ${s3.name}`);
          Cd(t4) ? vd.classes && !s3 && console.warn(`ignoring re-exported model class ${e3}`) : (vd.classes && console.log(`registering model class ${e3}`), t4[Td] = e3);
          Gd[e3] = t4;
        }(this, t3), _Sd.lastRegistered = this, this;
      }
      static wellKnownModel(t3) {
        if (!ad.hasCurrent()) throw Error("static Model.wellKnownModel() called from outside model");
        return ad.current().get(t3);
      }
      static evaluate(t3) {
        return ad.evaluate(t3);
      }
      static isExecuting() {
        return ad.hasCurrent();
      }
      static types() {
        return {};
      }
      static gatherClassTypes(t3, e3) {
        const s3 = {};
        return wd({ root: t3 }, e3, s3, /* @__PURE__ */ new Set()), s3;
      }
      static eventDebugOptions() {
        return vd;
      }
      static eventDebugInit(t3) {
        t3.subscribe("*", "*", t3.createQFunc('\n        function logEvents(data) {\n            // do this now to have no side effects below\n            const { scope, event, source } = this.activeSubscription;\n            // below stuff is outside the model. Must not have any side effects!\n            const debug = this.constructor.eventDebugOptions();\n            if (!debug.events && !debug.publish) return;\n            const action = source === "model" ? "publish" : "receive";\n            const emoji = source === "model" ? "🔮" : "📬";\n            console.log(`${emoji} @${this.now()} Model ${action} ${scope}:${event}`, data);\n        }\n        '));
      }
      static okayToIgnore() {
        return [];
      }
      static classToID(t3) {
        return function(t4) {
          if (Cd(t4)) return t4[Td];
          const e3 = t4.name || "ClassName";
          throw Error(`Model class not registered, did you call ${e3}.register("${e3}")?`);
        }(t3);
      }
      static classFromID(t3) {
        return kd(t3);
      }
      static allClasses() {
        return Wd();
      }
      static allClassTypes() {
        return function() {
          const t3 = {};
          for (const e3 of Wd()) Object.assign(t3, e3.types());
          return Object.entries(t3);
        }();
      }
      static instantiateClassID(t3, e3) {
        return kd(t3).createNoInit(e3);
      }
      constructor(t3) {
        if (t3 !== Ld) throw Error(`You must create ${App.libName} Models using create() not "new"!`);
      }
      init(t3, e3) {
        xd.delete(this);
      }
      destroy() {
        te().unsubscribeAll(this), te().deregister(this);
      }
      publish(t3, e3, s3) {
        this.__realm || this.__realmError(), this.__realm.publish(e3, s3, t3);
      }
      subscribe(t3, e3, s3) {
        return this.__realm || this.__realmError(), this.__realm.subscribe(this, t3, e3, s3);
      }
      unsubscribe(t3, e3) {
        let s3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "*";
        this.__realm || this.__realmError(), this.__realm.unsubscribe(this, t3, e3, s3);
      }
      unsubscribeAll() {
        this.__realm || this.__realmError(), this.__realm.unsubscribeAll(this);
      }
      get activeSubscription() {
        if (!ad.hasCurrent()) return;
        const { currentEvent: t3, currentEventFromModel: e3 } = ad.current();
        if (!t3) return;
        const [s3, n3] = t3.split(":");
        return { scope: s3, event: n3, source: e3 ? "model" : "view" };
      }
      __realmError() {
        if (!this.id) throw Error(`${this} has no ID, did you call super.init(options)?`);
      }
      future() {
        let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0;
        this.__realm || this.__realmError();
        for (var s3 = arguments.length, n3 = new Array(s3 > 2 ? s3 - 2 : 0), i3 = 2; i3 < s3; i3++) n3[i3 - 2] = arguments[i3];
        return this.__realm.future(this, t3, e3, n3);
      }
      cancelFuture(t3) {
        return this.__realm || this.__realmError(), this.__realm.cancelFuture(this, t3);
      }
      random() {
        return te().random();
      }
      now() {
        return te().now();
      }
      beWellKnownAs(t3) {
        te().vm.set(t3, this);
      }
      getModel(t3) {
        return this.__realm.vm.lookUpModel(t3);
      }
      wellKnownModel(t3) {
        return this.__realm.vm.get(t3);
      }
      modelOnly(t3) {
        if (ad.current() === this.__realm.vm) return true;
        const e3 = Error(t3 || `${this}.modelOnly() called from outside a model!`);
        throw Pt("view code", e3), e3;
      }
      get sessionId() {
        return this.__realm.vm.id;
      }
      get viewCount() {
        return Object.keys(this.__realm.vm.views).length;
      }
      createQFunc(t3, e3) {
        return void 0 === e3 && (e3 = t3, t3 = {}), zc(this, t3, e3);
      }
      persistSession(t3) {
        if (this !== this.wellKnownModel("modelRoot")) throw Error("persistSession() must only be called on the root model");
        this.__realm.vm.persist(this, t3);
      }
      [Symbol.toPrimitive]() {
        return `${this.constructor[Td] || this.constructor.name}#${this.id}`;
      }
    };
    var Gd = {};
    var Td = Symbol("CLASS_ID");
    function Wd() {
      return Object.values(Gd);
    }
    function Cd(t3) {
      return Object.prototype.hasOwnProperty.call(t3, Td);
    }
    function kd(t3) {
      if (Gd[t3]) return Gd[t3];
      throw Error(`Model class "${t3}" in snapshot, but not registered?`);
    }
    var Pd = "Croquet.Model";
    var Id;
    Sd[Td] = Pd, Gd[Pd] = Sd;
    var Rd = class {
      static displayStatus(t3, e3) {
        return kt(t3, e3);
      }
      static displayWarning(t3, e3) {
        return Ct(t3, e3);
      }
      static displayError(t3, e3) {
        return function(t4) {
          let e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          return t4 && Qt.showMessage(t4, { ...e4, level: "error" });
        }(t3, e3);
      }
      constructor(t3) {
        "object" == typeof t3 && "__realm" in t3 || console.warn(`${Qt.libName}: argument to View constructor needs to be a Model`);
        let e3 = te("");
        e3 && e3.isViewRealm() || (e3 = se(t3.__realm.vm, () => te(), true)), Object.defineProperty(this, "realm", { value: e3 }), Object.defineProperty(this, "id", { value: e3.register(this), configurable: true });
        const s3 = e3.controller.session;
        if (s3.view || (s3.view = this), Id || (Id = { events: m.has("debug", "events"), publish: m.has("debug", "publish") }), s3.view === this && (Id.events || Id.publish)) {
          const t4 = (t5) => {
            if (!e3.vm.debugEvents) return;
            const { scope: s5, event: n4, source: i3, subscribed: o3 } = this.activeSubscription;
            if (!o3 && !Id.publish) return;
            const r2 = "view" === i3 ? "publish" : "receive", a3 = "view" === i3 ? "📮" : "👁️", l3 = o3 || "publish" === r2 ? "" : " (no subscribers)";
            console.log(`${a3} View ${r2} ${s5}:${n4}${l3}`, t5);
          }, s4 = (e4) => "view" === this.activeSubscription.source && t4(e4), n3 = (e4) => "model" === this.activeSubscription.source && t4(e4);
          s4.__CROQUET__ = true, n3.__CROQUET__ = true, this.subscribe("*", { event: "*", handling: "queued" }, n3), this.subscribe("*", { event: "*", handling: "immediate" }, s4);
        }
      }
      detach() {
        this.unsubscribeAll(), this.realm.deregister(this), Object.defineProperty(this, "id", { value: "" });
      }
      reattach() {
        Object.defineProperty(this, "id", { value: this.realm.register(this) });
      }
      publish(t3, e3, s3) {
        this.realm.publish(e3, s3, t3);
      }
      subscribe(t3, e3, s3) {
        if ("string" == typeof s3 && (s3 = this[s3]), "function" != typeof s3) throw Error(`${Qt.libName}: subscribe() handler is not a function`);
        const n3 = s3;
        (s3 = n3.bind(this)).unbound = n3;
        const { event: i3, handling: o3 } = e3.event ? e3 : { event: e3 };
        this.realm.subscribe(i3, this.id, s3, t3, o3);
      }
      unsubscribe(t3, e3) {
        let s3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
        "string" == typeof s3 && (s3 = this[s3]), this.realm.unsubscribe(e3, this.id, s3, t3);
      }
      unsubscribeAll() {
        this.realm.unsubscribeAll(this.id);
      }
      get activeSubscription() {
        const { currentEvent: t3, currentEventFromModel: e3, currentEventOnlyGeneric: s3 } = Ot;
        if (!t3) return;
        const [n3, i3] = t3.split(":");
        return { scope: n3, event: i3, source: e3 ? "model" : "view", subscribed: !s3 };
      }
      future() {
        let t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
        return this.realm.future(this, t3);
      }
      random() {
        return te().random();
      }
      now() {
        return this.realm.now();
      }
      externalNow() {
        return this.realm.externalNow();
      }
      extrapolatedNow() {
        return this.realm.extrapolatedNow();
      }
      update(t3) {
      }
      wellKnownModel(t3) {
        return this.realm.vm.get(t3);
      }
      get sessionId() {
        return this.realm.controller.sessionSpec.id;
      }
      get session() {
        if (this.id && this.realm.valid()) return this.realm.controller.session;
      }
      get viewId() {
        return this.realm.controller.viewId;
      }
      [Symbol.toPrimitive]() {
        const t3 = this.constructor.name;
        return t3.includes("View") ? t3 : `${t3}[View]`;
      }
    };
    var Vd = new class {
      constructor() {
        this.ready = false, this.isInIframe = window.top !== window, this.subscriptions = {}, this.enumerator = null;
      }
      setReceiver(t3) {
        this.receiver = t3, this.ready = true;
      }
      setIframeEnumerator(t3) {
        this.enumerator = t3;
      }
      on(t3, e3) {
        if (!this.receiver) throw Error("setReceiver() has not been called");
        if ("string" == typeof e3 && (e3 = this.receiver[e3]), !e3) throw Error("Messenger.on: the second argument must be a method name or a function");
        if (this.subscriptions[t3]) {
          if (this.findIndex(this.subscriptions[t3], e3) >= 0) throw Error(`${e3} is already subscribed`);
        } else this.subscriptions[t3] = [];
        this.subscriptions[t3].push(e3), this.listener || (this.listener = (t4) => this.receive(t4), window.addEventListener("message", this.listener));
      }
      detach() {
        this.listener && (window.removeEventListener("message", this.listener), this.listener = null), this.stopPublishingPointerMove(), this.receiver = null, this.subscriptions = {}, this.enumerator = null, this.ready = false;
      }
      removeSubscription(t3, e3) {
        "string" == typeof e3 && (e3 = this.receiver[e3]);
        const s3 = this.subscriptions[t3];
        if (s3) {
          const n3 = this.findIndex(s3, e3);
          s3.splice(n3, 1), 0 === s3.length && delete this.subscriptions[t3];
        }
      }
      removeAllSubscriptions() {
        this.subscriptions = {};
      }
      receive(t3) {
        const { event: e3, data: s3 } = t3.data, n3 = t3.source;
        this.handleEvent(e3, s3, n3);
      }
      handleEvent(t3, e3, s3) {
        const n3 = this.subscriptions[t3];
        n3 && n3.forEach((t4) => {
          t4.call(this.receiver, e3, s3);
        });
      }
      send(t3, e3, s3) {
        if (this.isInIframe) return void window.top.postMessage({ event: t3, data: e3 }, "*");
        if (s3) return void s3.postMessage({ event: t3, data: e3 }, "*");
        if (!this.enumerator) return;
        this.enumerator().forEach((s4) => {
          s4.contentWindow.postMessage({ event: t3, data: e3 }, "*");
        });
      }
      findIndex(t3, e3) {
        const s3 = e3.name;
        return t3.findIndex((t4) => {
          const n3 = t4.name;
          return s3 || n3 ? s3 === n3 : e3 === t4;
        });
      }
      startPublishingPointerMove() {
        this._moveHandler || (this._moveHandler = (t3) => this.send("pointerPosition", { x: t3.clientX, y: t3.clientY, type: t3.type }), window.document.addEventListener("pointermove", this._moveHandler, true));
      }
      stopPublishingPointerMove() {
        this._moveHandler && (window.document.removeEventListener("pointermove", this._moveHandler, true), this._moveHandler = null);
      }
    }();
    var Yd = "node" === l2.CROQUET_PLATFORM;
    var Md = 60;
    var Hd = class _Hd {
      static async join(t3) {
        try {
          return await this.join_impl(t3);
        } catch (t4) {
          throw Qt.showMessage(t4.message || t4, { level: "fatal" }), t4;
        }
      }
      static async join_impl(t3) {
        t3.appId || (t3.appId = "no.appId"), t3.name || (t3.name = Qt.autoSession(), t3.password || (t3.password = Qt.autoPassword())), t3.model || (t3.model = Sd.lastRegistered), t3.view || (t3.view = Rd);
        const s3 = [];
        for (const [p2, f2] of Object.entries(t3)) f2 instanceof Promise && s3.push(f2.then((e3) => t3[p2] = e3));
        function n3(t4, e3) {
          return t4 === e3 || t4.prototype instanceof e3;
        }
        if (await Promise.all(s3), t3.box) {
          if ("string" != typeof t3.box) throw Error(`${Qt.libName}: box must be a string in Session.join()!`);
          if (!t3.box.includes("/")) throw Error(`${Qt.libName}: box must be a (partial) URL in Session.join()!`);
        } else if (!t3.reflector || !t3.files) {
          if ("string" != typeof t3.apiKey) throw Error(`${Qt.libName}: no apiKey provided in Session.join()!`);
          if (t3.apiKey.length > 128) throw Error(`${Qt.libName}: apiKey > 128 characters in Session.join()!`);
        }
        if ("string" != typeof t3.name) throw Error(`${Qt.libName}: no session name provided in Session.join()!`);
        if (t3.name.length > 128) throw Error(`${Qt.libName}: session name > 128 characters in Session.join()!`);
        const i3 = t3.model;
        if ("function" != typeof i3 || !n3(i3, Sd)) throw Error(`${Qt.libName}: bad model class in Session.join()`);
        const o3 = t3.view || Rd;
        if ("function" != typeof o3 || !n3(o3, Rd)) throw Error(`${Qt.libName}: bad view class in Session.join()`);
        if ("string" != typeof t3.appId) throw Error(`${Qt.libName}: no appId provided in Session.join()`);
        if (!t3.appId.length > 128) throw Error(`${Qt.libName}: appId > 128 characters in Session.join()`);
        if (!t3.appId.match(/^[a-z](-?[a-z0-9_])*(\.[a-z0-9_](-?[a-z0-9_])*)+$/i)) throw Error(`${Qt.libName}: malformed appId in Session.join()`);
        if ("string" != typeof t3.password || !t3.password) throw Error(`${Qt.libName}: no password provided in Session.join()`);
        for (const b2 of ["reflector", "synchronizer", "files", "backend", "box"]) {
          const y2 = m[b2] || t3[b2];
          void 0 !== y2 && (m[b2] = y2);
        }
        if (Yd && "manual" !== t3.step) throw Error("stepping must be manual in a Node.js app");
        if ("rejoinLimit" in t3) {
          if ("number" != typeof t3.rejoinLimit || t3.rejoinLimit < 0 || t3.rejoinLimit > 6e4) throw Error("rejoinLimit range: 0-60000");
        } else t3.rejoinLimit = 1e3;
        if ("eventRateLimit" in t3) {
          if ("number" != typeof t3.eventRateLimit || t3.eventRateLimit < 1 || t3.eventRateLimit > 60) throw Error("eventRateLimit range: 1-60");
        } else t3.eventRateLimit = 20;
        if (t3.heraldUrl) {
          if (t3.heraldUrl.length > 256) throw Error("heraldUrl can only be 256 characters");
          if (!t3.heraldUrl.startsWith("https://")) throw Error("heraldUrl needs to be https");
        }
        if (t3.hashOverride) {
          if (43 !== t3.hashOverride.length) throw Error("hashOverride must be 43 characters");
          if (-1 !== t3.hashOverride.search(/[^-_a-zA-Z0-9]/)) throw Error("hashOverride must be base64url encoded");
        }
        if (t3.debug) {
          let g2 = function(t4) {
            return "string" == typeof t4 && (t4 = t4.split(",")), t4 ? Array.isArray(t4) ? t4 : [t4] : [];
          };
          m.debug = [...g2(t3.debug), ...g2(m.debug)].join(",");
        }
        if ("autoSleep" in t3) {
          const w2 = t3.autoSleep, Z2 = typeof w2;
          if ("number" === Z2) {
            if (w2 < 0) throw Error("an autoSleep value must be >= 0");
          } else {
            if ("boolean" !== Z2) throw Error("autoSleep must be numeric or boolean");
            t3.autoSleep = w2 ? 10 : 0;
          }
        } else t3.autoSleep = 10;
        if (t3.flags) {
          let X2 = t3.flags;
          "string" == typeof X2 && (X2 = X2.split(",")), X2 = X2 ? Array.isArray(X2) ? X2 : [X2] : [], X2 = X2.filter((t4) => "object" != typeof t4), X2.length ? (t3.flags = {}, X2.forEach((e3) => t3.flags[e3] = true)) : t3.flags = null;
        }
        "expectedSimFPS" in t3 && (Md = Math.min(t3.expectedSimFPS, 120));
        const r2 = ["name", "password", "apiKey", "appId", "tps", "autoSleep", "heraldUrl", "rejoinLimit", "eventRateLimit", "optionsFromUrl", "persistentIdOptions", "viewOptions", "viewData", "viewIdDebugSuffix", "hashOverride", "location", "flags", "progressReporter"];
        !function() {
          if (Object.isFrozen(Kd)) return;
          Nd(Kd), function(t4) {
            const s4 = JSON.stringify(t4, (t5, e3) => "function" == typeof e3 ? _(e3) : e3);
            if ("{}" === s4) return;
            const n4 = JSON.parse(s4), i4 = Q(e2(n4));
            U.push(i4), i4.then((t5) => j[t5].what = `${Qt.libName} Constants`);
          }(Kd);
        }();
        const a3 = new gc(), l3 = JSON.parse(JSON.stringify({ ...t3.options }));
        if (t3.persistentIdOptions) {
          if (!Array.isArray(t3.persistentIdOptions)) throw Error("persistentIdOptions must be an array");
          for (const v2 of t3.persistentIdOptions) if (!(v2 in l3)) throw Error(`persistentIdOptions key "${v2}" not found in options`);
        }
        const c2 = { id: "", persistentId: "", versionId: "", name: t3.name, model: null, view: null, step(t4) {
          a3.stepSession("animation", { frameTime: t4, view: c2.view, expectedSimFPS: Md });
        }, leave: () => _Hd.leave(c2.id), data: { store: (t4, e3) => kc.store(t4, { ...e3, sessionId: c2.id }), fetch: (t4, e3) => kc.fetch(t4, { ...e3, sessionId: c2.id }), hash: (t4) => kc.hash(t4), toId: (t4) => kc.toId(t4), fromId: (t4) => kc.fromId(t4) }, get latency() {
          return a3.latency;
        }, get latencies() {
          return a3.latencies;
        } };
        "undefined" != typeof __CROQUET_DEVTOOLS__ && __CROQUET_DEVTOOLS__.dispatchEvent(new CustomEvent("session", { detail: { session: c2, controller: a3 } }));
        const d2 = { options: l3, initFn: (t4, e3) => i3.create(t4, e3), rebootModelView: u2 };
        for (const [L2, x2] of Object.entries(t3)) r2.includes(L2) && (d2[L2] = x2);
        await a3.initFromSessionSpec(d2);
        let h2 = false;
        return await u2(), "manual" !== t3.step && a3.startStepping(c2.step), c2;
        async function u2() {
          !function() {
            c2.model = null, c2.view && (m.has("debug", "session", false) && console.log(c2.id, "detaching root view"), c2.view.detach(), "" !== c2.view.id && console.warn(`${Qt.libName}: ${c2.view} did not call super.detach()`), c2.view = null);
            Qt.clearSessionMoniker(), Vd.ready && Vd.detach();
          }(), a3.leaving ? a3.leaving(true) : h2 || (h2 = true, await a3.establishSession(d2), h2 = false, c2.model = a3.vm.get("modelRoot"), c2.id = a3.id, c2.persistentId = a3.persistentId, c2.versionId = a3.versionId, a3.session = c2, Qt.makeSessionWidgets(c2.id), a3.inViewRealm(() => {
            m.has("debug", "session", false) && console.log(c2.id, "creating root view"), new o3(c2.model, d2.viewOptions);
          }));
        }
      }
      static async leave(t3) {
        const e3 = function(t4) {
          for (const e4 of bc) if (e4.id === t4) return e4;
          return null;
        }(t3);
        if (!e3) return false;
        e3.reconnectTimeout && (clearTimeout(e3.reconnectTimeout), delete e3.reconnectTimeout);
        const s3 = new Promise((t4) => e3.leaving = t4), n3 = e3.connection;
        return !!n3.connected && (n3.closeConnection(1e3), s3);
      }
      static thisSession() {
        const t3 = ad.current();
        return t3 ? t3.id : "";
      }
      get id() {
        return "";
      }
      get persistentId() {
        return "";
      }
      get versionId() {
        return "";
      }
      get name() {
        return "";
      }
      get data() {
        return {};
      }
      step(t3) {
      }
      leave() {
      }
    };
    var Kd = {};
    function Nd(t3) {
      if (!Object.isFrozen(t3)) {
        Object.freeze(t3);
        for (const e3 of Object.values(t3)) !e3 || "object" != typeof e3 && "function" != typeof e3 || Nd(e3);
      }
    }
    var zd = { Model: Sd, View: Rd, Session: Hd, Data: kc, Constants: Kd, App: Qt, Messenger: Vd, VERSION: Bl };
    Sd.Croquet = zd, Rd.Croquet = zd, "undefined" != typeof __CROQUET_DEVTOOLS__ && __CROQUET_DEVTOOLS__.dispatchEvent(new CustomEvent("load", { detail: { version: Bl } })), "undefined" != typeof globalThis && (globalThis.__CROQUET__ ? console.warn("WARNING: Multiple instances of Croquet being imported.") : globalThis.__CROQUET__ = Bl), exports.App = Qt, exports.Constants = Kd, exports.Data = kc, exports.Messenger = Vd, exports.Model = Sd, exports.Session = Hd, exports.VERSION = Bl, exports.View = Rd;
  }
});

// node_modules/@multisynq/client/dist/multisynq-client.mjs
var import_croquet = __toESM(require_croquet_croquet(), 1);
var s = "1.0.4";
console.log(`Multisynq ${s}`);
var i = { Model: import_croquet.Model, View: import_croquet.View, Session: import_croquet.Session, Data: import_croquet.Data, Constants: import_croquet.Constants, App: import_croquet.App, VERSION: s };
import_croquet.Model.Multisynq = i;
import_croquet.View.Multisynq = i;
typeof globalThis < "u" && (globalThis.__MULTISYNQ__ ? console.warn("WARNING: Multiple instances of Multisynq being imported.") : globalThis.__MULTISYNQ__ = s);
var export_App = import_croquet.App;
var export_Constants = import_croquet.Constants;
var export_Data = import_croquet.Data;
var export_Model = import_croquet.Model;
var export_Session = import_croquet.Session;
var export_View = import_croquet.View;
export {
  export_App as App,
  export_Constants as Constants,
  export_Data as Data,
  export_Model as Model,
  export_Session as Session,
  s as VERSION,
  export_View as View
};
/*! Bundled license information:

toastify-js/src/toastify.js:
  (*!
   * Toastify js 1.12.0
   * https://github.com/apvarun/toastify-js
   * @license MIT licensed
   *
   * Copyright (C) 2018 Varun A P
   *)
*/
//# sourceMappingURL=@multisynq_client.js.map
